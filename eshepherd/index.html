<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>eShepherd</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="eshepherd.png">
  <link rel="icon" type="image/png" sizes="16x16" href="eshepherd.png">
  <link rel="apple-touch-icon" href="eshepherd.png">
  <link rel="shortcut icon" href="eshepherd.png">
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <!-- Client Vector Search Library - loaded dynamically via esm.sh -->
  <!--1. Link Vue Javascript & Konva-->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <!--2. Link VueKonva Javascript -->
  <script src="https://unpkg.com/vue-konva@3/dist/vue-konva.umd.js"></script>
  <!-- Load utility modules -->
  <script type="module" src="utils-loader.js"></script>
  <!-- Load component modules -->
  <script type="module" src="components-loader.js"></script>
  <!-- Replace Tailwind CDN with a local installation or CLI setup for production -->
</head>
<body class="bg-gray-100">
  <div id="app">
    <!-- Top Banner -->
    <header :class="['fixed top-0 inset-x-0 h-10 bg-gray-800 text-white grid grid-cols-3 items-center px-3 text-sm shadow z-10 transition-transform duration-300', { '-translate-y-full': !bannerVisible }]">
      <div class="flex items-center">
        <button v-if="user" @click="toggleSidebar" class="flex items-center gap-1 rounded px-2 py-1 bg-gray-700 hover:bg-gray-600 active:bg-gray-500 text-xs">
          <svg class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M4 6h16v2H4V6Zm0 5h10v2H4v-2Zm0 5h16v2H4v-2Z"/></svg>
          <span>{{ sidebarCollapsed ? 'Show Sessions' : 'Hide Sessions' }}</span>
        </button>
      </div>
      <div class="text-center font-semibold tracking-wide text-orange-500">eShepherd</div>
      <div class="flex justify-end">
        <button v-if="user" @click="signOut" class="text-xs text-gray-300 hover:text-white">Sign Out</button>
      </div>
    </header>
    
    <!-- Main Content Area -->
    <div :class="['main-content', { 'banner-hidden': !bannerVisible }]">
      <!-- Left Pane: Control Side Panel -->
      <div :class="['directory-pane text-xs transition-all duration-200 bg-blue-50', { 'border-r border-gray-200': !sidebarCollapsed }]" :style="sidebarCollapsed ? { width: '0px', minWidth: '0px' } : { minWidth: '200px' }" id="directoryPane">
        <control-side-panel
          v-show="!sidebarCollapsed && user"
          :user="user"
          :loading="loading"
          :sessions="sessions"
          :selected-session-name="selectedSessionName"
          :selected-file="selectedFile"
          :people-retrieval-status="peopleRetrievalStatus"
          :people-retrieval-count="peopleRetrievalCount"
          :selected-key-box="selectedKeyBox"
          :selected-point-label-id="selectedPointLabelId"
          :labelling-started="labellingStarted"
          :search-query="searchQuery"
          :search-results="searchResults"
          :selected-search-index="selectedSearchIndex"
          :face-guesses="faceGuesses"
          :planning-centre-people="planningCentrePeople"
          :checking-embedding-in-d-b="checkingEmbeddingInDB"
          :check-in-overlay-selection="checkInOverlaySelection"
          :check-in-submitting="checkInSubmitting"
          :check-in-error="checkInError"
          :check-in-success-message="checkInSuccessMessage"
          :show-faces="showFaces"
          :face-labels="faceLabels"
          :face-scanning-status="faceScanningStatus"
          :face-scan-count="faceScanCount"
          :checked-people-by-box="checkedPeopleByBox"
          :checked-people-by-point="checkedPeopleByPoint"
          :point-label-persons="pointLabelPersons"
          :embeddings-stored="embeddingsStored"
          :embeddings-count-cache="embeddingsCountCache"
          :face-match-cache="faceMatchCache"
          :embedding-index="embeddingIndex"
          @session-change="onSessionChange"
          @faces-button-click="handleFacesButtonClick"
          @fetch-planning-centre-people="fetchPlanningCentrePeople"
          @reload-embeddings="reloadEmbeddingsIndex"
          @search-input="searchQuery = $event"
          @search-results-change="searchResults = $event"
          @search-index-change="selectedSearchIndex = $event"
          @face-guesses-clear="faceGuesses = []"
          @face-guesses-update="faceGuesses = $event"
          @load-face-guesses="loadAllStoredEmbeddings()"
          @select-person="selectPerson"
          @selected-person-checkbox-change="handleSelectedPersonCheckboxChange"
          @household-checkbox-change="handleHouseholdCheckboxChange"
          @selected-point-person-checkbox-change="handleSelectedPointPersonCheckboxChange"
          @point-household-checkbox-change="handlePointHouseholdCheckboxChange"
          @store-embeddings="handleStoreEmbeddings"
          @open-check-in-overlay="openCheckInOverlay"
        ></control-side-panel>
      </div>

      <!-- Resizer -->
      <div class="resizer" id="resizer" v-show="!sidebarCollapsed && user"></div>

      <!-- Right Pane: Image Annotation Panel -->
      <image-annotation-panel
        ref="imageAnnotationPanel"
        :user="user"
        :loading="loading"
        :error="error"
        :selected-image="selectedImage"
        :selected-file="selectedFile"
        :image-loading="imageLoading"
        :current-folder-files="currentFolderFiles"
        :current-file-index="currentFileIndex"
        :has-prev-image="hasPrevImage"
        :has-next-image="hasNextImage"
        :selected-bounding-box-index="selectedBoundingBoxIndex"
        :selected-overlap-box="selectedOverlapBox"
        :annotations="annotations"
        :show-faces="showFaces"
        :face-labels="faceLabels"
        :point-labels="pointLabels"
        :selected-point-label-id="selectedPointLabelId"
        :selected-key-box="selectedKeyBox"
        :point-label-persons="pointLabelPersons"
        :checked-people-by-point="checkedPeopleByPoint"
          :checked-people-by-box="checkedPeopleByBox"
          :planning-centre-people="planningCentrePeople"
          :ensure-url-valid="ensureUrlValid"
          :fetch-model-data="fetchModelData"
          @sign-in="signIn"
        @file-change="selectedFile = $event"
        @image-change="selectedImage = $event"
        @file-index-change="currentFileIndex = $event"
        @clear-selection="handleClearSelection"
        @banner-visibility-change="handleBannerVisibilityChange"
        @update-annotations="annotations = $event"
        @loading-change="imageLoading = $event"
        @cluster-box-click="onClusterBoxClick"
        @cluster-box-deselected="onClusterBoxDeselected"
        @point-label-click="onPointLabelClick"
        @point-label-create="onPointLabelCreate"
      >
        <!-- Check-In Overlay (inside image-annotation-panel for proper positioning) -->
        <check-in-overlay
          :show="showCheckInOverlay"
          :table-data="getCheckInTableData()"
          :selection="checkInOverlaySelection"
          :selected-count="getOverlaySelectedCount()"
          :total-count="getCheckInTableData().length"
          :all-selected="areAllCheckInSelected()"
          :submitting="checkInSubmitting"
          :error="checkInError"
          :success-message="checkInSuccessMessage"
          :user="user"
          @close="closeCheckInOverlay"
          @toggle-select-all="toggleCheckInSelectAll"
          @checkbox-change="handleCheckInTableCheckboxChange"
          @submitting-change="checkInSubmitting = $event"
          @error-change="checkInError = $event"
          @success-message-change="checkInSuccessMessage = $event"
        ></check-in-overlay>
      </image-annotation-panel>
          </div>
        </div>
        
  <script>
    // Wait for Utils and Components to be loaded from modules
    (async function() {
      // Wait for Utils to be available (loaded by utils-loader.js)
      while (!window.Utils || Object.keys(window.Utils).length === 0) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      // Wait for Components to be available (loaded by components-loader.js)
      while (!window.Components || Object.keys(window.Components).length === 0) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      // Firebase is initialized in utils-loader.js (config/firebase.js)
      // Access via window.firebaseAuth and window.firebaseDatabase
      const auth = window.firebaseAuth;
      const database = window.firebaseDatabase;

      // Utils and Services are now loaded from utils-loader.js module
      const Utils = window.Utils;
      const Services = window.Services;

    const VueKonva = window['vue-konva'].default;
    const app = Vue.createApp({
          data() {
        return {
          directoryTree: [],
          selectedImage: null,
          selectedFile: null,
          selectedSession: null,
          selectedSessionName: '',
          annotations: [],
          currentFolderFiles: [],
          currentFileIndex: -1,
          sidebarCollapsed: false,
          user: null,
          loading: true,
          imageLoading: false,
          error: null,
          touchStartX: null,
          touchStartY: null,
          bannerVisible: true,
          isSwipe: false,
          showFaces: false,
          labellingStarted: false,
          peopleRetrievalStatus: 'idle', // 'idle', 'retrieving', 'completed'
          peopleRetrievalCount: 0,
          planningCentrePeople: [], // Store the actual records
          selectedBoundingBoxIndex: null, // Index of the selected bounding box
          pointLabels: {}, // Map of "imageName" to array of point labels: {imageName: [{id, x, y, naturalX, naturalY}]}
          selectedPointLabelId: null, // ID of the selected point label (null if none selected)
          pointLabelPersons: {}, // Map of point label ID to selected person record (similar to faceLabels)
          checkedPeopleByPoint: {}, // Per-point-label checked people: { [pointLabelId]: { [personId]: true/false } }
          faceLabels: {}, // Map of "imageName_x_y_w_h" to selected person record (persists per session)
          searchQuery: '',
          searchResults: [],
          selectedSearchIndex: -1, // Index of the highlighted search result
          faceGuesses: [], // Top 5 matches for the selected bounding box: [{person, similarity}]
          currentSessionLabels: {}, // Store labels for current session
          searchResultRefs: {}, // Refs to search result elements for scrolling
          selectedPersonChecked: true, // Track if selected person checkbox is checked (for current selection UI)
          householdCheckboxes: {}, // Track household member checkboxes state (for current selection UI)
          checkedPeopleByBox: {}, // Per-bounding-box checked people: { [faceLabelKey]: { [personId]: true/false } }
          embeddingsStored: {}, // Track if embeddings are stored for each bounding box (keyed by face label key)
          embeddingsCountCache: {}, // Cache for embeddings count per person ID
          currentEmbeddingData: null, // Store current embedding data for comparison
          checkingEmbeddingInDB: false, // Track if we're currently checking embedding in DB
          embeddingIndex: null, // EmbeddingIndex from client-vector-search
          ClientVectorSearchModule: null, // Store the imported module
          faceMatchCache: {}, // Cache face matches per image: {imageKey: {embeddingIndex: {personId, similarity, person}}}
          SIMILARITY_THRESHOLD: 0.80, // Cosine similarity threshold for face matching (0.75 is good for face recognition)
          faceScanningStatus: {}, // Track face scanning status per image: {imageKey: 'scanning' | 'scanned' | null}
          faceScanCount: {}, // Track number of faces scanned per image: {imageKey: number}
          showCheckInOverlay: false, // Control visibility of check-in overlay
          checkInSubmitting: false, // Track check-in submission state
          checkInError: null, // Store check-in error messages
          checkInSuccessMessage: '', // Store success message after check-in
          checkInOverlaySnapshot: [], // Person IDs captured when opening overlay
          checkInOverlaySelection: {}, // Overlay-specific checkbox states
          selectedKeyBox: null // Unified selection: tracks selected cluster's key box { clusterId, sourceFile, embeddingIndex, facialArea, sourceImage, isKeyBoxFromCurrentImage }
        };
      },
      methods: {
        async handleFacesButtonClick() {
          if (!this.labellingStarted) {
            // Start labelling: show faces and fetch planning centre people
            this.labellingStarted = true;
            this.showFaces = true;
            await this.fetchPlanningCentrePeople();
          } else {
            // Toggle faces visibility
            this.showFaces = !this.showFaces;
          }
        },
        async signIn() {
          const result = await Services.auth.signIn();
          if (result.user) {
            this.user = result.user;
            this.error = null;
            await this.fetchDirectoryTree();
          } else {
            this.error = result.error || 'Sign in failed';
          }
        },
        async signOut() {
          const result = await Services.auth.signOut();
          if (!result.error) {
            this.user = null;
            this.directoryTree = [];
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedFile = null;
            this.selectedSession = null;
            this.selectedSessionName = '';
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        toggleSidebar() {
          this.sidebarCollapsed = !this.sidebarCollapsed;
          this.bannerVisible = true; // Show banner when interacting with UI
        },
        updateFolderContextFromSelected(node) {
          // Find parent and its file list; then set current index
          const result = this.findParentAndIndexByMediaLink(this.directoryTree, node.url, null);
          if (result && result.parent) {
            const files = result.parent.children.filter(child => child.type === 'file');
            const idx = files.findIndex(f => f.url === node.url);
            this.currentFolderFiles = files;
            this.currentFileIndex = idx;
          } else {
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        findParentAndIndexByMediaLink(nodes, url, parent) {
          if (!nodes) return null;
          for (const n of nodes) {
            if (n.type === 'file' && n.url === url) {
              return { parent, node: n };
            }
            if (n.children && n.children.length) {
              const res = this.findParentAndIndexByMediaLink(n.children, url, n);
              if (res) return res;
            }
          }
          return null;
        },
        async fetchDirectoryTree() {
          if (!this.user) return;
          
          try {
            this.loading = true;
            const result = await Services.file.fetchDirectoryTree(this.user);
            if (result.items) {
              this.directoryTree = Services.file.transformToTree(result.items);
              // Auto-select the latest session after loading
              this.$nextTick(() => {
                this.selectLatestSession();
              });
            } else {
              this.error = result.error || 'Failed to load images';
            }
          } catch (error) {
            console.error('Error fetching directory tree:', error);
            this.error = 'Failed to load images: ' + error.message;
          } finally {
            this.loading = false;
          }
        },
        isUrlExpired(file) {
          return Services.file.isUrlExpired(file);
        },
        async fetchPlanningCentrePeople() {
          if (!this.user) {
            console.error('User not authenticated');
            return;
          }
          
          try {
            this.peopleRetrievalStatus = 'retrieving';
            const result = await Services.planningCenter.fetchPeople(this.user);
            
            if (result.error) {
              throw new Error(result.error);
            }
            
            this.planningCentrePeople = result.records;
            this.peopleRetrievalCount = result.records.length;
            this.peopleRetrievalStatus = 'completed';
            
            // After loading people, try to match faces in current image
            if (this.selectedFile && this.selectedFile.model) {
              this.$nextTick(() => {
                this.matchFacesInImage(this.selectedFile);
              });
            }
          } catch (error) {
            console.error('Error fetching planning centre people:', error);
            this.peopleRetrievalStatus = 'completed'; // Still mark as completed to show error state
            this.peopleRetrievalCount = 0;
          }
        },
        async refreshUrls() {
          if (!this.user) return false;
          
          try {
            const result = await Services.file.refreshUrls(this.user);
            if (result.items) {
              // Update URLs in the directory tree and currentFolderFiles
              Services.file.updateUrlsInTree(this.directoryTree, result.items, this.currentFolderFiles);
              return true;
            } else {
              return false;
            }
          } catch (error) {
            console.error('Error refreshing URLs:', error);
            return false;
          }
        },
        updateUrlsInTree(tree, items) {
          Services.file.updateUrlsInTree(tree, items, this.currentFolderFiles);
        },
        async ensureUrlValid(file) {
          if (!file) return null;
          return await Services.file.ensureUrlValid(file, this.user, this.directoryTree, () => this.refreshUrls());
        },
        findFileByName(nodes, fileName) {
          return Services.file.findFileByName(nodes, fileName);
        },
        transformToTree(data) {
          return Services.file.transformToTree(data);
        },
        onSessionChange() {
          if (!this.selectedSessionName) return;
          
          // Find the session by name
          const session = this.sessions.find(s => s.name === this.selectedSessionName);
          if (session) {
            this.bannerVisible = true; // Show banner when selecting session
            this.onSelectSession(session);
          }
        },
        getFaceLabelKey(imageName, facialArea) {
          return Utils.getFaceLabelKey(imageName, facialArea);
        },
        async onSelectSession(session) {
          this.selectedSession = session;
          this.selectedSessionName = session.name;
          // Clear labels, checked people, and embeddings stored when session changes
          this.faceLabels = {};
          this.currentSessionLabels = {};
          this.checkedPeopleByBox = {};
          this.embeddingsStored = {};
          this.embeddingsCountCache = {};
          this.currentEmbeddingData = null;
          this.embeddingIndex = null; // Reload embeddings for new session
          this.faceMatchCache = {}; // Clear face match cache
          this.faceScanningStatus = {}; // Clear face scanning status
          this.faceScanCount = {}; // Clear face scan count
          // Get all files from this session (recursively)
          const files = this.getAllFilesFromNode(session);
          this.currentFolderFiles = files;
          
          // Select the first image if available
          if (files.length > 0) {
            this.currentFileIndex = 0;
            this.selectedFile = files[0];
            const validUrl = await this.ensureUrlValid(files[0]);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', files[0].name);
            }
            // Fetch model data if model_url exists
            if (files[0].model_url) {
              this.fetchModelData(files[0]);
            }
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          } else {
            this.currentFileIndex = -1;
            this.selectedFile = null;
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        getAllFilesFromNode(node) {
          return Services.file.getAllFilesFromNode(node);
        },
        async fetchModelData(file) {
          if (!file || !file.model_url) return null;
          
          // If model is already cached, return it
          if (file.model !== null && file.model !== undefined) {
            // If model is loaded and we have faces, try to match them
            if (file.model && file.model.embeddings) {
              this.$nextTick(() => {
                this.matchFacesInImage(file);
              });
            }
            return file.model;
          }
          
          try {
            const response = await fetch(file.model_url);
            if (!response.ok) {
              throw new Error(`Failed to fetch model: ${response.status}`);
            }
            const modelData = await response.json();
            // Cache the model data
            file.model = modelData;
            
            // After loading model, match faces
            this.$nextTick(() => {
              this.matchFacesInImage(file);
            });
            
            return modelData;
          } catch (error) {
            console.error('Error fetching model data:', error);
            // Set to empty object to prevent repeated failed fetches
            file.model = {};
            return null;
          }
        },
        // Decode base64 embedding to Float32Array (numpy float32 array equivalent)
        // Python encoding: np.array(embedding, dtype=np.float32).tobytes() -> base64.b64encode().decode('utf-8')
        decodeEmbeddingFromBase64(base64String) {
          return Utils.decodeEmbeddingFromBase64(base64String);
        },
        // Reload embeddings index from Firebase
        async reloadEmbeddingsIndex() {
          // Clear current index and cache
          this.embeddingIndex = null;
          this.faceMatchCache = {};
          this.faceScanningStatus = {};
          this.faceScanCount = {};
          
          // Reload embeddings (force reload)
          await this.loadAllStoredEmbeddings(true);
          
          // Rescan faces in current image if available
          if (this.selectedFile && this.selectedFile.model) {
            this.$nextTick(() => {
              this.matchFacesInImage(this.selectedFile);
            });
          }
        },
        // Load all embeddings from Firebase and create EmbeddingIndex
        async loadAllStoredEmbeddings(forceReload = false) {
          if (this.embeddingIndex !== null && !forceReload) {
            // Already loaded
            return;
          }
          
          try {
            // Dynamically import client-vector-search from esm.sh
            if (!this.ClientVectorSearchModule) {
              this.ClientVectorSearchModule = await import('https://esm.run/client-vector-search');
            }
            
            this.embeddingIndex = await Services.embedding.loadAllStoredEmbeddings(
              this.ClientVectorSearchModule,
              forceReload,
              this.embeddingIndex
            );
          } catch (error) {
            console.error('Error loading all stored embeddings:', error);
            this.embeddingIndex = null;
          }
        },
        // Match all faces in an image
        async matchFacesInImage(file) {
          if (!file || !file.model || !file.name) {
            return;
          }
          
          const imageKey = file.name;
          
          // Check cache first
          if (this.faceMatchCache[imageKey]) {
            // Apply cached matches
            this.applyFaceMatches(file, this.faceMatchCache[imageKey]);
            // Set status to scanned since we already have cached results
            this.faceScanningStatus[imageKey] = 'scanned';
            // Get face count from model if not cached
            if (!this.faceScanCount[imageKey]) {
              try {
                const model = typeof file.model === 'string' 
                  ? JSON.parse(file.model) 
                  : file.model;
                if (model.embeddings && Array.isArray(model.embeddings)) {
                  this.faceScanCount[imageKey] = model.embeddings.filter(e => e && e.embedding && e.facial_area).length;
                }
              } catch (e) {
                this.faceScanCount[imageKey] = Object.keys(this.faceMatchCache[imageKey]).length;
              }
            }
            this.$forceUpdate();
            return;
          }
          
          // Use utility function
          const matches = await Utils.matchFacesInImage(file, {
            peopleRetrievalStatus: this.peopleRetrievalStatus,
            planningCentrePeople: this.planningCentrePeople,
            faceMatchCache: this.faceMatchCache,
            faceScanningStatus: this.faceScanningStatus,
            faceScanCount: this.faceScanCount,
            embeddingIndex: this.embeddingIndex,
            similarityThreshold: this.SIMILARITY_THRESHOLD,
            loadAllStoredEmbeddings: () => this.loadAllStoredEmbeddings(),
            updateState: (updates) => {
              Object.keys(updates).forEach(key => {
                this[key] = updates[key];
              });
            this.$forceUpdate();
            }
          });
            
            // Apply the matches
          if (matches && Object.keys(matches).length > 0) {
            this.applyFaceMatches(file, matches);
          }
        },
        // Apply face matches to labels
        applyFaceMatches(file, matches) {
          if (!file || !matches || Object.keys(matches).length === 0) {
            return;
          }
          
          Utils.applyFaceMatches(file, matches, {
            faceLabels: this.faceLabels,
            currentSessionLabels: this.currentSessionLabels,
            setPersonCheckedForBox: (key, personId, checked) => this.setPersonCheckedForBox(key, personId, checked),
            updateState: (updates) => {
              Object.keys(updates).forEach(key => {
                this[key] = updates[key];
              });
            this.$forceUpdate();
          }
          });
        },
        formatModel(model) {
          if (!model) return '';
          
          try {
            // If model is already a string, try to parse it as JSON
            if (typeof model === 'string') {
              const parsed = JSON.parse(model);
              return JSON.stringify(parsed, null, 2);
            }
            // If model is an object, stringify it with formatting
            return JSON.stringify(model, null, 2);
          } catch (error) {
            // If parsing fails, return as string
            return typeof model === 'string' ? model : String(model);
          }
        },
        selectLatestSession() {
          // Select the latest session (first one in the sorted list, since we sort latest to earliest)
          if (this.sessions.length > 0) {
            const latestSession = this.sessions[0];
            this.onSelectSession(latestSession);
          }
        },
        handleClearSelection() {
          this.selectedBoundingBoxIndex = null;
          this.selectedPointLabelId = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
        },
        handleBannerVisibilityChange(value) {
          this.bannerVisible = value === null ? !this.bannerVisible : value;
        },
        async onSelectNode(node) {
          if (node.type === 'file') {
            this.selectedFile = node;
            const validUrl = await this.ensureUrlValid(node);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', node.name);
            }
            // Fetch model data if model_url exists
            if (node.model_url) {
              this.fetchModelData(node);
            }
            this.updateFolderContextFromSelected(node);
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        onPointLabelCreate(pointData) {
          if (!this.selectedFile) return;
          
          const imageName = this.selectedFile.name;
          if (!this.pointLabels[imageName]) {
            this.pointLabels[imageName] = [];
          }
          
          // Generate unique ID for the point
          const pointId = `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Add point to the array
          this.pointLabels[imageName].push({
            id: pointId,
            x: pointData.x,
            y: pointData.y,
            naturalX: pointData.naturalX,
            naturalY: pointData.naturalY
          });
          
          // Select the newly created point
          this.selectedPointLabelId = pointId;
          
          // Clear bounding box selection when selecting a point
          this.selectedBoundingBoxIndex = null;
          
          // Initialize checkboxes (no person selected yet for new point)
          this.selectedPersonChecked = true;
          this.householdCheckboxes = {};
          
          // Clear search state
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
          
          // Ensure labelling is started (needed for search box to be visible)
          if (!this.labellingStarted) {
            this.labellingStarted = true;
            this.showFaces = true;
            // Fetch planning centre people if not already loaded
            if (!this.planningCentrePeople || this.planningCentrePeople.length === 0) {
              this.fetchPlanningCentrePeople();
            }
          }
          
          // Focus the search input - use both $nextTick and setTimeout to ensure DOM is ready
          this.$nextTick(() => {
            setTimeout(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            }, 100);
          });
        },
        onPointLabelClick(pointId) {
          // Toggle selection - if clicking the same point, deselect it
          if (this.selectedPointLabelId === pointId) {
            // Check if there's a person selected before deselecting
            const currentLabel = this.getCurrentPointLabel();
            if (!currentLabel) {
              // No person selected, delete the point label
              this.deletePointLabel(pointId);
            }
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          } else {
            this.selectedPointLabelId = pointId;
            // Clear bounding box selection when selecting a point
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentPointLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonCheckedForPoint(pointId, currentLabel.id);
              this.initializeHouseholdCheckboxesForPoint(pointId, currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input (same as bounding box logic)
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          }
        },
        async onClusterBoxClick(keyBoxData) {
          // Unified handler for cluster key box selection
          const { clusterId, sourceFile, embeddingIndex, facialArea, sourceImage, isKeyBoxFromCurrentImage } = keyBoxData;
          
          if (!sourceFile) return;
          
          // Fetch model data if needed (but don't switch images)
          if (sourceFile.model_url && !sourceFile.model) {
            this.fetchModelData(sourceFile);
          }
          
          // Wait for model to be available if needed
          if (!sourceFile.model && sourceFile.model_url) {
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          
          // Clear point label selection when selecting a cluster box
          this.selectedPointLabelId = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
          this.faceGuesses = [];
          
          // Store unified key box selection
          this.selectedKeyBox = {
            clusterId,
            sourceFile,
            embeddingIndex,
            facialArea,
            sourceImage,
            isKeyBoxFromCurrentImage
          };
          
          // Initialize checkboxes if there's already a label
          const currentLabel = this.getCurrentFaceLabel();
          if (currentLabel) {
            // Check global list for selected person's checked state
            this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
            this.initializeHouseholdCheckboxes(currentLabel);
            
            // Reset stored state first
            const resetKey = this.getFaceLabelKey(sourceImage, facialArea);
            if (resetKey) {
              this.embeddingsStored[resetKey] = false;
            }
            
            // Set loading state
            this.checkingEmbeddingInDB = true;
            this.$forceUpdate();
            
            // Load embedding data and check if it exists in DB
            // Temporarily switch to key box file for loading embedding data if needed
            const originalFile = this.selectedFile;
            if (!isKeyBoxFromCurrentImage) {
              this.selectedFile = sourceFile;
            }
            this.loadEmbeddingData();
            this.getEmbeddingsCount(); // Load count (async, but don't wait)
            this.checkEmbeddingInDB(); // Check DB (async, but don't wait)
            if (!isKeyBoxFromCurrentImage) {
              this.selectedFile = originalFile; // Restore original file
            }
          } else {
            // No label yet, default to checked
            this.selectedPersonChecked = true;
            this.householdCheckboxes = {};
            this.currentEmbeddingData = null;
            
            // Face guesses will be loaded by ControlSidePanel component
          }
          
          // Focus the search input
          this.$nextTick(() => {
            if (this.$refs.searchInput) {
              this.$refs.searchInput.focus();
            }
          });
        },
        onClusterBoxDeselected() {
          // Clear unified key box selection
          // Set to null - watch handler in ImageAnnotationCanvas will detect this and stop blinking
          const wasSelected = this.selectedKeyBox !== null;
          this.selectedKeyBox = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
          this.faceGuesses = [];
          this.selectedPersonChecked = true;
          this.householdCheckboxes = {};
          // Force Vue to detect the change if needed
          if (wasSelected) {
            this.$forceUpdate();
          }
        },
        getHouseholdMembers(person) {
          return Services.planningCenter.getHouseholdMembers(person, this.planningCentrePeople);
        },
        getHouseholdGroups(person) {
          return Services.planningCenter.getHouseholdGroups(person, this.planningCentrePeople);
        },
        getHouseholdMembersDisplay(person) {
          return Services.planningCenter.getHouseholdMembersDisplay(person, this.planningCentrePeople);
        },
        getPersonById(personId) {
          return Services.planningCenter.getPersonById(personId, this.planningCentrePeople);
        },
        getCheckInTableData() {
          const entries = [];
          const addedIds = new Set();
          const snapshotIds = this.checkInOverlaySnapshot || [];
          
          if (!snapshotIds.length) {
            return entries;
          }
          
          snapshotIds.forEach(personId => {
            const person = this.getPersonById(personId);
            if (person && person.id && !addedIds.has(person.id)) {
              entries.push({ person });
              addedIds.add(person.id);
            }
          });
          
          return entries;
        },
        areAllCheckInSelected() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (snapshotIds.length === 0) {
            return false;
          }
          return snapshotIds.every(personId => this.checkInOverlaySelection[personId]);
        },
        toggleCheckInSelectAll() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (snapshotIds.length === 0) {
            return;
          }
          const shouldSelectAll = !this.areAllCheckInSelected();
          snapshotIds.forEach(personId => {
            this.checkInOverlaySelection[personId] = shouldSelectAll;
          });
        },
        handleCheckInTableCheckboxChange(personId, event) {
          const checked = event.target.checked;
          this.checkInOverlaySelection[personId] = checked;
        },
        openCheckInOverlay() {
          const selectedIds = this.getSelectedCheckInPersonIds();
          if (!selectedIds.length) {
            return;
          }
          this.checkInOverlaySnapshot = [...selectedIds];
          this.checkInOverlaySelection = {};
          selectedIds.forEach(personId => {
            this.checkInOverlaySelection[personId] = true;
          });
          this.checkInError = null;
          this.checkInSuccessMessage = '';
          this.showCheckInOverlay = true;
        },
        closeCheckInOverlay() {
          this.showCheckInOverlay = false;
        },
        getOverlaySelectedCount() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (!snapshotIds.length) {
            return 0;
          }
          return snapshotIds.filter(personId => this.checkInOverlaySelection[personId]).length;
        },
        getSelectedCheckInPersonIds() {
          return Utils.getSelectedCheckInPersonIds(this.checkedPeopleByBox, this.checkedPeopleByPoint);
        },
        // Get session validity time range in UTC
        // sessionName is assumed to be a date in SGT format (e.g., "2025-11-30")
        getSessionValidityRange(sessionName) {
          return Utils.getSessionValidityRange(sessionName);
        },
        async selectPerson(person) {
          // Clear face guesses when a person is selected
          this.faceGuesses = [];
          
          // Check if we have either a key box or point label selected
          if (!this.selectedKeyBox && !this.selectedPointLabelId) return;
          
          // Handle key box selection
          if (this.selectedKeyBox) {
            const { sourceFile: targetFile, embeddingIndex: targetEmbeddingIndex, facialArea: targetFacialArea, sourceImage, isKeyBoxFromCurrentImage } = this.selectedKeyBox;
            const isOverlapBox = !isKeyBoxFromCurrentImage;
            
            if (targetEmbeddingIndex !== null && targetFile && targetFacialArea) {
            const key = this.getFaceLabelKey(targetFile.name, targetFacialArea);
              if (key) {
                // Clear all previously checked people for this bounding box before setting new person
                if (this.checkedPeopleByBox[key]) {
                  // Uncheck all previously checked people
                  Object.keys(this.checkedPeopleByBox[key]).forEach(personId => {
                    this.checkedPeopleByBox[key][personId] = false;
                  });
                }
                
                this.faceLabels[key] = person;
                this.currentSessionLabels[key] = person;
                // Mark selected person as checked for this bounding box
                if (person.id) {
                  this.setPersonCheckedForBox(key, person.id, true);
                }
                // Initialize checkbox states from per-box list
                this.selectedPersonChecked = this.isPersonChecked(person.id);
                this.initializeHouseholdCheckboxes(person);
                
                // Reset stored state first
              const resetKey = this.getFaceLabelKey(targetFile.name, targetFacialArea);
                  if (resetKey) {
                    this.embeddingsStored[resetKey] = false;
                }
                
                // Set loading state
                this.checkingEmbeddingInDB = true;
                this.$forceUpdate();
                
                // Load current embedding data and check if it exists in DB
              // For overlap boxes, we need to use the overlap file's model
              if (isOverlapBox) {
                // Temporarily switch to overlap file for loading embedding data
                const originalFile = this.selectedFile;
                this.selectedFile = targetFile;
                this.loadEmbeddingData();
                await this.getEmbeddingsCount();
                await this.checkEmbeddingInDB();
                this.selectedFile = originalFile; // Restore original file
              } else {
                this.loadEmbeddingData();
                await this.getEmbeddingsCount();
                await this.checkEmbeddingInDB();
              }
              
              // Clear overlap box selection after setting person
              if (isOverlapBox) {
                this.selectedOverlapBox = null;
                this.selectedBoundingBoxIndex = null;
              }
            }
            }
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          } else if (this.selectedPointLabelId !== null) {
            // Handle point label selection
            this.pointLabelPersons[this.selectedPointLabelId] = person;
            // Mark selected person as checked for this point label
            if (person.id) {
              this.setPersonCheckedForPoint(this.selectedPointLabelId, person.id, true);
            }
            // Initialize checkbox states from per-point list
            this.selectedPersonChecked = this.isPersonCheckedForPoint(this.selectedPointLabelId, person.id);
            this.initializeHouseholdCheckboxesForPoint(this.selectedPointLabelId, person);
            
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          }
        },
        initializeHouseholdCheckboxes(person) {
          // Initialize household checkboxes from per-bounding-box checked list
          this.householdCheckboxes = {};
          const groups = this.getHouseholdGroups(person);
          groups.forEach(group => {
            group.members.forEach(member => {
              if (member.id) {
                // Check per-bounding-box list for checked state
                this.householdCheckboxes[member.id] = this.isPersonChecked(member.id);
              }
            });
          });
        },
        // Get the face label key for the currently selected key box
        getCurrentFaceLabelKey() {
          if (!this.selectedKeyBox) return null;
          const { sourceImage, facialArea } = this.selectedKeyBox;
          return this.getFaceLabelKey(sourceImage, facialArea);
        },
        // Get checked people for a specific bounding box
        getCheckedPeopleForBox(faceLabelKey) {
          return Utils.getCheckedPeopleForBox(this.checkedPeopleByBox, faceLabelKey);
        },
        // Set checked state for a person in a specific bounding box
        setPersonCheckedForBox(faceLabelKey, personId, checked) {
          if (!faceLabelKey || !personId) return;
          if (!this.checkedPeopleByBox[faceLabelKey]) {
            this.checkedPeopleByBox[faceLabelKey] = {};
          }
          if (checked) {
            this.checkedPeopleByBox[faceLabelKey][personId] = true;
          } else {
            delete this.checkedPeopleByBox[faceLabelKey][personId];
          }
        },
        // Check if a person is checked for the current bounding box
        isPersonChecked(personId) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          return Utils.isPersonChecked(this.checkedPeopleByBox, faceLabelKey, personId);
        },
        handleSelectedPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentFaceLabel();
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (currentLabel && currentLabel.id && faceLabelKey) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update per-bounding-box checked list
            this.setPersonCheckedForBox(faceLabelKey, currentLabel.id, checked);
            
            if (!checked) {
              // Uncheck all household checkboxes for this box
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.setPersonCheckedForBox(faceLabelKey, member.id, false);
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
              
              // Clear the face label so the bounding box returns to unselected (yellow) state
              if (this.faceLabels && this.faceLabels[faceLabelKey]) {
                delete this.faceLabels[faceLabelKey];
              }
              if (this.currentSessionLabels && this.currentSessionLabels[faceLabelKey]) {
                delete this.currentSessionLabels[faceLabelKey];
              }
              
              // Deselect the bounding box so it's no longer in selected state (not blinking)
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              
              // Force update to refresh the bounding box color
              this.$forceUpdate();
            } else {
              // When re-checking, restore household checkbox states from per-box list
              this.initializeHouseholdCheckboxes(currentLabel);
            }
          }
        },
        handleHouseholdCheckboxChange(memberId, event) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (memberId && faceLabelKey) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update per-bounding-box checked list
            this.setPersonCheckedForBox(faceLabelKey, memberId, checked);
          }
        },
        getHouseholdCheckboxState(memberId) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          return Utils.getHouseholdCheckboxState(this.checkedPeopleByBox, faceLabelKey, memberId, this.householdCheckboxes);
        },
        getSelectedPersonCheckedState() {
          return Utils.getSelectedPersonCheckedState(this.selectedFile, this.selectedBoundingBoxIndex, this.faceLabels, this.checkedPeopleByBox, this.selectedPersonChecked);
        },
        getSelectedPointPersonCheckedState() {
          return Utils.getSelectedPointPersonCheckedState(this.selectedPointLabelId, this.pointLabelPersons, this.checkedPeopleByPoint, this.selectedPersonChecked);
        },
        handleSelectedPointPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentPointLabel();
          if (currentLabel && currentLabel.id && this.selectedPointLabelId) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update per-point checked list
            this.setPersonCheckedForPoint(this.selectedPointLabelId, currentLabel.id, checked);
            
            if (!checked) {
              // Uncheck all household checkboxes for this point
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.setPersonCheckedForPoint(this.selectedPointLabelId, member.id, false);
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
              
              // Clear the point label person
              if (this.pointLabelPersons && this.pointLabelPersons[this.selectedPointLabelId]) {
                delete this.pointLabelPersons[this.selectedPointLabelId];
              }
              
              // Store the point ID before clearing selection
              const pointIdToDelete = this.selectedPointLabelId;
              
              // Deselect the point label so it's no longer in selected state (not blinking)
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              
              // Delete the point label since there's no person selected
              this.deletePointLabel(pointIdToDelete);
              
              // Force update to refresh the UI
              this.$forceUpdate();
            } else {
              // When re-checking, restore household checkbox states from per-point list
              this.initializeHouseholdCheckboxesForPoint(this.selectedPointLabelId, currentLabel);
            }
          }
        },
        handlePointHouseholdCheckboxChange(memberId, event) {
          if (memberId && this.selectedPointLabelId) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update per-point checked list
            this.setPersonCheckedForPoint(this.selectedPointLabelId, memberId, checked);
          }
        },
        getPointHouseholdCheckboxState(memberId) {
          if (!this.selectedPointLabelId || !memberId) return false;
          // Check per-point list first, then local state
          const checkedPeople = this.checkedPeopleByPoint[this.selectedPointLabelId] || {};
          if (checkedPeople.hasOwnProperty(memberId)) {
            return checkedPeople[memberId];
          }
          return this.householdCheckboxes[memberId] || false;
        },
        getEmbeddingsCountDisplay() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          return this.embeddingsCountCache[currentLabel.id] || 0;
        },
        async getEmbeddingsCount() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          
          // Check cache first
          if (this.embeddingsCountCache[currentLabel.id] !== undefined) {
            return this.embeddingsCountCache[currentLabel.id];
          }
          
          // Fetch from service
          try {
            const count = await Services.embedding.getEmbeddingsCount(currentLabel.id);
            this.embeddingsCountCache[currentLabel.id] = count;
            // Force update to refresh UI
            this.$forceUpdate();
            return count;
          } catch (error) {
            console.error('Error fetching embeddings count:', error);
            return 0;
          }
        },
        getEmbeddingsStoredState() {
          return Utils.getEmbeddingsStoredState(this.selectedFile, this.selectedBoundingBoxIndex, this.embeddingsStored);
        },
        loadEmbeddingData() {
          // Load the embedding data for the selected key box
          if (!this.selectedKeyBox || !this.selectedKeyBox.sourceFile || !this.selectedKeyBox.sourceFile.model) {
            this.currentEmbeddingData = null;
            return;
          }
          
          const { sourceFile, embeddingIndex } = this.selectedKeyBox;
          
          try {
            const model = typeof sourceFile.model === 'string' 
              ? JSON.parse(sourceFile.model) 
              : sourceFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.currentEmbeddingData = null;
              return;
            }
            
            const embedding = model.embeddings[embeddingIndex];
            if (embedding && embedding.embedding) {
              this.currentEmbeddingData = embedding.embedding;
            } else {
              this.currentEmbeddingData = null;
            }
          } catch (error) {
            console.error('Error loading embedding data:', error);
            this.currentEmbeddingData = null;
          }
        },
        async checkEmbeddingInDB() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Get the key for this key box
          if (!this.selectedKeyBox) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          const { sourceImage, facialArea } = this.selectedKeyBox;
          const key = this.getFaceLabelKey(sourceImage, facialArea);
          if (!key) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Set loading state
          this.checkingEmbeddingInDB = true;
          this.$forceUpdate();
          
          // If no embedding data, mark as not stored
          if (!this.currentEmbeddingData) {
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
            return;
          }
          
          try {
            const result = await Services.embedding.checkEmbeddingInDB(currentLabel.id, this.currentEmbeddingData);
            
            // Update count cache
            this.embeddingsCountCache[currentLabel.id] = result.count;
            
            // Update stored state
            this.embeddingsStored[key] = result.exists;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          } catch (error) {
            console.error('Error checking embedding in DB:', error);
            // On error, mark as not stored
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          }
        },
        encodeEmbeddingToBase64(embedding) {
          return Utils.encodeEmbeddingToBase64(embedding);
        },
        async handleStoreEmbeddings() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id || !this.currentEmbeddingData || !this.user) {
            return;
          }
          
          try {
            const result = await Services.embedding.storeEmbedding(currentLabel.id, this.currentEmbeddingData);
            
            if (result.success) {
            // Update stored state
            if (this.selectedKeyBox) {
              const { sourceImage, facialArea } = this.selectedKeyBox;
              const key = this.getFaceLabelKey(sourceImage, facialArea);
              if (key) {
                this.embeddingsStored[key] = true;
              }
            }
            
            // Update count cache
              this.embeddingsCountCache[currentLabel.id] = result.count;
            
            // Force update to refresh UI
            this.$forceUpdate();
            } else {
              alert('Failed to store embedding: ' + (result.error || 'Unknown error'));
            }
          } catch (error) {
            console.error('Error storing embedding:', error);
            alert('Failed to store embedding: ' + error.message);
          }
        },
        getFacialAreaForIndex(embeddingIndex) {
          if (!this.selectedFile || !this.selectedFile.model) return null;
          return Utils.getFacialAreaForIndex(this.selectedFile.model, embeddingIndex);
        },
        getCurrentFaceLabel() {
          if (!this.selectedKeyBox) return null;
          const { sourceImage, facialArea } = this.selectedKeyBox;
          const key = this.getFaceLabelKey(sourceImage, facialArea);
          return key ? this.faceLabels[key] : null;
        },
        getCurrentPointLabel() {
          return Utils.getCurrentPointLabel(this.selectedPointLabelId, this.pointLabelPersons);
        },
        isPersonCheckedForPoint(pointLabelId, personId) {
          return Utils.isPersonCheckedForPoint(this.checkedPeopleByPoint, pointLabelId, personId);
        },
        setPersonCheckedForPoint(pointLabelId, personId, checked) {
          if (!pointLabelId || !personId) return;
          if (!this.checkedPeopleByPoint[pointLabelId]) {
            this.checkedPeopleByPoint[pointLabelId] = {};
          }
          this.checkedPeopleByPoint[pointLabelId][personId] = checked;
        },
        initializeHouseholdCheckboxesForPoint(pointLabelId, person) {
          if (!pointLabelId || !person || !this.getHouseholdMembers) return;
          const householdMembers = this.getHouseholdMembers(person);
          this.householdCheckboxes = {};
          householdMembers.forEach(member => {
            if (member && member.id) {
              this.householdCheckboxes[member.id] = this.isPersonCheckedForPoint(pointLabelId, member.id);
            }
          });
        },
        clearCurrentFaceLabel() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (key) {
            delete this.faceLabels[key];
            delete this.currentSessionLabels[key];
            // Clear selection
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          }
        },
        clearCurrentPointLabel() {
          if (this.selectedPointLabelId === null) return;
          if (this.pointLabelPersons && this.pointLabelPersons[this.selectedPointLabelId]) {
            delete this.pointLabelPersons[this.selectedPointLabelId];
          }
          // Clear selection
          this.selectedPointLabelId = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
        },
        deletePointLabel(pointId) {
          if (!pointId || !this.selectedFile) return;
          
          const imageName = this.selectedFile.name;
          if (this.pointLabels[imageName]) {
            // Remove the point from the array
            this.pointLabels[imageName] = this.pointLabels[imageName].filter(point => point.id !== pointId);
            
            // If array is empty, remove the image entry
            if (this.pointLabels[imageName].length === 0) {
              delete this.pointLabels[imageName];
            }
          }
          
          // Clean up associated data
          if (this.pointLabelPersons && this.pointLabelPersons[pointId]) {
            delete this.pointLabelPersons[pointId];
          }
          if (this.checkedPeopleByPoint && this.checkedPeopleByPoint[pointId]) {
            delete this.checkedPeopleByPoint[pointId];
          }
        },
        setupKeyboardNavigation() {
          document.addEventListener('keydown', this.handleKeydown);
        },
        handleKeydown(event) {
          // Only handle arrow keys when user is logged in and not loading
          if (!this.user || this.loading) return;
          
          // Handle ESC key to deselect key box or point label (works even in input fields)
          if (event.key === 'Escape') {
            if (this.selectedKeyBox !== null) {
              event.preventDefault();
              // Use the same deselection logic as clicking the box
              this.onClusterBoxDeselected();
              return;
            }
            if (this.selectedPointLabelId !== null) {
              event.preventDefault();
              // Check if there's a person selected before deselecting
              const currentLabel = this.getCurrentPointLabel();
              const pointId = this.selectedPointLabelId;
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              
              // If no person selected, delete the point label
              if (!currentLabel) {
                this.deletePointLabel(pointId);
              }
              return;
            }
          }
          
          // Handle 'Tab' key to go to next bounding box (works even in input fields when box is selected)
          if (event.key === 'Tab' && this.selectedBoundingBoxIndex !== null && this.showFaces && this.selectedFile && this.selectedFile.model) {
            event.preventDefault();
            this.goToNextBoundingBox();
            return;
          }
          
          // Handle 'a' key to add embedding (only when person is selected and button is enabled)
          if (event.key === 'a' || event.key === 'A') {
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel && currentLabel.id && this.currentEmbeddingData && this.user && 
                !this.checkingEmbeddingInDB && !this.getEmbeddingsStoredState()) {
              event.preventDefault();
              this.handleStoreEmbeddings();
              return;
            }
          }
          
          // Don't handle if user is typing in an input field or textarea (except ESC, Tab, and 'a')
          if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            // ESC, Tab, and 'a' keys are handled above, but for other keys, return early
            // Allow arrow keys in search input to be handled by handleSearchKeydown
            return;
          }
          
          switch(event.key) {
            case 'ArrowLeft':
              event.preventDefault();
              if (this.hasPrevImage) {
                this.bannerVisible = true;
                // Emit event to trigger prev image navigation
                this.$refs.imageAnnotationPanel?.goPrevImage();
              }
              break;
            case 'ArrowRight':
              event.preventDefault();
              if (this.hasNextImage) {
                this.bannerVisible = true;
                // Emit event to trigger next image navigation
                this.$refs.imageAnnotationPanel?.goNextImage();
              }
              break;
          }
        },
        goToNextBoundingBox() {
          if (!this.selectedFile || !this.selectedFile.model) return;
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return;
            }
            
            // Get all embedding indices that have facial areas
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => embedding.facial_area);
            
            if (embeddingsWithFaces.length === 0) return;
            
            // Find current index in the list
            const currentIndex = embeddingsWithFaces.findIndex(
              ({ index }) => index === this.selectedBoundingBoxIndex
            );
            
            if (currentIndex === -1) {
              // Current selection not found, select first one
              this.selectedBoundingBoxIndex = embeddingsWithFaces[0].index;
            } else {
              // Go to next, wrap around if at end
              const nextIndex = (currentIndex + 1) % embeddingsWithFaces.length;
              this.selectedBoundingBoxIndex = embeddingsWithFaces[nextIndex].index;
            }
            
            // Reset search and focus input
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          } catch (error) {
            console.error('Error navigating to next bounding box:', error);
          }
        },
      },
      computed: {
        sessions() {
          // Return only root-level directories (sessions), sorted from latest to earliest
          const dirs = this.directoryTree.filter(node => node.type === 'directory');
          // Sort from latest to earliest (descending order)
          const sorted = Array.from(dirs);
          sorted.sort((a, b) => {
            // Try to parse as dates if they look like dates, otherwise use string comparison
            const dateA = new Date(a.name);
            const dateB = new Date(b.name);
            
            // If both are valid dates, compare as dates
            if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
              return dateB - dateA; // Descending: later dates first
            }
            
            // Otherwise use string comparison (descending)
            return b.name.localeCompare(a.name);
          });
          return sorted;
        },
        hasPrevImage() {
          return this.currentFileIndex > 0;
        },
        hasNextImage() {
          return this.currentFileIndex >= 0 && this.currentFileIndex < this.currentFolderFiles.length - 1;
        }
      },
      mounted() {
        // Auto-scroll down 1px to trigger URL bar hiding on mobile
        setTimeout(() => {
          window.scrollTo(0, 1);
          // Scroll back to top after a moment (URL bar will stay hidden)
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 100);
        }, 100);
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
          // Re-trigger scroll to hide URL bar after orientation change
          setTimeout(() => {
            window.scrollTo(0, 1);
            setTimeout(() => {
              window.scrollTo(0, 0);
            }, 100);
            // Force resize event
            window.dispatchEvent(new Event('resize'));
          }, 300);
        });
        
        // Listen for authentication state changes
        Services.auth.onAuthStateChanged((user) => {
          this.user = user;
          this.loading = false;
          if (user) {
            this.fetchDirectoryTree();
          }
        });
        
        // Add keyboard navigation
        this.setupKeyboardNavigation();
      },
      beforeUnmount() {
        // Clean up keyboard event listeners
        document.removeEventListener('keydown', this.handleKeydown);
      },
    });


      // Register new components
      app.component('control-side-panel', window.Components.ControlSidePanel);
      app.component('image-annotation-panel', window.Components.ImageAnnotationPanel);
      app.component('check-in-overlay', window.Components.CheckInOverlay);
      app.component('image-annotation-canvas', window.Components.ImageAnnotationCanvas);

    app.use(VueKonva);
    const vueApp = app.mount('#app');

    // Setup resizer functionality after Vue app is mounted
    // Setup resizer after Vue app is mounted with a delay to ensure DOM is ready
      setTimeout(Utils.setupResizer, 100);
    })().catch(console.error);
  </script>
</body>
</html>
