<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>eShepherd</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="eshepherd.png">
  <link rel="icon" type="image/png" sizes="16x16" href="eshepherd.png">
  <link rel="apple-touch-icon" href="eshepherd.png">
  <link rel="shortcut icon" href="eshepherd.png">
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <!-- Client Vector Search Library - loaded dynamically via esm.sh -->
  <!--1. Link Vue Javascript & Konva-->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <!--2. Link VueKonva Javascript -->
  <script src="https://unpkg.com/vue-konva@3/dist/vue-konva.umd.js"></script>
  <!-- Load utility modules -->
  <script type="module" src="utils-loader.js"></script>
  <!-- Load component modules -->
  <script type="module" src="components-loader.js"></script>
  <!-- Replace Tailwind CDN with a local installation or CLI setup for production -->
</head>
<body class="bg-gray-100">
  <div id="app">
    <!-- Top Banner -->
    <header :class="['fixed top-0 inset-x-0 h-10 bg-gray-800 text-white grid grid-cols-3 items-center px-3 text-sm shadow z-10 transition-transform duration-300', { '-translate-y-full': !bannerVisible }]">
      <div class="flex items-center">
        <button v-if="user" @click="toggleSidebar" class="flex items-center gap-1 rounded px-2 py-1 bg-gray-700 hover:bg-gray-600 active:bg-gray-500 text-xs">
          <svg class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M4 6h16v2H4V6Zm0 5h10v2H4v-2Zm0 5h16v2H4v-2Z"/></svg>
          <span>{{ sidebarCollapsed ? 'Show Sessions' : 'Hide Sessions' }}</span>
        </button>
      </div>
      <div class="text-center font-semibold tracking-wide text-orange-500">eShepherd</div>
      <div class="flex justify-end">
        <button v-if="user" @click="signOut" class="text-xs text-gray-300 hover:text-white">Sign Out</button>
      </div>
    </header>
    
    <!-- Main Content Area -->
    <div :class="['main-content', { 'banner-hidden': !bannerVisible }]">
      <!-- Left Pane: Control Side Panel -->
      <div :class="['directory-pane text-xs transition-all duration-200 bg-blue-50', { 'border-r border-gray-200': !sidebarCollapsed }]" :style="sidebarCollapsed ? { width: '0px', minWidth: '0px' } : { minWidth: '200px' }" id="directoryPane">
        <control-side-panel
          v-show="!sidebarCollapsed && user"
          :user="user"
          :loading="loading"
          :sessions="sessions"
          :selected-session-name="selectedSessionName"
          :selected-file="selectedFile"
          :people-retrieval-status="peopleRetrievalStatus"
          :people-retrieval-count="peopleRetrievalCount"
          :selected-bounding-box-index="selectedBoundingBoxIndex"
          :selected-point-label-id="selectedPointLabelId"
          :labelling-started="labellingStarted"
          :search-query="searchQuery"
          :search-results="searchResults"
          :selected-search-index="selectedSearchIndex"
          :face-guesses="faceGuesses"
          :planning-centre-people="planningCentrePeople"
          :checking-embedding-in-d-b="checkingEmbeddingInDB"
          :check-in-overlay-selection="checkInOverlaySelection"
          :check-in-submitting="checkInSubmitting"
          :check-in-error="checkInError"
          :check-in-success-message="checkInSuccessMessage"
          :get-faces-button-text="getFacesButtonText"
          :get-faces-button-class="getFacesButtonClass"
          :get-face-scanning-status="getFaceScanningStatus"
          :get-face-scan-count="getFaceScanCount"
          :get-current-face-label="getCurrentFaceLabel"
          :get-current-point-label="getCurrentPointLabel"
          :get-selected-person-checked-state="getSelectedPersonCheckedState"
          :get-selected-point-person-checked-state="getSelectedPointPersonCheckedState"
          :get-household-checkbox-state="getHouseholdCheckboxState"
          :get-point-household-checkbox-state="getPointHouseholdCheckboxState"
          :get-household-groups="getHouseholdGroups"
          :get-household-members="getHouseholdMembers"
          :get-household-members-display="getHouseholdMembersDisplay"
          :get-match-display-text="getMatchDisplayText"
          :get-embeddings-stored-state="getEmbeddingsStoredState"
          :get-selected-check-in-person-ids="getSelectedCheckInPersonIds"
          :get-session-valid-time-range-string="getSessionValidTimeRangeString"
          :is-session-valid="isSessionValid"
          :get-session-invalid-message="getSessionInvalidMessage"
          :get-check-in-table-data="getCheckInTableData"
          :get-overlay-selected-count="getOverlaySelectedCount"
          :are-all-check-in-selected="areAllCheckInSelected"
          @session-change="onSessionChange"
          @faces-button-click="handleFacesButtonClick"
          @fetch-planning-centre-people="fetchPlanningCentrePeople"
          @reload-embeddings="reloadEmbeddingsIndex"
          @search-input="handleSearchInput"
          @search-keydown="handleSearchKeydown"
          @select-person="selectPerson"
          @selected-person-checkbox-change="handleSelectedPersonCheckboxChange"
          @household-checkbox-change="handleHouseholdCheckboxChange"
          @selected-point-person-checkbox-change="handleSelectedPointPersonCheckboxChange"
          @point-household-checkbox-change="handlePointHouseholdCheckboxChange"
          @store-embeddings="handleStoreEmbeddings"
          @open-check-in-overlay="openCheckInOverlay"
        ></control-side-panel>
      </div>

      <!-- Resizer -->
      <div class="resizer" id="resizer" v-show="!sidebarCollapsed && user"></div>

      <!-- Right Pane: Image Annotation Panel -->
      <image-annotation-panel
        :user="user"
        :loading="loading"
        :error="error"
        :selected-image="selectedImage"
        :selected-file="selectedFile"
        :image-loading="imageLoading"
        :current-folder-files="currentFolderFiles"
        :current-file-index="currentFileIndex"
        :has-prev-image="hasPrevImage"
        :has-next-image="hasNextImage"
        :selected-bounding-box-index="selectedBoundingBoxIndex"
        :annotations="annotations"
        :show-faces="showFaces"
        :face-labels="faceLabels"
        :point-labels="pointLabels"
        :selected-point-label-id="selectedPointLabelId"
        :point-label-persons="pointLabelPersons"
        :checked-people-by-point="checkedPeopleByPoint"
        :checked-people-by-box="checkedPeopleByBox"
        :planning-centre-people="planningCentrePeople"
        :get-face-label-key="getFaceLabelKey"
        :get-household-members="getHouseholdMembers"
        :get-image-timestamp="getImageTimestamp"
        @sign-in="signIn"
        @prev-image="bannerVisible = true; goPrevImage()"
        @next-image="bannerVisible = true; goNextImage()"
        @touch-start="handleTouchStart"
        @touch-end="handleTouchEnd"
        @update-annotations="onUpdateAnnotations"
        @loading-change="imageLoading = $event"
        @face-box-click="onFaceBoxClick"
        @point-label-click="onPointLabelClick"
        @point-label-create="onPointLabelCreate"
      >
        <!-- Check-In Overlay (inside image-annotation-panel for proper positioning) -->
        <check-in-overlay
          :show="showCheckInOverlay"
          :table-data="getCheckInTableData()"
          :selection="checkInOverlaySelection"
          :selected-count="getOverlaySelectedCount()"
          :total-count="getCheckInTableData().length"
          :all-selected="areAllCheckInSelected()"
          :submitting="checkInSubmitting"
          :error="checkInError"
          :success-message="checkInSuccessMessage"
          @close="closeCheckInOverlay"
          @submit="performCheckIn"
          @toggle-select-all="toggleCheckInSelectAll"
          @checkbox-change="handleCheckInTableCheckboxChange"
        ></check-in-overlay>
      </image-annotation-panel>
    </div>
  </div>

  <script>
    // Wait for Utils and Components to be loaded from modules
    (async function() {
      // Wait for Utils to be available (loaded by utils-loader.js)
      while (!window.Utils || Object.keys(window.Utils).length === 0) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      // Wait for Components to be available (loaded by components-loader.js)
      while (!window.Components || Object.keys(window.Components).length === 0) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      // Firebase is initialized in utils-loader.js (config/firebase.js)
      // Access via window.firebaseAuth and window.firebaseDatabase
      const auth = window.firebaseAuth;
      const database = window.firebaseDatabase;

      // Utils and Services are now loaded from utils-loader.js module
      const Utils = window.Utils;
      const Services = window.Services;

      const VueKonva = window['vue-konva'].default;
      const app = Vue.createApp({
          data() {
        return {
          directoryTree: [],
          selectedImage: null,
          selectedFile: null,
          selectedSession: null,
          selectedSessionName: '',
          annotations: [],
          currentFolderFiles: [],
          currentFileIndex: -1,
          sidebarCollapsed: false,
          user: null,
          loading: true,
          imageLoading: false,
          error: null,
          touchStartX: null,
          touchStartY: null,
          bannerVisible: true,
          isSwipe: false,
          showFaces: false,
          labellingStarted: false,
          peopleRetrievalStatus: 'idle', // 'idle', 'retrieving', 'completed'
          peopleRetrievalCount: 0,
          planningCentrePeople: [], // Store the actual records
          selectedBoundingBoxIndex: null, // Index of the selected bounding box
          pointLabels: {}, // Map of "imageName" to array of point labels: {imageName: [{id, x, y, naturalX, naturalY}]}
          selectedPointLabelId: null, // ID of the selected point label (null if none selected)
          pointLabelPersons: {}, // Map of point label ID to selected person record (similar to faceLabels)
          checkedPeopleByPoint: {}, // Per-point-label checked people: { [pointLabelId]: { [personId]: true/false } }
          faceLabels: {}, // Map of "imageName_x_y_w_h" to selected person record (persists per session)
          searchQuery: '',
          searchResults: [],
          selectedSearchIndex: -1, // Index of the highlighted search result
          faceGuesses: [], // Top 5 matches for the selected bounding box: [{person, similarity}]
          currentSessionLabels: {}, // Store labels for current session
          searchResultRefs: {}, // Refs to search result elements for scrolling
          selectedPersonChecked: true, // Track if selected person checkbox is checked (for current selection UI)
          householdCheckboxes: {}, // Track household member checkboxes state (for current selection UI)
          checkedPeopleByBox: {}, // Per-bounding-box checked people: { [faceLabelKey]: { [personId]: true/false } }
          embeddingsStored: {}, // Track if embeddings are stored for each bounding box (keyed by face label key)
          embeddingsCountCache: {}, // Cache for embeddings count per person ID
          currentEmbeddingData: null, // Store current embedding data for comparison
          checkingEmbeddingInDB: false, // Track if we're currently checking embedding in DB
          embeddingIndex: null, // EmbeddingIndex from client-vector-search
          ClientVectorSearchModule: null, // Store the imported module
          faceMatchCache: {}, // Cache face matches per image: {imageKey: {embeddingIndex: {personId, similarity, person}}}
          SIMILARITY_THRESHOLD: 0.80, // Cosine similarity threshold for face matching (0.75 is good for face recognition)
          faceScanningStatus: {}, // Track face scanning status per image: {imageKey: 'scanning' | 'scanned' | null}
          faceScanCount: {}, // Track number of faces scanned per image: {imageKey: number}
          showCheckInOverlay: false, // Control visibility of check-in overlay
          checkInSubmitting: false, // Track check-in submission state
          checkInError: null, // Store check-in error messages
          checkInSuccessMessage: '', // Store success message after check-in
          checkInOverlaySnapshot: [], // Person IDs captured when opening overlay
          checkInOverlaySelection: {} // Overlay-specific checkbox states
        };
      },
      methods: {
        getFacesButtonText() {
          if (!this.labellingStarted) {
            return 'Start Labelling';
          }
          return this.showFaces ? 'Hide Faces' : 'Show Faces';
        },
        getFacesButtonClass() {
          if (!this.labellingStarted) {
            return 'bg-blue-500 text-white border-blue-600 hover:bg-blue-600';
          }
          return this.showFaces ? 'bg-green-500 text-white border-green-600' : 'bg-gray-200 text-gray-700 border-gray-300 hover:bg-gray-300';
        },
        async handleFacesButtonClick() {
          if (!this.labellingStarted) {
            // Start labelling: show faces and fetch planning centre people
            this.labellingStarted = true;
            this.showFaces = true;
            await this.fetchPlanningCentrePeople();
          } else {
            // Toggle faces visibility
            this.showFaces = !this.showFaces;
          }
        },
        async signIn() {
          const result = await Services.auth.signIn();
          if (result.user) {
            this.user = result.user;
            this.error = null;
            await this.fetchDirectoryTree();
          } else {
            this.error = result.error || 'Sign in failed';
          }
        },
        async signOut() {
          const result = await Services.auth.signOut();
          if (!result.error) {
            this.user = null;
            this.directoryTree = [];
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedFile = null;
            this.selectedSession = null;
            this.selectedSessionName = '';
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        toggleSidebar() {
          this.sidebarCollapsed = !this.sidebarCollapsed;
          this.bannerVisible = true; // Show banner when interacting with UI
        },
        updateFolderContextFromSelected(node) {
          // Find parent and its file list; then set current index
          const result = this.findParentAndIndexByMediaLink(this.directoryTree, node.url, null);
          if (result && result.parent) {
            const files = result.parent.children.filter(child => child.type === 'file');
            const idx = files.findIndex(f => f.url === node.url);
            this.currentFolderFiles = files;
            this.currentFileIndex = idx;
          } else {
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        findParentAndIndexByMediaLink(nodes, url, parent) {
          if (!nodes) return null;
          for (const n of nodes) {
            if (n.type === 'file' && n.url === url) {
              return { parent, node: n };
            }
            if (n.children && n.children.length) {
              const res = this.findParentAndIndexByMediaLink(n.children, url, n);
              if (res) return res;
            }
          }
          return null;
        },
        async fetchDirectoryTree() {
          if (!this.user) return;
          
          try {
            this.loading = true;
            const result = await Services.file.fetchDirectoryTree(this.user);
            if (result.items) {
              this.directoryTree = Services.file.transformToTree(result.items);
              // Auto-select the latest session after loading
              this.$nextTick(() => {
                this.selectLatestSession();
              });
            } else {
              this.error = result.error || 'Failed to load images';
            }
          } catch (error) {
            console.error('Error fetching directory tree:', error);
            this.error = 'Failed to load images: ' + error.message;
          } finally {
            this.loading = false;
          }
        },
        isUrlExpired(file) {
          return Services.file.isUrlExpired(file);
        },
        async fetchPlanningCentrePeople() {
          if (!this.user) {
            console.error('User not authenticated');
            return;
          }
          
          try {
            this.peopleRetrievalStatus = 'retrieving';
            const result = await Services.planningCenter.fetchPeople(this.user);
            
            if (result.error) {
              throw new Error(result.error);
            }
            
            this.planningCentrePeople = result.records;
            this.peopleRetrievalCount = result.records.length;
            this.peopleRetrievalStatus = 'completed';
            
            // After loading people, try to match faces in current image
            if (this.selectedFile && this.selectedFile.model) {
              this.$nextTick(() => {
                this.matchFacesInImage(this.selectedFile);
              });
            }
          } catch (error) {
            console.error('Error fetching planning centre people:', error);
            this.peopleRetrievalStatus = 'completed'; // Still mark as completed to show error state
            this.peopleRetrievalCount = 0;
          }
        },
        async refreshUrls() {
          if (!this.user) return false;
          
          try {
            const result = await Services.file.refreshUrls(this.user);
            if (result.items) {
              // Update URLs in the directory tree and currentFolderFiles
              Services.file.updateUrlsInTree(this.directoryTree, result.items, this.currentFolderFiles);
              return true;
            } else {
              return false;
            }
          } catch (error) {
            console.error('Error refreshing URLs:', error);
            return false;
          }
        },
        updateUrlsInTree(tree, items) {
          Services.file.updateUrlsInTree(tree, items, this.currentFolderFiles);
        },
        async ensureUrlValid(file) {
          if (!file) return null;
          return await Services.file.ensureUrlValid(file, this.user, this.directoryTree, () => this.refreshUrls());
        },
        findFileByName(nodes, fileName) {
          return Services.file.findFileByName(nodes, fileName);
        },
        transformToTree(data) {
          return Services.file.transformToTree(data);
        },
        onSessionChange() {
          if (!this.selectedSessionName) return;
          
          // Find the session by name
          const session = this.sessions.find(s => s.name === this.selectedSessionName);
          if (session) {
            this.bannerVisible = true; // Show banner when selecting session
            this.onSelectSession(session);
          }
        },
        getFaceLabelKey(imageName, facialArea) {
          if (!imageName || !facialArea) return null;
          const x = Math.round(facialArea.x || 0);
          const y = Math.round(facialArea.y || 0);
          const w = Math.round(facialArea.w || 0);
          const h = Math.round(facialArea.h || 0);
          return `${imageName}_${x}_${y}_${w}_${h}`;
        },
        async onSelectSession(session) {
          this.selectedSession = session;
          this.selectedSessionName = session.name;
          // Clear labels, checked people, and embeddings stored when session changes
          this.faceLabels = {};
          this.currentSessionLabels = {};
          this.checkedPeopleByBox = {};
          this.embeddingsStored = {};
          this.embeddingsCountCache = {};
          this.currentEmbeddingData = null;
          this.embeddingIndex = null; // Reload embeddings for new session
          this.faceMatchCache = {}; // Clear face match cache
          this.faceScanningStatus = {}; // Clear face scanning status
          this.faceScanCount = {}; // Clear face scan count
          // Get all files from this session (recursively)
          const files = this.getAllFilesFromNode(session);
          this.currentFolderFiles = files;
          
          // Select the first image if available
          if (files.length > 0) {
            this.currentFileIndex = 0;
            this.selectedFile = files[0];
            const validUrl = await this.ensureUrlValid(files[0]);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', files[0].name);
            }
            // Fetch model data if model_url exists
            if (files[0].model_url) {
              this.fetchModelData(files[0]);
            }
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          } else {
            this.currentFileIndex = -1;
            this.selectedFile = null;
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        getAllFilesFromNode(node) {
          return Services.file.getAllFilesFromNode(node);
        },
        getImageTimestamp(file) {
          if (!file || !file.name) return null;
          
          try {
            // Extract the first part before the underscore (hex timestamp)
            const parts = file.name.split('_');
            if (parts.length === 0 || !parts[0]) return null;
            
            const hexTimestamp = parts[0];
            
            // Convert hex to decimal (unix timestamp)
            const unixTimestamp = parseInt(hexTimestamp, 16);
            
            if (isNaN(unixTimestamp)) return null;
            
            // Convert unix timestamp to Date object
            const date = new Date(unixTimestamp * 1000); // Convert seconds to milliseconds
            
            // Format the date/time
            return date.toLocaleString('en-US', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: true
            });
          } catch (error) {
            console.error('Error parsing timestamp from filename:', error);
            return null;
          }
        },
        async fetchModelData(file) {
          if (!file || !file.model_url) return null;
          
          // If model is already cached, return it
          if (file.model !== null && file.model !== undefined) {
            // If model is loaded and we have faces, try to match them
            if (file.model && file.model.embeddings) {
              this.$nextTick(() => {
                this.matchFacesInImage(file);
              });
            }
            return file.model;
          }
          
          try {
            const response = await fetch(file.model_url);
            if (!response.ok) {
              throw new Error(`Failed to fetch model: ${response.status}`);
            }
            const modelData = await response.json();
            // Cache the model data
            file.model = modelData;
            
            // After loading model, match faces
            this.$nextTick(() => {
              this.matchFacesInImage(file);
            });
            
            return modelData;
          } catch (error) {
            console.error('Error fetching model data:', error);
            // Set to empty object to prevent repeated failed fetches
            file.model = {};
            return null;
          }
        },
        // Decode base64 embedding to Float32Array (numpy float32 array equivalent)
        // Python encoding: np.array(embedding, dtype=np.float32).tobytes() -> base64.b64encode().decode('utf-8')
        decodeEmbeddingFromBase64(base64String) {
          return Utils.decodeEmbeddingFromBase64(base64String);
        },
        // Reload embeddings index from Firebase
        async reloadEmbeddingsIndex() {
          // Clear current index and cache
          this.embeddingIndex = null;
          this.faceMatchCache = {};
          this.faceScanningStatus = {};
          this.faceScanCount = {};
          
          // Reload embeddings (force reload)
          await this.loadAllStoredEmbeddings(true);
          
          // Rescan faces in current image if available
          if (this.selectedFile && this.selectedFile.model) {
            this.$nextTick(() => {
              this.matchFacesInImage(this.selectedFile);
            });
          }
        },
        // Load all embeddings from Firebase and create EmbeddingIndex
        async loadAllStoredEmbeddings(forceReload = false) {
          if (this.embeddingIndex !== null && !forceReload) {
            // Already loaded
            return;
          }
          
          try {
            // Dynamically import client-vector-search from esm.sh
            if (!this.ClientVectorSearchModule) {
              this.ClientVectorSearchModule = await import('https://esm.run/client-vector-search');
            }
            
            this.embeddingIndex = await Services.embedding.loadAllStoredEmbeddings(
              this.ClientVectorSearchModule,
              forceReload,
              this.embeddingIndex
            );
          } catch (error) {
            console.error('Error loading all stored embeddings:', error);
            this.embeddingIndex = null;
          }
        },
        // Load top 5 matches for face guesses
        async loadFaceGuesses() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.model) {
            this.faceGuesses = [];
            return;
          }
          
          try {
            // Load embedding data for the selected bounding box
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.faceGuesses = [];
              return;
            }
            
            const embedding = model.embeddings[this.selectedBoundingBoxIndex];
            if (!embedding || !embedding.embedding || !embedding.facial_area) {
              this.faceGuesses = [];
              return;
            }
            
            // Decode embedding if it's base64 encoded
            let embeddingArray = embedding.embedding;
            if (typeof embeddingArray === 'string') {
              embeddingArray = this.decodeEmbeddingFromBase64(embeddingArray);
              if (!embeddingArray) {
                this.faceGuesses = [];
                return;
              }
            }
            
            // Ensure embeddingArray is a flat array of numbers
            if (!Array.isArray(embeddingArray)) {
              this.faceGuesses = [];
              return;
            }
            
            embeddingArray = embeddingArray.flat(Infinity);
            
            // Validate all elements are numbers
            if (!embeddingArray.every(v => typeof v === 'number' && !isNaN(v) && isFinite(v))) {
              this.faceGuesses = [];
              return;
            }
            
            // Load all stored embeddings if not already loaded
            await this.loadAllStoredEmbeddings();
            
            if (!this.embeddingIndex) {
              this.faceGuesses = [];
              return;
            }
            
            // Search for top 5 matches
            const results = await this.embeddingIndex.search(embeddingArray, { topK: 5 });
            
            if (!results || results.length === 0) {
              this.faceGuesses = [];
              return;
            }
            
            // Process results and match with planningCentrePeople
            // Use a Map to deduplicate by personId, keeping only the highest similarity
            const guessesMap = new Map();
            
            for (const result of results) {
              let similarity = result.similarity || result.score || 0;
              
              // If distance is provided instead, convert to similarity
              if (result.distance !== undefined && similarity === 0) {
                similarity = 1 - result.distance;
              }
              
              // Extract personId
              let personId = null;
              if (result.personId) {
                personId = result.personId;
              } else if (result.id) {
                personId = result.id.split('_')[0];
              } else if (result.object && result.object.personId) {
                personId = result.object.personId;
              } else if (result.item && result.item.personId) {
                personId = result.item.personId;
              }
              
              if (personId) {
                // Find person in planningCentrePeople
                const person = this.planningCentrePeople.find(p => p.id === personId);
                if (person) {
                  // Check if we already have this person, keep the one with higher similarity
                  const existing = guessesMap.get(personId);
                  if (!existing || similarity > existing.similarity) {
                    guessesMap.set(personId, {
                      person: person,
                      similarity: similarity
                    });
                  }
                }
              }
            }
            
            // Convert Map to array and sort by similarity (descending)
            const guesses = Array.from(guessesMap.values())
              .sort((a, b) => b.similarity - a.similarity)
              .slice(0, 5); // Take top 5 after deduplication
            
            this.faceGuesses = guesses;
          } catch (error) {
            console.error('Error loading face guesses:', error);
            this.faceGuesses = [];
          }
        },
        // Find best match for an embedding using client-vector-search
        async findBestMatch(queryEmbedding) {
          if (!queryEmbedding) {
            console.error('findBestMatch: queryEmbedding is null or undefined');
            return null;
          }
          
          if (!Array.isArray(queryEmbedding)) {
            console.error('findBestMatch: queryEmbedding is not an array. Type:', typeof queryEmbedding, 'Value:', queryEmbedding);
            return null;
          }
          
          if (queryEmbedding.length === 0) {
            console.error('findBestMatch: queryEmbedding is an empty array');
            return null;
          }
          
          if (!this.embeddingIndex) {
            console.error('findBestMatch: embeddingIndex is null. Has it been initialized?');
            return null;
          }
          
          try {
            // Search for top match
            const results = await this.embeddingIndex.search(queryEmbedding, { topK: 1 });
            
            if (results && results.length > 0) {
              const bestResult = results[0];
              
              // Debug: log the result structure
              console.log('Search result:', bestResult);
              
              // Check if similarity is above threshold
              // client-vector-search returns similarity scores (typically 0-1 for cosine similarity)
              // The result might have similarity, score, or distance (inverted)
              let similarity = bestResult.similarity || bestResult.score || 0;
              
              // If distance is provided instead, convert to similarity (assuming cosine distance)
              if (bestResult.distance !== undefined && similarity === 0) {
                similarity = 1 - bestResult.distance; // Convert distance to similarity
              }
              
              // Extract personId from the result
              // The library should return the original object we passed in
              let personId = null;
              
              // Try different ways to get personId
              if (bestResult.personId) {
                personId = bestResult.personId;
              } else if (bestResult.id) {
                // Extract from id format: "personId_index"
                personId = bestResult.id.split('_')[0];
              } else if (bestResult.object && bestResult.object.personId) {
                personId = bestResult.object.personId;
              } else if (bestResult.item && bestResult.item.personId) {
                personId = bestResult.item.personId;
              }
              
              console.log('Extracted personId:', personId, 'similarity:', similarity);
              
              if (similarity >= this.SIMILARITY_THRESHOLD && personId) {
                return {
                  personId: personId,
                  similarity: similarity,
                  embedding: bestResult.embedding || bestResult.object?.embedding || bestResult.item?.embedding
                };
              } else {
                console.log(`Match below threshold: similarity=${similarity}, threshold=${this.SIMILARITY_THRESHOLD}, personId=${personId}`);
              }
            }
            
            return null;
          } catch (error) {
            console.error('Error finding best match:', error);
            return null;
          }
        },
        // Match all faces in an image
        async matchFacesInImage(file) {
          if (!file || !file.model || !file.name) {
            return;
          }
          
          // Only scan faces when planningCentrePeople data is fully loaded
          if (this.peopleRetrievalStatus !== 'completed' || !this.planningCentrePeople || this.planningCentrePeople.length === 0) {
            console.log('Skipping face scan: planningCentrePeople not loaded yet');
            return;
          }
          
          const imageKey = file.name;
          
          // Check cache first
          if (this.faceMatchCache[imageKey]) {
            // Apply cached matches
            this.applyFaceMatches(file, this.faceMatchCache[imageKey]);
            // Set status to scanned since we already have cached results
            this.faceScanningStatus[imageKey] = 'scanned';
            // Get face count from model if not cached
            if (!this.faceScanCount[imageKey]) {
              try {
                const model = typeof file.model === 'string' 
                  ? JSON.parse(file.model) 
                  : file.model;
                if (model.embeddings && Array.isArray(model.embeddings)) {
                  this.faceScanCount[imageKey] = model.embeddings.filter(e => e && e.embedding && e.facial_area).length;
                }
              } catch (e) {
                this.faceScanCount[imageKey] = Object.keys(this.faceMatchCache[imageKey]).length;
              }
            }
            this.$forceUpdate();
            return;
          }
          
          try {
            // Set scanning status
            this.faceScanningStatus[imageKey] = 'scanning';
            this.$forceUpdate();
            
            const model = typeof file.model === 'string' 
              ? JSON.parse(file.model) 
              : file.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.faceScanningStatus[imageKey] = 'scanned';
              this.$forceUpdate();
              return;
            }
            
            // Load all stored embeddings if not already loaded
            await this.loadAllStoredEmbeddings();
            
            // Get person records for matching
            const matches = {};
            let faceCount = 0;
            
            // Match each face embedding
            for (let i = 0; i < model.embeddings.length; i++) {
              const embedding = model.embeddings[i];
              
              if (embedding && embedding.embedding && embedding.facial_area) {
                faceCount++;
                
                // Decode embedding if it's base64 encoded
                let embeddingArray = embedding.embedding;
                if (typeof embeddingArray === 'string') {
                  // Try to decode from base64
                  embeddingArray = this.decodeEmbeddingFromBase64(embeddingArray);
                  if (!embeddingArray) {
                    console.warn(`Face ${i}: Could not decode embedding from base64`);
                    continue;
                  }
                }
                
                const bestMatch = await this.findBestMatch(embeddingArray);
                
                if (bestMatch) {
                  console.log('Found match:', bestMatch);
                  // Find person record from planningCentrePeople
                  const person = this.planningCentrePeople.find(p => p.id === bestMatch.personId);
                  
                  if (person) {
                    matches[i] = {
                      personId: bestMatch.personId,
                      similarity: bestMatch.similarity,
                      person: person
                    };
                    console.log(`Matched face ${i} to person ${person.name} (ID: ${person.id}, similarity: ${bestMatch.similarity})`);
                  } else {
                    console.warn(`Person with ID ${bestMatch.personId} not found in planningCentrePeople`);
                  }
                } else {
                  console.log(`No match found for face ${i} (below threshold or no match)`);
                }
              }
            }
            
            // Store face count
            this.faceScanCount[imageKey] = faceCount;
            
            // Cache the matches
            this.faceMatchCache[imageKey] = matches;
            
            // Apply the matches
            this.applyFaceMatches(file, matches);
            
            // Set status to scanned
            this.faceScanningStatus[imageKey] = 'scanned';
            this.$forceUpdate();
            
          } catch (error) {
            console.error('Error matching faces in image:', error);
            this.faceScanningStatus[imageKey] = 'scanned'; // Set to scanned even on error
            this.$forceUpdate();
          }
        },
        // Get face scanning status for current image
        getFaceScanningStatus() {
          if (!this.selectedFile || !this.selectedFile.name) {
            return null;
          }
          return this.faceScanningStatus[this.selectedFile.name] || null;
        },
        // Get face scan count for current image
        getFaceScanCount() {
          if (!this.selectedFile || !this.selectedFile.name) {
            return 0;
          }
          return this.faceScanCount[this.selectedFile.name] || 0;
        },
        // Apply face matches to labels
        applyFaceMatches(file, matches) {
          if (!file || !matches || Object.keys(matches).length === 0) {
            return;
          }
          
          try {
            const model = typeof file.model === 'string' 
              ? JSON.parse(file.model) 
              : file.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return;
            }
            
            // Apply each match
            for (const embeddingIndexStr in matches) {
              const embeddingIndex = parseInt(embeddingIndexStr);
              const match = matches[embeddingIndex];
              
              if (match && match.person && model.embeddings[embeddingIndex]) {
                const embedding = model.embeddings[embeddingIndex];
                const facialArea = embedding.facial_area;
                
                if (facialArea) {
                  const key = this.getFaceLabelKey(file.name, facialArea);
                  
                  if (key) {
                    // Only set the label if it hasn't been manually set by the user
                    // This prevents overwriting manual selections when applying cached matches
                    if (!this.faceLabels[key]) {
                      // Set the label
                      this.faceLabels[key] = match.person;
                      this.currentSessionLabels[key] = match.person;
                      
                      // Mark person as checked for this bounding box (same as manual selection)
                      if (match.person.id) {
                        this.setPersonCheckedForBox(key, match.person.id, true);
                      }
                      
                      console.log(`Matched face ${embeddingIndex} to ${match.person.name} (similarity: ${match.similarity.toFixed(3)})`);
                    } else {
                      console.log(`Skipping match for face ${embeddingIndex}: manual selection already exists`);
                    }
                  }
                }
              }
            }
            
            // Force update to refresh UI
            this.$forceUpdate();
          } catch (error) {
            console.error('Error applying face matches:', error);
          }
        },
        formatModel(model) {
          if (!model) return '';
          
          try {
            // If model is already a string, try to parse it as JSON
            if (typeof model === 'string') {
              const parsed = JSON.parse(model);
              return JSON.stringify(parsed, null, 2);
            }
            // If model is an object, stringify it with formatting
            return JSON.stringify(model, null, 2);
          } catch (error) {
            // If parsing fails, return as string
            return typeof model === 'string' ? model : String(model);
          }
        },
        selectLatestSession() {
          // Select the latest session (first one in the sorted list, since we sort latest to earliest)
          if (this.sessions.length > 0) {
            const latestSession = this.sessions[0];
            this.onSelectSession(latestSession);
          }
        },
        async onSelectNode(node) {
          if (node.type === 'file') {
            this.selectedFile = node;
            const validUrl = await this.ensureUrlValid(node);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', node.name);
            }
            // Fetch model data if model_url exists
            if (node.model_url) {
              this.fetchModelData(node);
            }
            this.updateFolderContextFromSelected(node);
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        async goPrevImage() {
          if (this.currentFileIndex > 0) {
            const newIndex = this.currentFileIndex - 1;
            const nextFile = this.currentFolderFiles[newIndex];
            if (nextFile) {
              this.selectedFile = nextFile;
              const validUrl = await this.ensureUrlValid(nextFile);
              this.selectedImage = validUrl;
              if (!validUrl) {
                console.error('Failed to get valid URL for file:', nextFile.name);
              }
              // Fetch model data if model_url exists
              if (nextFile.model_url) {
                this.fetchModelData(nextFile);
              }
              this.currentFileIndex = newIndex;
              // Clear selected bounding box when switching images (but keep labels)
              this.selectedBoundingBoxIndex = null;
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              // Don't clear faceLabels - they persist per session
            }
          }
        },
        async goNextImage() {
          if (this.currentFileIndex >= 0 && this.currentFileIndex < this.currentFolderFiles.length - 1) {
            const newIndex = this.currentFileIndex + 1;
            const nextFile = this.currentFolderFiles[newIndex];
            if (nextFile) {
              this.selectedFile = nextFile;
              const validUrl = await this.ensureUrlValid(nextFile);
              this.selectedImage = validUrl;
              if (!validUrl) {
                console.error('Failed to get valid URL for file:', nextFile.name);
              }
              // Fetch model data if model_url exists
              if (nextFile.model_url) {
                this.fetchModelData(nextFile);
              }
              this.currentFileIndex = newIndex;
              // Clear selected bounding box when switching images (but keep labels)
              this.selectedBoundingBoxIndex = null;
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              // Don't clear faceLabels - they persist per session
            }
          }
        },
        onUpdateAnnotations(newAnnotations) {
          this.annotations = newAnnotations;
        },
        onPointLabelCreate(pointData) {
          if (!this.selectedFile) return;
          
          const imageName = this.selectedFile.name;
          if (!this.pointLabels[imageName]) {
            this.pointLabels[imageName] = [];
          }
          
          // Generate unique ID for the point
          const pointId = `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Add point to the array
          this.pointLabels[imageName].push({
            id: pointId,
            x: pointData.x,
            y: pointData.y,
            naturalX: pointData.naturalX,
            naturalY: pointData.naturalY
          });
          
          // Select the newly created point
          this.selectedPointLabelId = pointId;
          
          // Clear bounding box selection when selecting a point
          this.selectedBoundingBoxIndex = null;
          
          // Initialize checkboxes (no person selected yet for new point)
          this.selectedPersonChecked = true;
          this.householdCheckboxes = {};
          
          // Clear search state
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
          
          // Ensure labelling is started (needed for search box to be visible)
          if (!this.labellingStarted) {
            this.labellingStarted = true;
            this.showFaces = true;
            // Fetch planning centre people if not already loaded
            if (!this.planningCentrePeople || this.planningCentrePeople.length === 0) {
              this.fetchPlanningCentrePeople();
            }
          }
          
          // Focus the search input - use both $nextTick and setTimeout to ensure DOM is ready
          this.$nextTick(() => {
            setTimeout(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            }, 100);
          });
        },
        onPointLabelClick(pointId) {
          // Toggle selection - if clicking the same point, deselect it
          if (this.selectedPointLabelId === pointId) {
            // Check if there's a person selected before deselecting
            const currentLabel = this.getCurrentPointLabel();
            if (!currentLabel) {
              // No person selected, delete the point label
              this.deletePointLabel(pointId);
            }
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          } else {
            this.selectedPointLabelId = pointId;
            // Clear bounding box selection when selecting a point
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentPointLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonCheckedForPoint(pointId, currentLabel.id);
              this.initializeHouseholdCheckboxesForPoint(pointId, currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input (same as bounding box logic)
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          }
        },
        onFaceBoxClick(embeddingIndex) {
          // Toggle selection - if clicking the same box, deselect it
          if (this.selectedBoundingBoxIndex === embeddingIndex) {
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.faceGuesses = [];
            this.selectedPersonChecked = true;
            this.householdCheckboxes = {};
          } else {
            this.selectedBoundingBoxIndex = embeddingIndex;
            // Clear point label selection when selecting a bounding box
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.faceGuesses = []; // Clear previous guesses
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
              
              // Reset stored state first
              const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
              if (facialArea) {
                const resetKey = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                if (resetKey) {
                  this.embeddingsStored[resetKey] = false;
                }
              }
              
              // Set loading state
              this.checkingEmbeddingInDB = true;
              this.$forceUpdate();
              
              // Load embedding data and check if it exists in DB
              this.loadEmbeddingData();
              this.getEmbeddingsCount(); // Load count (async, but don't wait)
              this.checkEmbeddingInDB(); // Check DB (async, but don't wait)
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              this.currentEmbeddingData = null;
              
              // Load top 5 matches for guesses
              this.loadFaceGuesses();
            }
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          }
        },
        handleSearchInput(value) {
          this.searchQuery = value;
          this.performSearch();
        },
        performSearch() {
          // Clear face guesses when user starts typing
          this.faceGuesses = [];
          
          if (!this.searchQuery || this.searchQuery.trim() === '') {
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.searchResultRefs = {};
            return;
          }
          
          const query = this.searchQuery.toLowerCase().trim();
          const results = this.planningCentrePeople
            .filter(person => person.name && person.name.toLowerCase().includes(query))
            .slice(0, 15); // Up to 15 results (show 5 initially, scroll for more)
          
          this.searchResults = results;
          // Reset selected index when search results change
          this.selectedSearchIndex = results.length > 0 ? 0 : -1;
          // Clear refs - they will be recreated by Vue
          this.$nextTick(() => {
            this.scrollToSelectedResult();
          });
        },
        getHouseholdMembers(person) {
          return Utils.getHouseholdMembers(person, this.planningCentrePeople);
        },
        getHouseholdGroups(person) {
          return Utils.getHouseholdGroups(person, this.planningCentrePeople);
        },
        getHouseholdMembersDisplay(person) {
          return Utils.getHouseholdMembersDisplay(person, this.planningCentrePeople);
        },
        getPersonById(personId) {
          return Utils.getPersonById(personId, this.planningCentrePeople);
        },
        getCheckInTableData() {
          const entries = [];
          const addedIds = new Set();
          const snapshotIds = this.checkInOverlaySnapshot || [];
          
          if (!snapshotIds.length) {
            return entries;
          }
          
          snapshotIds.forEach(personId => {
            const person = this.getPersonById(personId);
            if (person && person.id && !addedIds.has(person.id)) {
              entries.push({ person });
              addedIds.add(person.id);
            }
          });
          
          return entries;
        },
        areAllCheckInSelected() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (snapshotIds.length === 0) {
            return false;
          }
          return snapshotIds.every(personId => this.checkInOverlaySelection[personId]);
        },
        toggleCheckInSelectAll() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (snapshotIds.length === 0) {
            return;
          }
          const shouldSelectAll = !this.areAllCheckInSelected();
          snapshotIds.forEach(personId => {
            this.checkInOverlaySelection[personId] = shouldSelectAll;
          });
        },
        handleCheckInTableCheckboxChange(personId, event) {
          const checked = event.target.checked;
          this.checkInOverlaySelection[personId] = checked;
        },
        openCheckInOverlay() {
          const selectedIds = this.getSelectedCheckInPersonIds();
          if (!selectedIds.length) {
            return;
          }
          this.checkInOverlaySnapshot = [...selectedIds];
          this.checkInOverlaySelection = {};
          selectedIds.forEach(personId => {
            this.checkInOverlaySelection[personId] = true;
          });
          this.checkInError = null;
          this.checkInSuccessMessage = '';
          this.showCheckInOverlay = true;
        },
        closeCheckInOverlay() {
          this.showCheckInOverlay = false;
        },
        getOverlaySelectedCount() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (!snapshotIds.length) {
            return 0;
          }
          return snapshotIds.filter(personId => this.checkInOverlaySelection[personId]).length;
        },
        getSelectedCheckInPersonIds() {
          // Aggregate all checked people from all bounding boxes and point labels
          const allCheckedPeople = {};
          Object.values(this.checkedPeopleByBox || {}).forEach(checkedPeople => {
            Object.keys(checkedPeople).forEach(personId => {
              if (checkedPeople[personId]) {
                allCheckedPeople[personId] = true;
              }
            });
          });
          Object.values(this.checkedPeopleByPoint || {}).forEach(checkedPeople => {
            Object.keys(checkedPeople).forEach(personId => {
              if (checkedPeople[personId]) {
                allCheckedPeople[personId] = true;
              }
            });
          });
          return Object.keys(allCheckedPeople);
        },
        // Get session validity time range in UTC
        // sessionName is assumed to be a date in SGT format (e.g., "2025-11-30")
        getSessionValidityRange(sessionName) {
          return Utils.getSessionValidityRange(sessionName);
        },
        // Check if current time is within valid session period
        isSessionValid() {
          return Utils.isSessionValid(this.selectedSessionName);
        },
        // Format UTC date for display in user's local timezone (without timezone suffix)
        formatLocalDateTimeNoTz(utcDate) {
          return Utils.formatLocalDateTimeNoTz(utcDate);
        },
        // Get timezone abbreviation for display
        getLocalTimeZoneName() {
          return Utils.getLocalTimeZoneName();
        },
        // Get formatted valid time range string in user's local timezone
        getSessionValidTimeRangeString() {
          return Utils.getSessionValidTimeRangeString(this.selectedSessionName);
        },
        // Get session invalid message based on whether it's past or not started
        getSessionInvalidMessage() {
          return Utils.getSessionInvalidMessage(this.selectedSessionName);
        },
        getOverlaySelectedPersonIds() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          return snapshotIds.filter(personId => this.checkInOverlaySelection[personId]);
        },
        async performCheckIn() {
          if (this.checkInSubmitting) {
            return;
          }
          
          const personIds = this.showCheckInOverlay ? this.getOverlaySelectedPersonIds() : this.getSelectedCheckInPersonIds();
          if (!personIds.length) {
            this.checkInError = 'Select at least one person to check in.';
            this.checkInSuccessMessage = '';
            return;
          }
          
          if (!this.user) {
            this.checkInError = 'You must be signed in to perform check-in.';
            this.checkInSuccessMessage = '';
            return;
          }
          
          try {
            this.checkInSubmitting = true;
            this.checkInError = null;
            this.checkInSuccessMessage = '';
            
            const result = await Services.planningCenter.performCheckIn(this.user, personIds);
            
            if (result.success) {
              this.checkInSuccessMessage = result.data?.message || 'Check-in request submitted successfully.';
              
              if (result.data && typeof result.data === 'object') {
                const {
                  success,
                  total_persons_received,
                  already_checked_in,
                  people_to_update
                } = result.data;
                
                const lines = [];
                if (typeof success !== 'undefined') {
                  lines.push(`Success: ${success ? 'Yes' : 'No'}`);
                }
                if (typeof total_persons_received !== 'undefined') {
                  lines.push(`Total persons received: ${total_persons_received}`);
                }
                if (typeof already_checked_in !== 'undefined') {
                  lines.push(`Already checked in: ${already_checked_in}`);
                }
                if (typeof people_to_update !== 'undefined') {
                  lines.push(`People to update: ${people_to_update}`);
                }
                
                if (lines.length > 0) {
                  alert(lines.join('\n'));
                }
              }
            } else {
              this.checkInError = result.error || 'Failed to perform check-in.';
            }
          } catch (error) {
            console.error('Error performing check-in:', error);
            this.checkInError = error.message || 'Failed to perform check-in. Please check your internet connection and try again.';
          } finally {
            this.checkInSubmitting = false;
          }
        },
        handleSearchKeydown(event) {
          if (this.searchResults.length === 0) {
            return; // Don't handle keys if there are no results
          }
          
          switch(event.key) {
            case 'ArrowDown':
              event.preventDefault();
              this.selectedSearchIndex = (this.selectedSearchIndex + 1) % this.searchResults.length;
              this.scrollToSelectedResult();
              break;
            case 'ArrowUp':
              event.preventDefault();
              if (this.selectedSearchIndex <= 0) {
                this.selectedSearchIndex = this.searchResults.length - 1;
              } else {
                this.selectedSearchIndex = this.selectedSearchIndex - 1;
              }
              this.scrollToSelectedResult();
              break;
            case 'Enter':
              event.preventDefault();
              if (this.selectedSearchIndex >= 0 && this.selectedSearchIndex < this.searchResults.length) {
                this.selectPerson(this.searchResults[this.selectedSearchIndex]);
              }
              break;
            case 'Escape':
              event.preventDefault();
              this.selectedSearchIndex = -1;
              break;
          }
        },
        scrollToSelectedResult() {
          // Use $nextTick to ensure DOM is updated before scrolling
          this.$nextTick(() => {
            if (this.selectedSearchIndex >= 0 && this.searchResultRefs[this.selectedSearchIndex]) {
              const selectedElement = this.searchResultRefs[this.selectedSearchIndex];
              const container = this.$refs.searchResultsContainer;
              
              if (container && selectedElement) {
                const containerRect = container.getBoundingClientRect();
                const elementRect = selectedElement.getBoundingClientRect();
                
                // Check if element is outside visible area
                if (elementRect.top < containerRect.top) {
                  // Element is above visible area, scroll up
                  selectedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else if (elementRect.bottom > containerRect.bottom) {
                  // Element is below visible area, scroll down
                  selectedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
              }
            }
          });
        },
        async selectPerson(person) {
          // Clear face guesses when a person is selected
          this.faceGuesses = [];
          
          if (this.selectedBoundingBoxIndex !== null && this.selectedFile) {
            // Get the facial area for the selected embedding index
            const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
            if (facialArea) {
              const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
              if (key) {
                // Clear all previously checked people for this bounding box before setting new person
                if (this.checkedPeopleByBox[key]) {
                  // Uncheck all previously checked people
                  Object.keys(this.checkedPeopleByBox[key]).forEach(personId => {
                    this.checkedPeopleByBox[key][personId] = false;
                  });
                }
                
                this.faceLabels[key] = person;
                this.currentSessionLabels[key] = person;
                // Mark selected person as checked for this bounding box
                if (person.id) {
                  this.setPersonCheckedForBox(key, person.id, true);
                }
                // Initialize checkbox states from per-box list
                this.selectedPersonChecked = this.isPersonChecked(person.id);
                this.initializeHouseholdCheckboxes(person);
                
                // Reset stored state first
                const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
                if (facialArea) {
                  const resetKey = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                  if (resetKey) {
                    this.embeddingsStored[resetKey] = false;
                  }
                }
                
                // Set loading state
                this.checkingEmbeddingInDB = true;
                this.$forceUpdate();
                
                // Load current embedding data and check if it exists in DB
                this.loadEmbeddingData();
                await this.getEmbeddingsCount(); // Load count first
                await this.checkEmbeddingInDB(); // This will set checkingEmbeddingInDB to false when done
              }
            }
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          } else if (this.selectedPointLabelId !== null) {
            // Handle point label selection
            this.pointLabelPersons[this.selectedPointLabelId] = person;
            // Mark selected person as checked for this point label
            if (person.id) {
              this.setPersonCheckedForPoint(this.selectedPointLabelId, person.id, true);
            }
            // Initialize checkbox states from per-point list
            this.selectedPersonChecked = this.isPersonCheckedForPoint(this.selectedPointLabelId, person.id);
            this.initializeHouseholdCheckboxesForPoint(this.selectedPointLabelId, person);
            
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          }
        },
        initializeHouseholdCheckboxes(person) {
          // Initialize household checkboxes from per-bounding-box checked list
          this.householdCheckboxes = {};
          const groups = this.getHouseholdGroups(person);
          groups.forEach(group => {
            group.members.forEach(member => {
              if (member.id) {
                // Check per-bounding-box list for checked state
                this.householdCheckboxes[member.id] = this.isPersonChecked(member.id);
              }
            });
          });
        },
        // Get the face label key for the currently selected bounding box
        getCurrentFaceLabelKey() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return null;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return null;
          return this.getFaceLabelKey(this.selectedFile.name, facialArea);
        },
        // Get checked people for a specific bounding box
        getCheckedPeopleForBox(faceLabelKey) {
          if (!faceLabelKey) return {};
          return this.checkedPeopleByBox[faceLabelKey] || {};
        },
        // Set checked state for a person in a specific bounding box
        setPersonCheckedForBox(faceLabelKey, personId, checked) {
          if (!faceLabelKey || !personId) return;
          if (!this.checkedPeopleByBox[faceLabelKey]) {
            this.checkedPeopleByBox[faceLabelKey] = {};
          }
          if (checked) {
            this.checkedPeopleByBox[faceLabelKey][personId] = true;
          } else {
            delete this.checkedPeopleByBox[faceLabelKey][personId];
          }
        },
        // Check if a person is checked for the current bounding box
        isPersonChecked(personId) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (!faceLabelKey || !personId) return false;
          const checkedPeople = this.getCheckedPeopleForBox(faceLabelKey);
          return checkedPeople[personId] || false;
        },
        handleSelectedPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentFaceLabel();
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (currentLabel && currentLabel.id && faceLabelKey) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update per-bounding-box checked list
            this.setPersonCheckedForBox(faceLabelKey, currentLabel.id, checked);
            
            if (!checked) {
              // Uncheck all household checkboxes for this box
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.setPersonCheckedForBox(faceLabelKey, member.id, false);
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
              
              // Clear the face label so the bounding box returns to unselected (yellow) state
              if (this.faceLabels && this.faceLabels[faceLabelKey]) {
                delete this.faceLabels[faceLabelKey];
              }
              if (this.currentSessionLabels && this.currentSessionLabels[faceLabelKey]) {
                delete this.currentSessionLabels[faceLabelKey];
              }
              
              // Deselect the bounding box so it's no longer in selected state (not blinking)
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              
              // Force update to refresh the bounding box color
              this.$forceUpdate();
            } else {
              // When re-checking, restore household checkbox states from per-box list
              this.initializeHouseholdCheckboxes(currentLabel);
            }
          }
        },
        handleHouseholdCheckboxChange(memberId, event) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (memberId && faceLabelKey) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update per-bounding-box checked list
            this.setPersonCheckedForBox(faceLabelKey, memberId, checked);
          }
        },
        getHouseholdCheckboxState(memberId) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (!faceLabelKey || !memberId) return false;
          // Check per-bounding-box list first, then local state
          const checkedPeople = this.getCheckedPeopleForBox(faceLabelKey);
          if (checkedPeople.hasOwnProperty(memberId)) {
            return checkedPeople[memberId];
          }
          return this.householdCheckboxes[memberId] || false;
        },
        getSelectedPersonCheckedState() {
          const currentLabel = this.getCurrentFaceLabel();
          if (currentLabel && currentLabel.id) {
            // Check global list for selected person's checked state
            return this.isPersonChecked(currentLabel.id);
          }
          // Fallback to local state if no label
          return this.selectedPersonChecked;
        },
        getSelectedPointPersonCheckedState() {
          const currentLabel = this.getCurrentPointLabel();
          if (currentLabel && currentLabel.id && this.selectedPointLabelId) {
            // Check per-point list for selected person's checked state
            return this.isPersonCheckedForPoint(this.selectedPointLabelId, currentLabel.id);
          }
          // Fallback to local state if no label
          return this.selectedPersonChecked;
        },
        handleSelectedPointPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentPointLabel();
          if (currentLabel && currentLabel.id && this.selectedPointLabelId) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update per-point checked list
            this.setPersonCheckedForPoint(this.selectedPointLabelId, currentLabel.id, checked);
            
            if (!checked) {
              // Uncheck all household checkboxes for this point
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.setPersonCheckedForPoint(this.selectedPointLabelId, member.id, false);
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
              
              // Clear the point label person
              if (this.pointLabelPersons && this.pointLabelPersons[this.selectedPointLabelId]) {
                delete this.pointLabelPersons[this.selectedPointLabelId];
              }
              
              // Store the point ID before clearing selection
              const pointIdToDelete = this.selectedPointLabelId;
              
              // Deselect the point label so it's no longer in selected state (not blinking)
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              
              // Delete the point label since there's no person selected
              this.deletePointLabel(pointIdToDelete);
              
              // Force update to refresh the UI
              this.$forceUpdate();
            } else {
              // When re-checking, restore household checkbox states from per-point list
              this.initializeHouseholdCheckboxesForPoint(this.selectedPointLabelId, currentLabel);
            }
          }
        },
        handlePointHouseholdCheckboxChange(memberId, event) {
          if (memberId && this.selectedPointLabelId) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update per-point checked list
            this.setPersonCheckedForPoint(this.selectedPointLabelId, memberId, checked);
          }
        },
        getPointHouseholdCheckboxState(memberId) {
          if (!this.selectedPointLabelId || !memberId) return false;
          // Check per-point list first, then local state
          const checkedPeople = this.checkedPeopleByPoint[this.selectedPointLabelId] || {};
          if (checkedPeople.hasOwnProperty(memberId)) {
            return checkedPeople[memberId];
          }
          return this.householdCheckboxes[memberId] || false;
        },
        getEmbeddingsCountDisplay() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          return this.embeddingsCountCache[currentLabel.id] || 0;
        },
        getMatchDisplayText() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) {
            return '0 Embeddings in DB';
          }
          
          const embeddingsCount = this.embeddingsCountCache[currentLabel.id] || 0;
          
          // Check if there's a match for the current bounding box
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.name) {
            return `${embeddingsCount} Embeddings in DB`;
          }
          
          const imageKey = this.selectedFile.name;
          const matchCache = this.faceMatchCache[imageKey];
          
          if (!matchCache || !matchCache[this.selectedBoundingBoxIndex]) {
            // No match found for this face
            return `No Match. ${embeddingsCount} Embeddings in DB`;
          }
          
          const match = matchCache[this.selectedBoundingBoxIndex];
          
          // Check if the selected person matches the top match
          if (match.personId === currentLabel.id) {
            // Selected person is the top match - show match percentage
            const matchPercentage = (match.similarity * 100).toFixed(1);
            return `${matchPercentage}% Match. ${embeddingsCount} Embeddings in DB`;
          } else {
            // Selected person is not the top match
            return `No Match. ${embeddingsCount} Embeddings in DB`;
          }
        },
        async getEmbeddingsCount() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          
          // Check cache first
          if (this.embeddingsCountCache[currentLabel.id] !== undefined) {
            return this.embeddingsCountCache[currentLabel.id];
          }
          
          // Fetch from service
          try {
            const count = await Services.embedding.getEmbeddingsCount(currentLabel.id);
            this.embeddingsCountCache[currentLabel.id] = count;
            // Force update to refresh UI
            this.$forceUpdate();
            return count;
          } catch (error) {
            console.error('Error fetching embeddings count:', error);
            return 0;
          }
        },
        getEmbeddingsStoredState() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return false;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return false;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          return key ? (this.embeddingsStored[key] || false) : false;
        },
        loadEmbeddingData() {
          // Load the embedding data for the current bounding box
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.model) {
            this.currentEmbeddingData = null;
            return;
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.currentEmbeddingData = null;
              return;
            }
            
            const embedding = model.embeddings[this.selectedBoundingBoxIndex];
            if (embedding && embedding.embedding) {
              this.currentEmbeddingData = embedding.embedding;
            } else {
              this.currentEmbeddingData = null;
            }
          } catch (error) {
            console.error('Error loading embedding data:', error);
            this.currentEmbeddingData = null;
          }
        },
        async checkEmbeddingInDB() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Get the key for this bounding box
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (!key) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Set loading state
          this.checkingEmbeddingInDB = true;
          this.$forceUpdate();
          
          // If no embedding data, mark as not stored
          if (!this.currentEmbeddingData) {
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
            return;
          }
          
          try {
            const result = await Services.embedding.checkEmbeddingInDB(currentLabel.id, this.currentEmbeddingData);
            
            // Update count cache
            this.embeddingsCountCache[currentLabel.id] = result.count;
            
            // Update stored state
            this.embeddingsStored[key] = result.exists;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          } catch (error) {
            console.error('Error checking embedding in DB:', error);
            // On error, mark as not stored
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          }
        },
        encodeEmbeddingToBase64(embedding) {
          return Utils.encodeEmbeddingToBase64(embedding);
        },
        async handleStoreEmbeddings() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id || !this.currentEmbeddingData || !this.user) {
            return;
          }
          
          try {
            const result = await Services.embedding.storeEmbedding(currentLabel.id, this.currentEmbeddingData);
            
            if (result.success) {
              // Update stored state
              const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
              if (facialArea) {
                const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                if (key) {
                  this.embeddingsStored[key] = true;
                }
              }
              
              // Update count cache
              this.embeddingsCountCache[currentLabel.id] = result.count;
              
              // Force update to refresh UI
              this.$forceUpdate();
            } else {
              alert('Failed to store embedding: ' + (result.error || 'Unknown error'));
            }
          } catch (error) {
            console.error('Error storing embedding:', error);
            alert('Failed to store embedding: ' + error.message);
          }
        },
        getFacialAreaForIndex(embeddingIndex) {
          if (!this.selectedFile || !this.selectedFile.model) return null;
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return null;
            }
            
            const embedding = model.embeddings[embeddingIndex];
            return embedding && embedding.facial_area ? embedding.facial_area : null;
          } catch (error) {
            console.error('Error getting facial area:', error);
            return null;
          }
        },
        getCurrentFaceLabel() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return null;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return null;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          return key ? this.faceLabels[key] || null : null;
        },
        getCurrentPointLabel() {
          if (this.selectedPointLabelId === null) return null;
          return this.pointLabelPersons[this.selectedPointLabelId] || null;
        },
        isPersonCheckedForPoint(pointLabelId, personId) {
          if (!pointLabelId || !personId) return false;
          const checkedPeople = this.checkedPeopleByPoint[pointLabelId] || {};
          return !!checkedPeople[personId];
        },
        setPersonCheckedForPoint(pointLabelId, personId, checked) {
          if (!pointLabelId || !personId) return;
          if (!this.checkedPeopleByPoint[pointLabelId]) {
            this.checkedPeopleByPoint[pointLabelId] = {};
          }
          this.checkedPeopleByPoint[pointLabelId][personId] = checked;
        },
        initializeHouseholdCheckboxesForPoint(pointLabelId, person) {
          if (!pointLabelId || !person || !this.getHouseholdMembers) return;
          const householdMembers = this.getHouseholdMembers(person);
          this.householdCheckboxes = {};
          householdMembers.forEach(member => {
            if (member && member.id) {
              this.householdCheckboxes[member.id] = this.isPersonCheckedForPoint(pointLabelId, member.id);
            }
          });
        },
        clearCurrentFaceLabel() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (key) {
            delete this.faceLabels[key];
            delete this.currentSessionLabels[key];
            // Clear selection
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          }
        },
        clearCurrentPointLabel() {
          if (this.selectedPointLabelId === null) return;
          if (this.pointLabelPersons && this.pointLabelPersons[this.selectedPointLabelId]) {
            delete this.pointLabelPersons[this.selectedPointLabelId];
          }
          // Clear selection
          this.selectedPointLabelId = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
        },
        deletePointLabel(pointId) {
          if (!pointId || !this.selectedFile) return;
          
          const imageName = this.selectedFile.name;
          if (this.pointLabels[imageName]) {
            // Remove the point from the array
            this.pointLabels[imageName] = this.pointLabels[imageName].filter(point => point.id !== pointId);
            
            // If array is empty, remove the image entry
            if (this.pointLabels[imageName].length === 0) {
              delete this.pointLabels[imageName];
            }
          }
          
          // Clean up associated data
          if (this.pointLabelPersons && this.pointLabelPersons[pointId]) {
            delete this.pointLabelPersons[pointId];
          }
          if (this.checkedPeopleByPoint && this.checkedPeopleByPoint[pointId]) {
            delete this.checkedPeopleByPoint[pointId];
          }
        },
        setupKeyboardNavigation() {
          document.addEventListener('keydown', this.handleKeydown);
        },
        handleKeydown(event) {
          // Only handle arrow keys when user is logged in and not loading
          if (!this.user || this.loading) return;
          
          // Handle ESC key to deselect bounding box or point label (works even in input fields)
          if (event.key === 'Escape') {
            if (this.selectedBoundingBoxIndex !== null) {
              event.preventDefault();
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              return;
            }
            if (this.selectedPointLabelId !== null) {
              event.preventDefault();
              // Check if there's a person selected before deselecting
              const currentLabel = this.getCurrentPointLabel();
              const pointId = this.selectedPointLabelId;
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              
              // If no person selected, delete the point label
              if (!currentLabel) {
                this.deletePointLabel(pointId);
              }
              return;
            }
          }
          
          // Handle 'Tab' key to go to next bounding box (works even in input fields when box is selected)
          if (event.key === 'Tab' && this.selectedBoundingBoxIndex !== null && this.showFaces && this.selectedFile && this.selectedFile.model) {
            event.preventDefault();
            this.goToNextBoundingBox();
            return;
          }
          
          // Handle 'a' key to add embedding (only when person is selected and button is enabled)
          if (event.key === 'a' || event.key === 'A') {
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel && currentLabel.id && this.currentEmbeddingData && this.user && 
                !this.checkingEmbeddingInDB && !this.getEmbeddingsStoredState()) {
              event.preventDefault();
              this.handleStoreEmbeddings();
              return;
            }
          }
          
          // Don't handle if user is typing in an input field or textarea (except ESC, Tab, and 'a')
          if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            // ESC, Tab, and 'a' keys are handled above, but for other keys, return early
            // Allow arrow keys in search input to be handled by handleSearchKeydown
            return;
          }
          
          switch(event.key) {
            case 'ArrowLeft':
              event.preventDefault();
              if (this.hasPrevImage) {
                this.goPrevImage();
              }
              break;
            case 'ArrowRight':
              event.preventDefault();
              if (this.hasNextImage) {
                this.goNextImage();
              }
              break;
          }
        },
        goToNextBoundingBox() {
          if (!this.selectedFile || !this.selectedFile.model) return;
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return;
            }
            
            // Get all embedding indices that have facial areas
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => embedding.facial_area);
            
            if (embeddingsWithFaces.length === 0) return;
            
            // Find current index in the list
            const currentIndex = embeddingsWithFaces.findIndex(
              ({ index }) => index === this.selectedBoundingBoxIndex
            );
            
            if (currentIndex === -1) {
              // Current selection not found, select first one
              this.selectedBoundingBoxIndex = embeddingsWithFaces[0].index;
            } else {
              // Go to next, wrap around if at end
              const nextIndex = (currentIndex + 1) % embeddingsWithFaces.length;
              this.selectedBoundingBoxIndex = embeddingsWithFaces[nextIndex].index;
            }
            
            // Reset search and focus input
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          } catch (error) {
            console.error('Error navigating to next bounding box:', error);
          }
        },
        handleTouchStart(event) {
          // Only handle touches when user is logged in, not loading, and an image is selected
          if (!this.user || this.loading || !this.selectedImage) return;
          
          // Get the first touch point
          const touch = event.touches[0];
          this.touchStartX = touch.clientX;
          this.touchStartY = touch.clientY;
          this.isSwipe = false; // Reset swipe flag
        },
        handleTouchEnd(event) {
          // Only handle if we have a start position
          if (this.touchStartX === null || this.touchStartY === null) return;
          if (!this.user || this.loading || !this.selectedImage) {
            this.touchStartX = null;
            this.touchStartY = null;
            return;
          }
          
          // Get the end touch point
          const touch = event.changedTouches[0];
          const touchEndX = touch.clientX;
          const touchEndY = touch.clientY;
          
          // Calculate the difference
          const deltaX = touchEndX - this.touchStartX;
          const deltaY = touchEndY - this.touchStartY;
          
          // Minimum swipe distance (in pixels)
          const minSwipeDistance = 50;
          
          // Check if it's a horizontal swipe (more horizontal than vertical)
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
            // Prevent default to avoid any unwanted behavior
            event.preventDefault();
            this.isSwipe = true;
            
            // Hide banner on swipe
            this.bannerVisible = false;
            
            if (deltaX > 0) {
              // Swipe right - go to previous image
              if (this.hasPrevImage) {
                this.goPrevImage();
              }
            } else {
              // Swipe left - go to next image
              if (this.hasNextImage) {
                this.goNextImage();
              }
            }
          } else {
            // It's a tap (not a swipe) - show banner
            if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
              // Very small movement, treat as tap
              this.bannerVisible = !this.bannerVisible;
            }
          }
          
          // Reset touch positions
          this.touchStartX = null;
          this.touchStartY = null;
        }
      },
      computed: {
        sessions() {
          // Return only root-level directories (sessions), sorted from latest to earliest
          const dirs = this.directoryTree.filter(node => node.type === 'directory');
          // Sort from latest to earliest (descending order)
          const sorted = Array.from(dirs);
          sorted.sort((a, b) => {
            // Try to parse as dates if they look like dates, otherwise use string comparison
            const dateA = new Date(a.name);
            const dateB = new Date(b.name);
            
            // If both are valid dates, compare as dates
            if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
              return dateB - dateA; // Descending: later dates first
            }
            
            // Otherwise use string comparison (descending)
            return b.name.localeCompare(a.name);
          });
          return sorted;
        },
        hasPrevImage() {
          return this.currentFileIndex > 0;
        },
        hasNextImage() {
          return this.currentFileIndex >= 0 && this.currentFileIndex < this.currentFolderFiles.length - 1;
        }
      },
      mounted() {
        // Auto-scroll down 1px to trigger URL bar hiding on mobile
        setTimeout(() => {
          window.scrollTo(0, 1);
          // Scroll back to top after a moment (URL bar will stay hidden)
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 100);
        }, 100);
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
          // Re-trigger scroll to hide URL bar after orientation change
          setTimeout(() => {
            window.scrollTo(0, 1);
            setTimeout(() => {
              window.scrollTo(0, 0);
            }, 100);
            // Force resize event
            window.dispatchEvent(new Event('resize'));
          }, 300);
        });
        
        // Listen for authentication state changes
        Services.auth.onAuthStateChanged((user) => {
          this.user = user;
          this.loading = false;
          if (user) {
            this.fetchDirectoryTree();
          }
        });
        
        // Add keyboard navigation
        this.setupKeyboardNavigation();
      },
      beforeUnmount() {
        // Clean up keyboard event listeners
        document.removeEventListener('keydown', this.handleKeydown);
      },
    });

    app.component('directory-tree', {
      props: ['nodes', 'selectedFile', 'isRootLevel'],
      data() {
        return {
          collapsed: {} // Track collapsed state for directories
        };
      },
      mounted() {
        this.setupInitialExpansion();
      },
      watch: {
        nodes: {
          handler() {
            this.setupInitialExpansion();
          },
          immediate: true
        }
      },
      methods: {
        setupInitialExpansion() {
          // Auto-expand the first (latest) date folder at root level
          if (this.isRootLevel && this.nodes && this.nodes.length > 0) {
            console.log('Setting up initial expansion for root level with', this.nodes.length, 'nodes');
            const firstNode = this.nodes[0];
            console.log('First node:', firstNode);
            if (firstNode.type === 'directory') {
              console.log('Expanding first directory:', firstNode.name);
              this.collapsed[firstNode.name] = false; // Expand the latest date folder
            }
            // Collapse all other directories at root level
            this.nodes.slice(1).forEach(node => {
              if (node.type === 'directory') {
                console.log('Collapsing directory:', node.name);
                this.collapsed[node.name] = true; // Collapse other date folders
              }
            });
            console.log('Final collapsed state:', this.collapsed);
          }
        },
        toggleCollapse(node) {
          this.collapsed = { ...this.collapsed, [node.name]: !this.collapsed[node.name] };
        },
        isCollapsed(node) {
          // For directories, check if explicitly set in collapsed object
          if (node.type === 'directory') {
            if (this.collapsed[node.name] === undefined) {
              return true; // Default to collapsed if not explicitly set
            }
            return this.collapsed[node.name]; // Return the explicit value (true/false)
          }
          return false; // Files are never collapsed
        },
        isSelected(node) {
          return this.selectedFile && this.selectedFile.name === node.name && this.selectedFile.mediaLink === node.mediaLink;
        }
      },
      template: `
        <ul class="select-none">
          <li v-for="node in nodes" :key="node.name" class="">
            <div v-if="node.type === 'directory'" @click="toggleCollapse(node)" class="flex items-center gap-2 px-3 py-1.5 cursor-pointer hover:bg-gray-50 text-gray-800 text-sm leading-tight font-[Arial_Narrow,Arial,sans-serif]">
              <svg :class="['h-4 w-4 text-gray-500 transform transition-transform', { 'rotate-0': isCollapsed(node), '-rotate-90': !isCollapsed(node) }]" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M12.03 5.47a.75.75 0 0 1 0 1.06L9.06 9.5l2.97 2.97a.75.75 0 1 1-1.06 1.06l-3.5-3.5a.75.75 0 0 1 0-1.06l3.5-3.5a.75.75 0 0 1 1.06 0Z" clip-rule="evenodd" />
              </svg>
              <svg class="h-4 w-4 text-amber-500" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M10 4H4a2 2 0 0 0-2 2v1h20V8a2 2 0 0 0-2-2h-8l-2-2Z"/>
                <path d="M22 9H2v9a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9Z"/>
              </svg>
              <span class="font-medium truncate">{{ node.name }}</span>
            </div>
            <div v-else @click="$emit('select', node)" :class="['group flex items-center gap-2 pl-9 pr-2 py-1.5 cursor-pointer hover:bg-blue-50 text-xs leading-tight font-[Arial_Narrow,Arial,sans-serif]', { 'bg-blue-100 text-blue-800': isSelected(node), 'text-gray-700': !isSelected(node) } ]">
              <svg class="h-4 w-4 text-gray-400 group-hover:text-blue-500" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M14 3H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9l-6-6Z"/>
              </svg>
              <span class="truncate">{{ node.name }}</span>
            </div>

            <transition name="fade" mode="out-in">
              <div v-show="!isCollapsed(node) && node.children.length" class="ml-4 border-l border-gray-200">
                <directory-tree :nodes="node.children" :selected-file="selectedFile" :is-root-level="false" @select="$emit('select', $event)"></directory-tree>
              </div>
            </transition>
          </li>
        </ul>`
    });

    app.component('image-annotation', {
      props: ['imageSrc', 'annotations', 'selectedFile', 'showFaces', 'faceLabels', 'selectedBoundingBoxIndex', 'pointLabels', 'selectedPointLabelId', 'pointLabelPersons', 'checkedPeopleByPoint', 'getFaceLabelKey', 'checkedPeopleByBox', 'planningCentrePeople', 'getHouseholdMembers'],
      template: `<div class="w-full h-full flex items-center justify-center relative">
        <div v-if="isLoading" class="loading-container">
          <div class="spinner"></div>
          <p>Loading image...</p>
        </div>
        <v-stage v-else :config="stageConfig" @mousedown="handleStageClick" @mousemove="handleStageMouseMove" @mouseleave="handleStageMouseLeave">
          <v-layer>
            <v-image :config="imageConfig"></v-image>
            <v-rect v-for="(box, index) in facialAreaBoxes" :key="index" :config="box" @click="handleBoxClick(box.embeddingIndex)"></v-rect>
            <v-group v-for="(label, index) in nameLabels" :key="'name-' + index" :config="{ x: label.groupX, y: label.groupY }">
              <v-rect :config="label.bgRect"></v-rect>
              <v-text v-for="(textItem, textIndex) in label.texts" :key="'text-' + textIndex" :config="textItem"></v-text>
            </v-group>
            <v-rect v-for="(box, index) in annotations" :key="'annotation-' + index" :config="box"></v-rect>
            <v-rect v-for="(pointGroup, index) in pointLabelGroups" :key="'point-box-' + index" :config="pointGroup.boundingBox" @click="handlePointLabelClick(pointGroup.id)"></v-rect>
            <v-text v-for="(pointGroup, index) in pointLabelGroups" :key="'point-marker-' + index" :config="pointGroup.marker"></v-text>
            <v-group v-for="(label, index) in pointNameLabels" :key="'point-name-' + index" :config="{ x: label.groupX, y: label.groupY }">
              <v-rect :config="label.bgRect"></v-rect>
              <v-text v-for="(textItem, textIndex) in label.texts" :key="'point-text-' + textIndex" :config="textItem"></v-text>
            </v-group>
            <v-group v-if="panTiltZoomConfig" :config="{ x: panTiltZoomConfig.groupX, y: panTiltZoomConfig.groupY }">
              <v-rect :config="panTiltZoomConfig.bgRect"></v-rect>
              <v-text :config="panTiltZoomConfig.text"></v-text>
            </v-group>
          </v-layer>
        </v-stage>
        <div v-if="showShiftTooltip" :style="{ position: 'absolute', left: tooltipX + 'px', top: tooltipY + 'px', pointerEvents: 'none', zIndex: 1000, backgroundColor: 'rgba(0, 0, 0, 0.8)', color: 'white', padding: '4px 8px', borderRadius: '4px', fontSize: '12px', whiteSpace: 'nowrap' }">
          Left Click to Add Name
        </div>
      </div>`,
      data() {
        return {
          stageConfig: { width: 800, height: 600 },
          imageConfig: { image: null, x: 0, y: 0, width: 800, height: 600 },
          isLoading: false,
          containerWidth: 0,
          containerHeight: 0,
          selectedBoxOpacity: 1,
          selectedPointOpacity: 1,
          blinkInterval: null,
          pointBlinkInterval: null,
          showShiftTooltip: false,
          tooltipX: 0,
          tooltipY: 0
        };
      },
      computed: {
        facialAreaBoxes() {
          // Return empty array if showFaces is false
          if (!this.showFaces) {
            return [];
          }
          
          if (!this.selectedFile || !this.selectedFile.model || !this.imageConfig.image) {
            return [];
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return [];
            }
            
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            // Calculate scale factors
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => {
                // Filter out embeddings without facial_area
                if (!embedding.facial_area) {
                  return false;
                }
                // Exclude bounding boxes that are approximately the same size as the entire image
                // Use a threshold of 10 pixels
                const area = embedding.facial_area;
                const areaWidth = area.w || 0;
                const areaHeight = area.h || 0;
                const widthDiff = Math.abs(areaWidth - naturalWidth);
                const heightDiff = Math.abs(areaHeight - naturalHeight);
                if (widthDiff <= 1 && heightDiff <= 1) {
                  return false; // Exclude this box - it covers the entire image (within 1px threshold)
                }
                return true;
              });
            
            return embeddingsWithFaces.map(({ embedding, index }) => {
              const area = embedding.facial_area;
              const x = (area.x || 0) * scaleX;
              const y = (area.y || 0) * scaleY;
              const width = (area.w || 0) * scaleX;
              const height = (area.h || 0) * scaleY;
              
              const isSelected = this.selectedBoundingBoxIndex === index;
              
              // Check if this face has a label using the new key format
              let hasLabel = false;
              if (this.selectedFile && this.getFaceLabelKey && this.faceLabels) {
                const key = this.getFaceLabelKey(this.selectedFile.name, area);
                hasLabel = key ? !!this.faceLabels[key] : false;
              }
              
              // Color logic: Amber for unlabelled, Soft Green for labelled
              // Selected boxes blink with color based on label status
              let strokeColor = '#FFD700'; // Amber - Not Labelled (default)
              let strokeWidth = 2;
              let opacity = 1;
              
              if (isSelected) {
                // Selected box: use green if labelled, amber if not labelled
                strokeColor = hasLabel ? '#10B981' : '#FFD700'; // Soft Green if labelled, Amber if not
                strokeWidth = 4; // Thicker for visibility
                opacity = this.selectedBoxOpacity; // Blinking opacity
              } else if (hasLabel) {
                strokeColor = '#10B981'; // Soft Green - Labelled
                strokeWidth = 2;
                opacity = 1;
              } else {
                strokeColor = '#FFD700'; // Amber - Not Labelled
                strokeWidth = 2;
                opacity = 1;
              }
              
              return {
                x: x,
                y: y,
                width: width,
                height: height,
                stroke: strokeColor,
                strokeWidth: strokeWidth,
                fill: 'transparent',
                opacity: opacity,
                embeddingIndex: index
              };
            });
          } catch (error) {
            console.error('Error parsing facial areas from model:', error);
            return [];
          }
        },
        nameLabels() {
          // Return empty array if showFaces is false
          if (!this.showFaces || !this.selectedFile || !this.selectedFile.model) {
            return [];
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings) || !this.imageConfig.image) {
              return [];
            }
            
            // Get image dimensions and scale factors
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            // Filter embeddings that have facial_area
            const embeddingsWithFaces = model.embeddings
              .map((embedding, index) => ({ embedding, index }))
              .filter(({ embedding }) => embedding.facial_area);
            
            const allLabels = [];
            
            embeddingsWithFaces.forEach(({ embedding, index }) => {
              const area = embedding.facial_area;
              const x = (area.x || 0) * scaleX;
              const y = (area.y || 0) * scaleY;
              const width = (area.w || 0) * scaleX;
              const height = (area.h || 0) * scaleY;
              
              // Get the face label key for this bounding box
              let key = null;
              if (this.selectedFile && this.getFaceLabelKey) {
                key = this.getFaceLabelKey(this.selectedFile.name, area);
              }
              
              if (!key) return;
              
              // Get the identified person from faceLabels (for vector-matched faces)
              const identifiedPerson = this.faceLabels && this.faceLabels[key] ? this.faceLabels[key] : null;
              
              // Get checked people for this bounding box
              const checkedPeople = this.checkedPeopleByBox && this.checkedPeopleByBox[key] ? this.checkedPeopleByBox[key] : {};
              const checkedPersonIds = Object.keys(checkedPeople).filter(personId => checkedPeople[personId]);
              
              // If there's an identified person, include them even if not explicitly checked
              if (identifiedPerson && identifiedPerson.id && !checkedPersonIds.includes(identifiedPerson.id)) {
                checkedPersonIds.push(identifiedPerson.id);
              }
              
              if (checkedPersonIds.length === 0) return; // No checked people, don't show label
              
              // Get person objects for all checked people
              const checkedPersons = checkedPersonIds
                .map(personId => {
                  if (!this.planningCentrePeople) return null;
                  return this.planningCentrePeople.find(p => p.id === personId);
                })
                .filter(p => p !== null);
              
              if (checkedPersons.length === 0) return;
              
              // Separate selected person from household members
              let selectedPerson = null;
              let householdMembers = [];
              
              if (identifiedPerson) {
                // Use identified person as selected person
                selectedPerson = identifiedPerson;
                // Get household members from checked people (excluding selected person)
                householdMembers = checkedPersons.filter(p => p.id !== identifiedPerson.id);
              } else {
                // No identified person, use first checked person as selected
                selectedPerson = checkedPersons[0];
                householdMembers = checkedPersons.slice(1);
              }
              
              if (!selectedPerson || !selectedPerson.name) return;
              
              // Build text lines: selected person on first line, each household member on separate lines
              const fontSize = 12;
              const padding = 4;
              const lineHeight = fontSize + 2; // Line height with spacing
              
              const texts = [];
              texts.push({
                x: padding,
                y: padding,
                text: selectedPerson.name,
                fontSize: fontSize,
                fontFamily: 'Arial',
                fill: '#D3D3D3', // Light grey
                align: 'left'
              });
              
              // Add each household member on a separate line
              householdMembers.forEach((member, index) => {
                if (member && member.name) {
                  texts.push({
                    x: padding,
                    y: padding + (index + 1) * lineHeight,
                    text: member.name,
                    fontSize: fontSize,
                    fontFamily: 'Arial',
                    fill: '#D3D3D3', // Light grey
                    align: 'left'
                  });
                }
              });
              
              // Calculate dimensions for background
              const allNames = [selectedPerson.name, ...householdMembers.map(p => p.name).filter(name => name)];
              const maxTextWidth = Math.max(...allNames.map(name => name.length * fontSize * 0.6));
              const textHeight = texts.length * lineHeight + padding;
              const textWidth = maxTextWidth;
              
              // Center the group horizontally below the box
              const groupX = x + (width - textWidth) / 2 - padding; // Center horizontally
              const groupY = y + height + 2; // 2px below the box
              
              allLabels.push({
                groupX: groupX,
                groupY: groupY,
                bgRect: {
                  x: 0,
                  y: 0,
                  width: textWidth + padding * 2,
                  height: textHeight,
                  fill: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black background
                  cornerRadius: 2
                },
                texts: texts
              });
            });
            
            return allLabels;
          } catch (error) {
            console.error('Error creating name labels:', error);
            return [];
          }
        },
        pointLabelGroups() {
          if (!this.selectedFile || !this.pointLabels || !this.imageConfig.image) {
            return [];
          }
          
          const imageName = this.selectedFile.name;
          const points = this.pointLabels[imageName] || [];
          
          if (points.length === 0) {
            return [];
          }
          
          const img = this.imageConfig.image;
          const naturalWidth = img.naturalWidth;
          const naturalHeight = img.naturalHeight;
          const displayWidth = this.imageConfig.width;
          const displayHeight = this.imageConfig.height;
          
          const scaleX = displayWidth / naturalWidth;
          const scaleY = displayHeight / naturalHeight;
          
          return points.map(point => {
            const x = point.naturalX * scaleX;
            const y = point.naturalY * scaleY;
            const isSelected = this.selectedPointLabelId === point.id;
            
            // Check if this point has a person selected
            const hasPerson = this.pointLabelPersons && this.pointLabelPersons[point.id] ? true : false;
            
            // Marker size and offset
            const fontSize = isSelected ? 24 : 16;
            const offsetX = isSelected ? 12 : 8;
            const offsetY = isSelected ? 12 : 8;
            
            // Bounding box around the marker (larger clickable area)
            const boxSize = isSelected ? 40 : 32; // Larger box when selected
            const boxX = x - boxSize / 2;
            const boxY = y - boxSize / 2;
            // Color logic: 
            // - Selected + no person: Blinking Yellow (#FFD700)
            // - Selected + has person: Blinking Green (#10B981)
            // - Not selected + has person: Solid Green (#10B981)
            // - Not selected + no person: Should not exist (point should be deleted)
            const boxColor = hasPerson ? '#10B981' : '#FFD700'; // Green if person selected, Yellow if not
            // Opacity: Blinking when selected, solid when not selected
            const boxOpacity = isSelected ? this.selectedPointOpacity : 1;
            
            return {
              id: point.id,
              boundingBox: {
                x: boxX,
                y: boxY,
                width: boxSize,
                height: boxSize,
                fill: 'transparent',
                stroke: boxColor,
                strokeWidth: isSelected ? 3 : 2,
                opacity: boxOpacity
              },
              marker: {
                x: x,
                y: y,
                text: '', // &#9678; character
                fontSize: fontSize,
                fontFamily: 'Arial',
                fill: boxColor,
                align: 'center',
                verticalAlign: 'middle',
                offsetX: offsetX,
                offsetY: offsetY,
                opacity: boxOpacity,
                listening: false // Marker itself doesn't need to be clickable, the box handles it
              }
            };
          });
        },
        pointNameLabels() {
          if (!this.selectedFile || !this.pointLabels || !this.pointLabelPersons || !this.imageConfig.image) {
            return [];
          }
          
          const imageName = this.selectedFile.name;
          const points = this.pointLabels[imageName] || [];
          
          if (points.length === 0) {
            return [];
          }
          
          const img = this.imageConfig.image;
          const naturalWidth = img.naturalWidth;
          const naturalHeight = img.naturalHeight;
          const displayWidth = this.imageConfig.width;
          const displayHeight = this.imageConfig.height;
          
          const scaleX = displayWidth / naturalWidth;
          const scaleY = displayHeight / naturalHeight;
          
          const allLabels = [];
          
          points.forEach(point => {
            // Get the identified person for this point label
            const identifiedPerson = this.pointLabelPersons[point.id] || null;
            
            if (!identifiedPerson) return; // No person selected, don't show label
            
            // Get checked people for this point label
            const checkedPeople = this.checkedPeopleByPoint && this.checkedPeopleByPoint[point.id] ? this.checkedPeopleByPoint[point.id] : {};
            const checkedPersonIds = Object.keys(checkedPeople).filter(personId => checkedPeople[personId]);
            
            // If there's an identified person, include them even if not explicitly checked
            if (identifiedPerson && identifiedPerson.id && !checkedPersonIds.includes(identifiedPerson.id)) {
              checkedPersonIds.push(identifiedPerson.id);
            }
            
            if (checkedPersonIds.length === 0) return; // No checked people, don't show label
            
            // Get person objects for all checked people
            const checkedPersons = checkedPersonIds
              .map(personId => {
                if (!this.planningCentrePeople) return null;
                return this.planningCentrePeople.find(p => p.id === personId);
              })
              .filter(p => p !== null);
            
            if (checkedPersons.length === 0) return;
            
            // Separate selected person from household members
            let selectedPerson = identifiedPerson;
            let householdMembers = checkedPersons.filter(p => p.id !== identifiedPerson.id);
            
            if (!selectedPerson || !selectedPerson.name) return;
            
            // Calculate position
            const x = point.naturalX * scaleX;
            const y = point.naturalY * scaleY;
            const boxSize = 32; // Default box size for positioning
            
            // Build text lines: selected person on first line, each household member on separate lines
            const fontSize = 12;
            const padding = 4;
            const lineHeight = fontSize + 2; // Line height with spacing
            
            const texts = [];
            texts.push({
              x: padding,
              y: padding,
              text: selectedPerson.name,
              fontSize: fontSize,
              fontFamily: 'Arial',
              fill: '#D3D3D3', // Light grey
              align: 'left'
            });
            
            // Add each household member on a separate line
            householdMembers.forEach((member, index) => {
              if (member && member.name) {
                texts.push({
                  x: padding,
                  y: padding + (index + 1) * lineHeight,
                  text: member.name,
                  fontSize: fontSize,
                  fontFamily: 'Arial',
                  fill: '#D3D3D3', // Light grey
                  align: 'left'
                });
              }
            });
            
            // Calculate dimensions for background
            const allNames = [selectedPerson.name, ...householdMembers.map(p => p.name).filter(name => name)];
            const maxTextWidth = Math.max(...allNames.map(name => name.length * fontSize * 0.6));
            const textHeight = texts.length * lineHeight + padding;
            const textWidth = maxTextWidth;
            
            // Center the group horizontally below the point marker
            const groupX = x - textWidth / 2 - padding; // Center horizontally
            const groupY = y + boxSize / 2 + 2; // 2px below the marker
            
            allLabels.push({
              groupX: groupX,
              groupY: groupY,
              bgRect: {
                x: 0,
                y: 0,
                width: textWidth + padding * 2,
                height: textHeight,
                fill: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black background
                cornerRadius: 2
              },
              texts: texts
            });
          });
          
          return allLabels;
        },
        panTiltZoom() {
          // Extract pan, tilt, zoom from filename
          if (!this.selectedFile || !this.selectedFile.name) {
            return null;
          }
          
          const filename = this.selectedFile.name.toLowerCase();
          
          // Check if it's a JPG file
          if (!filename.endsWith('.jpg') && !filename.endsWith('.jpeg')) {
            return null;
          }
          
          // Pattern to match: panXX.X_tiltXX.X_zoomXX.X (taking first occurrence)
          // Handles negative numbers like pan-34.4
          const panMatch = filename.match(/_pan(-?\d+\.?\d*)/);
          const tiltMatch = filename.match(/_tilt(-?\d+\.?\d*)/);
          const zoomMatch = filename.match(/_zoom(-?\d+\.?\d*)/);
          
          if (panMatch && tiltMatch && zoomMatch) {
            return {
              pan: parseFloat(panMatch[1]),
              tilt: parseFloat(tiltMatch[1]),
              zoom: parseFloat(zoomMatch[1])
            };
          }
          
          return null;
        },
        panTiltZoomConfig() {
          if (!this.panTiltZoom || !this.imageConfig.image) {
            return null;
          }
          
          const { pan, tilt, zoom } = this.panTiltZoom;
          const text = `Pan: ${pan.toFixed(1)} Tilt: ${tilt.toFixed(1)} Zoom: ${zoom.toFixed(1)}`;
          
          // Position in bottom left corner with some padding
          const padding = 10;
          const fontSize = 14;
          const fontFamily = 'Arial';
          
          // Create a temporary canvas to measure text width
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.font = `${fontSize}px ${fontFamily}`;
          const textWidth = ctx.measureText(text).width;
          const textHeight = fontSize;
          
          const textPadding = 6;
          const bgWidth = textWidth + textPadding * 2;
          const bgHeight = textHeight + textPadding * 2;
          
          const groupX = padding;
          const groupY = this.stageConfig.height - bgHeight - padding;
          
          return {
            groupX: groupX,
            groupY: groupY,
            bgRect: {
              x: 0,
              y: 0,
              width: bgWidth,
              height: bgHeight,
              fill: 'rgba(0, 0, 0, 0.5)',
              cornerRadius: 4
            },
            text: {
              x: textPadding,
              y: textPadding,
              text: text,
              fontSize: fontSize,
              fontFamily: fontFamily,
              fill: 'white',
              align: 'left',
              verticalAlign: 'top'
            }
          };
        }
      },
      watch: {
        selectedBoundingBoxIndex: {
          handler(newVal) {
            // Start/stop blinking animation when selection changes
            if (this.blinkInterval) {
              clearInterval(this.blinkInterval);
              this.blinkInterval = null;
            }
            
            if (newVal !== null) {
              // Start blinking animation
              this.selectedBoxOpacity = 1;
              this.blinkInterval = setInterval(() => {
                this.selectedBoxOpacity = this.selectedBoxOpacity === 1 ? 0.3 : 1;
                // Force update to trigger recomputation of facialAreaBoxes
                this.$forceUpdate();
              }, 500); // Blink every 500ms
            } else {
              // Stop blinking
              this.selectedBoxOpacity = 1;
            }
          },
          immediate: false
        },
        selectedPointLabelId: {
          handler(newVal) {
            // Start/stop blinking animation when point label selection changes
            if (this.pointBlinkInterval) {
              clearInterval(this.pointBlinkInterval);
              this.pointBlinkInterval = null;
            }
            
            if (newVal !== null) {
              // Start blinking animation
              this.selectedPointOpacity = 1;
              this.pointBlinkInterval = setInterval(() => {
                this.selectedPointOpacity = this.selectedPointOpacity === 1 ? 0.3 : 1;
                // Force update to trigger recomputation of pointLabelMarkers
                this.$forceUpdate();
              }, 500); // Blink every 500ms
            } else {
              // Stop blinking
              this.selectedPointOpacity = 1;
            }
          },
          immediate: false
        },
        imageSrc: {
          handler(newSrc) {
            if (!newSrc) return;
            this.loadImage(newSrc);
          },
          immediate: true
        },
        selectedFile: {
          handler(newFile, oldFile) {
            // Recalculate boxes when file changes
            this.$nextTick(() => {
              // Force update by accessing the computed property
              this.$forceUpdate();
            });
          },
          deep: true
        },
        'selectedFile.model': {
          handler() {
            // Recalculate boxes when model data is loaded
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          }
        },
        imageConfig: {
          handler() {
            // Recalculate boxes when image dimensions change
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          },
          deep: true
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.updateDimensions();
        });
        window.addEventListener('resize', this.updateDimensions);
        // Listen for Shift key release to hide tooltip
        window.addEventListener('keyup', this.handleKeyUp);
      },
      beforeUnmount() {
        window.removeEventListener('resize', this.updateDimensions);
        window.removeEventListener('keyup', this.handleKeyUp);
        // Clean up blinking intervals
        if (this.blinkInterval) {
          clearInterval(this.blinkInterval);
          this.blinkInterval = null;
        }
        if (this.pointBlinkInterval) {
          clearInterval(this.pointBlinkInterval);
          this.pointBlinkInterval = null;
        }
      },
      methods: {
        handleBoxClick(embeddingIndex) {
          this.$emit('face-box-click', embeddingIndex);
        },
        handleStageMouseMove(event) {
          // Check if Shift key is pressed
          if (event.evt.shiftKey) {
            const stage = event.target.getStage();
            const pointerPos = stage.getPointerPosition();
            const container = stage.container();
            const containerRect = container.getBoundingClientRect();
            
            // Calculate tooltip position relative to the container
            this.tooltipX = pointerPos.x + 10; // Offset to the right of cursor
            this.tooltipY = pointerPos.y - 20; // Offset above cursor
            this.showShiftTooltip = true;
          } else {
            this.showShiftTooltip = false;
          }
        },
        handleStageMouseLeave(event) {
          this.showShiftTooltip = false;
        },
        handleKeyUp(event) {
          // Hide tooltip when Shift is released
          if (event.key === 'Shift') {
            this.showShiftTooltip = false;
          }
        },
        handleStageClick(event) {
          // Check if Shift key is pressed and left mouse button
          if (event.evt.shiftKey && event.evt.button === 0) {
            // Get the stage position
            const stage = event.target.getStage();
            const pointerPos = stage.getPointerPosition();
            
            // Get image dimensions and scale factors
            if (!this.imageConfig.image) return;
            
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            const scaleX = naturalWidth / displayWidth;
            const scaleY = naturalHeight / displayHeight;
            
            // Convert display coordinates to natural image coordinates
            const naturalX = pointerPos.x * scaleX;
            const naturalY = pointerPos.y * scaleY;
            
            // Emit event to parent to create point label
            this.$emit('point-label-create', {
              x: pointerPos.x,
              y: pointerPos.y,
              naturalX: naturalX,
              naturalY: naturalY
            });
          }
        },
        handlePointLabelClick(pointId) {
          this.$emit('point-label-click', pointId);
        },
        updateDimensions() {
          // Get the image pane container dimensions
          const imagePane = document.querySelector('.image-pane');
          if (imagePane) {
            this.containerWidth = imagePane.clientWidth;
            this.containerHeight = imagePane.clientHeight;
            console.log('Container dimensions:', this.containerWidth, 'x', this.containerHeight);
            this.calculateOptimalSize();
          } else {
            console.log('Image pane not found');
          }
        },
        calculateOptimalSize() {
          // Use most of the available space, leaving some padding
          const padding = 20;
          const availableWidth = Math.max(400, this.containerWidth - padding);
          const availableHeight = Math.max(300, this.containerHeight - padding);
          
          console.log('Calculating optimal size:', {
            containerWidth: this.containerWidth,
            containerHeight: this.containerHeight,
            availableWidth,
            availableHeight,
            hasImage: !!this.imageConfig.image
          });
          
          // If we have an image loaded, use its natural dimensions
          if (this.imageConfig.image) {
            const img = this.imageConfig.image;
            const imageAspectRatio = img.naturalWidth / img.naturalHeight;
            const containerAspectRatio = availableWidth / availableHeight;
            
            console.log('Image dimensions:', {
              naturalWidth: img.naturalWidth,
              naturalHeight: img.naturalHeight,
              imageAspectRatio,
              containerAspectRatio
            });
            
            let width, height;
            
            if (containerAspectRatio > imageAspectRatio) {
              // Container is wider than image - fit to height
              height = availableHeight;
              width = height * imageAspectRatio;
            } else {
              // Container is taller than image - fit to width
              width = availableWidth;
              height = width / imageAspectRatio;
            }
            
            // Ensure we don't exceed container bounds
            if (width > availableWidth) {
              width = availableWidth;
              height = width / imageAspectRatio;
            }
            if (height > availableHeight) {
              height = availableHeight;
              width = height * imageAspectRatio;
            }
            
            console.log('Calculated dimensions:', { width, height });
            
            // Update stage and image config
            this.stageConfig = { width: Math.floor(width), height: Math.floor(height) };
            this.imageConfig = { 
              ...this.imageConfig, 
              width: Math.floor(width), 
              height: Math.floor(height) 
            };
            
            // Force update to recalculate facial area boxes with new dimensions
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          } else {
            // Default size when no image is loaded
            const defaultWidth = Math.min(800, availableWidth);
            const defaultHeight = Math.min(600, availableHeight);
            
            this.stageConfig = { width: defaultWidth, height: defaultHeight };
            this.imageConfig = { 
              ...this.imageConfig, 
              width: defaultWidth, 
              height: defaultHeight 
            };
          }
        },
        loadImage(imageSrc) {
          this.isLoading = true;
          this.$emit('loading-change', true);
          console.log('Loading image from URL:', imageSrc);
          
          const img = new Image();
          img.crossOrigin = 'anonymous'; // Enable CORS for signed URLs
          img.onload = () => {
            console.log('Image loaded successfully, dimensions:', img.naturalWidth, 'x', img.naturalHeight);
            this.imageConfig.image = img;
            this.isLoading = false;
            this.$emit('loading-change', false);
            // Recalculate dimensions after image loads with proper sizing
            this.$nextTick(() => {
              this.updateDimensions();
            });
          };
          img.onerror = (error) => {
            console.error('Error loading image:', error);
            this.isLoading = false;
            this.$emit('loading-change', false);
          };
          img.src = imageSrc; // Use the signed URL directly
        }
      }
    });

      // Register new components
      app.component('control-side-panel', window.Components.ControlSidePanel);
      app.component('image-annotation-panel', window.Components.ImageAnnotationPanel);
      app.component('check-in-overlay', window.Components.CheckInOverlay);
      
      app.use(VueKonva);
      const vueApp = app.mount('#app');

      // Setup resizer functionality after Vue app is mounted
      // Setup resizer after Vue app is mounted with a delay to ensure DOM is ready
      setTimeout(Utils.setupResizer, 100);
    })().catch(console.error);
  </script>
</body>
</html>
