<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>eShepherd</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="eshepherd.png">
  <link rel="icon" type="image/png" sizes="16x16" href="eshepherd.png">
  <link rel="apple-touch-icon" href="eshepherd.png">
  <link rel="shortcut icon" href="eshepherd.png">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <!-- Client Vector Search Library - loaded dynamically via esm.sh -->
  <!--1. Link Vue Javascript & Konva-->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <!--2. Link VueKonva Javascript -->
  <script src="https://unpkg.com/vue-konva@3/dist/vue-konva.umd.js"></script>
  <!-- Replace Tailwind CDN with a local installation or CLI setup for production -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      /* Make page slightly taller to allow scroll */
      height: 100.1vh;
      /* Hide scrollbar but allow scrolling */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }

    html::-webkit-scrollbar, body::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }

    #app {
      display: flex;
      height: 100vh;
      min-height: 100vh;
      flex-direction: column;
      /* Add small padding to bottom to enable scroll */
      padding-bottom: 1px;
    }
    .main-content {
      display: flex;
      flex: 1;
      margin-top: 40px; /* Account for fixed header height */
      transition: margin-top 0.3s ease;
    }
    .main-content.banner-hidden {
      margin-top: 0;
    }
    .directory-pane {
      width: 25.0%;
      min-width: 200px;
      max-width: 50%;
      background-color: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow: visible;
      position: relative;
    }
    .resizer {
      width: 5px;
      cursor: ew-resize;
      background-color: #ccc;
    }
    .image-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: auto;
      height: calc(100vh - 40px); /* Full height minus header */
    }
    .image-pane img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 2s linear infinite;
    }
    .spinner-small {
      border: 2px solid #f3f3f3;
      border-top: 2px solid #3498db;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
    .file-item {
      cursor: pointer;
    }
    /* Custom scrollbar for search results */
    .search-results-scroll::-webkit-scrollbar {
      width: 6px;
    }
    .search-results-scroll::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    .search-results-scroll::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }
    .search-results-scroll::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="app">
    <!-- Top Banner -->
    <header :class="['fixed top-0 inset-x-0 h-10 bg-gray-800 text-white grid grid-cols-3 items-center px-3 text-sm shadow z-10 transition-transform duration-300', { '-translate-y-full': !bannerVisible }]">
      <div class="flex items-center">
        <button v-if="user" @click="toggleSidebar" class="flex items-center gap-1 rounded px-2 py-1 bg-gray-700 hover:bg-gray-600 active:bg-gray-500 text-xs">
          <svg class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M4 6h16v2H4V6Zm0 5h10v2H4v-2Zm0 5h16v2H4v-2Z"/></svg>
          <span>{{ sidebarCollapsed ? 'Show Sessions' : 'Hide Sessions' }}</span>
        </button>
      </div>
      <div class="text-center font-semibold tracking-wide text-orange-500">eShepherd</div>
      <div class="flex justify-end">
        <button v-if="user" @click="signOut" class="text-xs text-gray-300 hover:text-white">Sign Out</button>
      </div>
    </header>
    
    <!-- Main Content Area -->
    <div :class="['main-content', { 'banner-hidden': !bannerVisible }]">
      <!-- Left Pane: Sessions Dropdown -->
      <div :class="['directory-pane text-xs transition-all duration-200 bg-blue-50', { 'border-r border-gray-200': !sidebarCollapsed }]" :style="sidebarCollapsed ? { width: '0px', minWidth: '0px' } : { minWidth: '200px' }" id="directoryPane">
        <div v-show="!sidebarCollapsed && user" class="p-3" style="position: relative; z-index: 1;">
          <label class="block text-xs font-semibold text-gray-600 mb-2">Session</label>
          <select
            v-model="selectedSessionName"
            @change="onSessionChange"
            :disabled="loading"
            class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md bg-white text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed"
            style="position: relative; z-index: 10;"
          >
            <option value="" disabled>Select a session</option>
            <option
              v-for="session in sessions"
              :key="session.name"
              :value="session.name"
            >
              {{ session.name }}
            </option>
          </select>
          
          <!-- Show Faces Toggle -->
          <div v-if="selectedFile && selectedFile.model_url" class="mt-3">
            <button
              @click="handleFacesButtonClick"
              :class="['w-full px-2 py-1 text-xs rounded border transition-colors', getFacesButtonClass()]"
            >
              {{ getFacesButtonText() }}
            </button>
          </div>
          
          <!-- People Retrieval Status -->
          <div v-if="peopleRetrievalStatus !== 'idle'" class="mt-3">
            <div v-if="peopleRetrievalStatus === 'retrieving'" class="flex items-center gap-2 text-xs text-gray-600">
              <div class="spinner-small"></div>
              <span>Retrieving people records...</span>
            </div>
            <div v-else-if="peopleRetrievalStatus === 'completed'" class="text-xs text-gray-600">
              Retrieved {{ peopleRetrievalCount }} records
              <div v-if="selectedFile && getFaceScanningStatus()" class="mt-1">
                <div v-if="getFaceScanningStatus() === 'scanning'" class="flex items-center gap-2 text-gray-600">
                  <div class="spinner-small"></div>
                  <span>Scanning Faces...</span>
                </div>
                <div v-else-if="getFaceScanningStatus() === 'scanned'" class="flex items-center justify-between text-gray-500">
                  <span>{{ getFaceScanCount() }} Faces Scanned</span>
                  <button
                    @click="reloadEmbeddingsIndex"
                    class="ml-2 text-xs px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                    title="Reload embeddings from database"
                  >
                    Reload Embeddings
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Face Search Box -->
          <div v-if="selectedBoundingBoxIndex !== null && labellingStarted" class="mt-3">
            <label class="block text-xs font-semibold text-gray-600 mb-2">Search for Person</label>
            <input
              ref="searchInput"
              v-model="searchQuery"
              @input="performSearch"
              @keydown="handleSearchKeydown"
              type="text"
              placeholder="Type to search..."
              :disabled="peopleRetrievalStatus === 'retrieving'"
              autocomplete="off"
              autocorrect="off"
              autocapitalize="off"
              spellcheck="false"
              :class="['w-full px-2 py-1 text-xs border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500', peopleRetrievalStatus === 'retrieving' ? 'bg-gray-100 cursor-not-allowed opacity-60' : '']"
            />
            <!-- Face Guesses (Top 5 Matches) -->
            <div v-if="faceGuesses.length > 0 && !searchQuery" class="mt-2 border border-gray-200 rounded-md overflow-hidden">
              <div class="px-2 py-1 bg-gray-100 border-b border-gray-200">
                <span class="text-xs font-semibold text-gray-600">Top Matches</span>
              </div>
              <div>
                <div
                  v-for="(guess, index) in faceGuesses"
                  :key="guess.person.id || index"
                  @click="selectPerson(guess.person)"
                  class="px-2 py-1.5 text-xs cursor-pointer border-b border-gray-100 last:border-b-0 hover:bg-blue-50"
                >
                  <div class="flex items-center justify-between">
                    <div class="flex items-center flex-1 min-w-0">
                      <span class="font-medium">{{ guess.person.name }}</span>
                      <span v-if="getHouseholdMembers(guess.person).length > 0" class="ml-2 text-gray-500 text-[10px]">
                        [{{ getHouseholdMembersDisplay(guess.person) }}]
                      </span>
                    </div>
                    <span class="text-gray-600 ml-2 flex-shrink-0">{{ (guess.similarity * 100).toFixed(1) }}%</span>
                  </div>
                </div>
              </div>
            </div>
            <!-- Search Results -->
            <div v-if="searchResults.length > 0" ref="searchResultsContainer" class="mt-2 border border-gray-200 rounded-md overflow-hidden search-results-scroll" style="max-height: 108px; overflow-y: auto; scrollbar-width: thin;">
              <div
                v-for="(person, index) in searchResults"
                :key="person.id || index"
                :ref="el => { if (el) searchResultRefs[index] = el }"
                @click="selectPerson(person)"
                :class="['px-2 py-1.5 text-xs cursor-pointer border-b border-gray-100 last:border-b-0', selectedSearchIndex === index ? 'bg-blue-200' : 'hover:bg-blue-50']"
              >
                <div class="flex items-center">
                  <span class="font-medium">{{ person.name }}</span>
                  <span v-if="getHouseholdMembers(person).length > 0" class="ml-2 text-gray-500 text-[10px]">
                    [{{ getHouseholdMembersDisplay(person) }}]
                  </span>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Selected Face Label -->
          <div v-if="selectedBoundingBoxIndex !== null && getCurrentFaceLabel()" class="mt-3">
            <label class="block text-xs font-semibold text-gray-600 mb-2">Check-In Persons</label>
            
            <!-- Selected Person -->
            <div class="mb-2">
              <div class="flex items-center justify-between px-2">
                <span class="text-xs text-gray-800">{{ getCurrentFaceLabel().name }} ({{ getCurrentFaceLabel().id }})</span>
                <input
                  type="checkbox"
                  :checked="getSelectedPersonCheckedState()"
                  @change="handleSelectedPersonCheckboxChange"
                  :class="['w-3 h-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500', !getSelectedPersonCheckedState() ? 'opacity-50' : '']"
                />
              </div>
            </div>
            
            <!-- Embeddings Stored -->
            <div class="mb-2 px-2 flex items-center justify-between">
              <span class="text-xs text-gray-600">{{ getMatchDisplayText() }}</span>
              <button
                @click="handleStoreEmbeddings"
                :disabled="checkingEmbeddingInDB || getEmbeddingsStoredState()"
                :class="['text-xs px-2 py-1 rounded border transition-colors flex items-center justify-center min-w-[120px]', (checkingEmbeddingInDB || getEmbeddingsStoredState()) ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-500 text-white border-blue-600 hover:bg-blue-600']"
              >
                <span v-if="checkingEmbeddingInDB" class="flex items-center gap-1">
                  <div class="spinner-small"></div>
                </span>
                <span v-else>{{ getEmbeddingsStoredState() ? 'Embedding Saved' : 'Add This Embedding [a]' }}</span>
              </button>
            </div>
            
            <!-- Household Groups -->
            <div v-if="getHouseholdGroups(getCurrentFaceLabel()).length > 0" class="space-y-2">
              <div
                v-for="(group, groupIndex) in getHouseholdGroups(getCurrentFaceLabel())"
                :key="groupIndex"
                class="border border-gray-300 rounded bg-gray-50 py-1"
              >
                <div
                  v-for="(member, memberIndex) in group.members"
                  :key="member.id || memberIndex"
                  class="flex items-center justify-between py-1 px-2"
                >
                  <span :class="['text-xs', getSelectedPersonCheckedState() ? 'text-gray-700' : 'text-gray-400']">{{ member.name }}</span>
                  <input
                    type="checkbox"
                    :checked="getHouseholdCheckboxState(member.id)"
                    @change="handleHouseholdCheckboxChange(member.id, $event)"
                    :disabled="!getSelectedPersonCheckedState()"
                    :class="['w-3 h-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500', !getSelectedPersonCheckedState() ? 'opacity-50 cursor-not-allowed' : '']"
                  />
                </div>
              </div>
            </div>
          </div>
          
        </div>
      </div>

      <!-- Resizer -->
      <div class="resizer" id="resizer" v-show="!sidebarCollapsed && user"></div>

      <!-- Right Pane: Image Display / Sign-in -->
      <div class="image-pane bg-gray-50">
        <!-- Sign-in UI -->
        <div v-if="!user && !loading" class="flex items-center justify-center h-full bg-gray-50">
          <div class="text-center">
            <h1 class="text-2xl font-bold text-gray-900 mb-4">eShepherd</h1>
            <p class="text-gray-600 mb-6">Sign in to view your images</p>
            <button @click="signIn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
              Sign in with Google
            </button>
            <div v-if="error" class="mt-4 text-red-600">{{ error }}</div>
          </div>
        </div>

        <!-- Loading UI -->
        <div v-if="loading" class="flex items-center justify-center h-full bg-gray-50">
          <div class="text-center">
            <div class="spinner mx-auto mb-4"></div>
            <p class="text-gray-600">Loading...</p>
          </div>
        </div>

        <!-- Image Display UI -->
        <div v-if="user && !loading">
          <div class="w-full border-b border-gray-200 bg-gray-50 px-2 py-1 flex items-center justify-center gap-1">
            <button
              :disabled="!hasPrevImage"
              @click="bannerVisible = true; goPrevImage()"
              class="inline-flex items-center gap-1 rounded bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed text-gray-800 shadow px-1.5 py-0.5 text-[11px]"
            >
              <svg class="h-3 w-3" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M12.03 15.53a.75.75 0 0 1-1.06 0l-4.5-4.5a.75.75 0 0 1 0-1.06l4.5-4.5a.75.75 0 1 1 1.06 1.06L8.56 10l3.47 3.47a.75.75 0 0 1 0 1.06Z" clip-rule="evenodd"/></svg>
              Prev
            </button>
            <button
              :disabled="!hasNextImage"
              @click="bannerVisible = true; goNextImage()"
              class="inline-flex items-center gap-1 rounded bg-white hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed text-gray-800 shadow px-1.5 py-0.5 text-[11px]"
            >
              Next
              <svg class="h-3 w-3" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M7.97 4.47a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1 0 1.06l-4.5 4.5a.75.75 0 1 1-1.06-1.06L11.44 10 7.97 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/></svg>
            </button>
            <span class="text-xs text-gray-500 ml-2">Use ← → arrow keys<span v-if="selectedBoundingBoxIndex !== null">, Tab for next box, ESC to deselect</span></span>
          </div>
          <div class="flex-1 w-full flex items-center justify-center bg-gray-50 relative" @touchstart="handleTouchStart" @touchend="handleTouchEnd">
            <image-annotation v-if="selectedImage" :image-src="selectedImage" :annotations="annotations" :selected-file="selectedFile" :show-faces="showFaces" :face-labels="faceLabels" :selected-bounding-box-index="selectedBoundingBoxIndex" :get-face-label-key="getFaceLabelKey" @update="onUpdateAnnotations" @loading-change="imageLoading = $event" @face-box-click="onFaceBoxClick"></image-annotation>
            <p v-else class="text-gray-500">Select a session to view images</p>
            <div v-if="selectedImage && currentFolderFiles.length > 0 && !imageLoading" class="absolute top-4 right-4 text-white px-3 py-1.5 rounded text-sm font-medium" style="background-color: rgba(0, 0, 0, 0.5);">
              {{ currentFileIndex + 1 }}/{{ currentFolderFiles.length }}
            </div>
            <div v-if="selectedFile && getImageTimestamp(selectedFile) && !imageLoading" class="absolute top-4 left-4 text-white px-3 py-1.5 rounded text-sm font-medium" style="background-color: rgba(0, 0, 0, 0.5);">
              {{ getImageTimestamp(selectedFile) }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAd9QCOrxuVFD3I-kmyY4-ZvNRCSibdb8I",
      authDomain: "charisfriends-54cf3.firebaseapp.com",
      databaseURL: "https://charisfriends-54cf3.firebaseio.com",
      projectId: "charisfriends-54cf3",
      storageBucket: "charisfriends-54cf3.firebasestorage.app",
      messagingSenderId: "12705856594",
      appId: "1:12705856594:web:a4bafa9cbaf7423690738b"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();

    const VueKonva = window['vue-konva'].default;
    const app = Vue.createApp({
          data() {
        return {
          directoryTree: [],
          selectedImage: null,
          selectedFile: null,
          selectedSession: null,
          selectedSessionName: '',
          annotations: [],
          currentFolderFiles: [],
          currentFileIndex: -1,
          sidebarCollapsed: false,
          user: null,
          loading: true,
          imageLoading: false,
          error: null,
          touchStartX: null,
          touchStartY: null,
          bannerVisible: true,
          isSwipe: false,
          showFaces: false,
          labellingStarted: false,
          peopleRetrievalStatus: 'idle', // 'idle', 'retrieving', 'completed'
          peopleRetrievalCount: 0,
          planningCentrePeople: [], // Store the actual records
          selectedBoundingBoxIndex: null, // Index of the selected bounding box
          faceLabels: {}, // Map of "imageName_x_y_w_h" to selected person record (persists per session)
          searchQuery: '',
          searchResults: [],
          selectedSearchIndex: -1, // Index of the highlighted search result
          faceGuesses: [], // Top 5 matches for the selected bounding box: [{person, similarity}]
          currentSessionLabels: {}, // Store labels for current session
          searchResultRefs: {}, // Refs to search result elements for scrolling
          selectedPersonChecked: true, // Track if selected person checkbox is checked
          householdCheckboxes: {}, // Track household member checkboxes state (local to current selection)
          checkedPeople: {}, // Global list of checked people (person ID -> true/false) per session
          embeddingsStored: {}, // Track if embeddings are stored for each bounding box (keyed by face label key)
          embeddingsCountCache: {}, // Cache for embeddings count per person ID
          currentEmbeddingData: null, // Store current embedding data for comparison
          checkingEmbeddingInDB: false, // Track if we're currently checking embedding in DB
          embeddingIndex: null, // EmbeddingIndex from client-vector-search
          ClientVectorSearchModule: null, // Store the imported module
          faceMatchCache: {}, // Cache face matches per image: {imageKey: {embeddingIndex: {personId, similarity, person}}}
          SIMILARITY_THRESHOLD: 0.80, // Cosine similarity threshold for face matching (0.75 is good for face recognition)
          faceScanningStatus: {}, // Track face scanning status per image: {imageKey: 'scanning' | 'scanned' | null}
          faceScanCount: {} // Track number of faces scanned per image: {imageKey: number}
        };
      },
      methods: {
        getFacesButtonText() {
          if (!this.labellingStarted) {
            return 'Start Labelling';
          }
          return this.showFaces ? 'Hide Faces' : 'Show Faces';
        },
        getFacesButtonClass() {
          if (!this.labellingStarted) {
            return 'bg-blue-500 text-white border-blue-600 hover:bg-blue-600';
          }
          return this.showFaces ? 'bg-green-500 text-white border-green-600' : 'bg-gray-200 text-gray-700 border-gray-300 hover:bg-gray-300';
        },
        async handleFacesButtonClick() {
          if (!this.labellingStarted) {
            // Start labelling: show faces and fetch planning centre people
            this.labellingStarted = true;
            this.showFaces = true;
            await this.fetchPlanningCentrePeople();
          } else {
            // Toggle faces visibility
            this.showFaces = !this.showFaces;
          }
        },
        async signIn() {
          try {
            const provider = new firebase.auth.GoogleAuthProvider();
            const result = await auth.signInWithPopup(provider);
            this.user = result.user;
            this.error = null;
            await this.fetchDirectoryTree();
          } catch (error) {
            console.error('Sign in error:', error);
            this.error = 'Sign in failed: ' + error.message;
          }
        },
        async signOut() {
          try {
            await auth.signOut();
            this.user = null;
            this.directoryTree = [];
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedFile = null;
            this.selectedSession = null;
            this.selectedSessionName = '';
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          } catch (error) {
            console.error('Sign out error:', error);
          }
        },
        toggleSidebar() {
          this.sidebarCollapsed = !this.sidebarCollapsed;
          this.bannerVisible = true; // Show banner when interacting with UI
        },
        updateFolderContextFromSelected(node) {
          // Find parent and its file list; then set current index
          const result = this.findParentAndIndexByMediaLink(this.directoryTree, node.url, null);
          if (result && result.parent) {
            const files = result.parent.children.filter(child => child.type === 'file');
            const idx = files.findIndex(f => f.url === node.url);
            this.currentFolderFiles = files;
            this.currentFileIndex = idx;
          } else {
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        findParentAndIndexByMediaLink(nodes, url, parent) {
          if (!nodes) return null;
          for (const n of nodes) {
            if (n.type === 'file' && n.url === url) {
              return { parent, node: n };
            }
            if (n.children && n.children.length) {
              const res = this.findParentAndIndexByMediaLink(n.children, url, n);
              if (res) return res;
            }
          }
          return null;
        },
        async fetchDirectoryTree() {
          if (!this.user) return;
          
          try {
            this.loading = true;
            const idToken = await this.user.getIdToken();
            
            const response = await fetch('https://eshepherd-auth-and-retrieve-files-g7egpip7ea-as.a.run.app', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${idToken}`,
                'Content-Type': 'application/json'
              }
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            if (data.success) {
              this.directoryTree = this.transformToTree(data.items);
              // Auto-select the latest session after loading
              this.$nextTick(() => {
                this.selectLatestSession();
              });
            } else {
              throw new Error(data.error || 'Failed to fetch data');
            }
          } catch (error) {
            console.error('Error fetching directory tree:', error);
            this.error = 'Failed to load images: ' + error.message;
          } finally {
            this.loading = false;
          }
        },
        isUrlExpired(file) {
          if (!file || !file.expiry_unix) return false;
          // Compare expiry_unix (seconds) with current time (seconds)
          const currentTime = Math.floor(Date.now() / 1000);
          return file.expiry_unix <= currentTime;
        },
        async fetchPlanningCentrePeople() {
          if (!this.user) {
            console.error('User not authenticated');
            return;
          }
          
          try {
            this.peopleRetrievalStatus = 'retrieving';
            const idToken = await this.user.getIdToken();
            
            const response = await fetch('https://get-planning-centre-people-g7egpip7ea-as.a.run.app', {
              method: 'GET',
              headers: {
                'Authorization': `Bearer ${idToken}`
              }
            });
            
            if (!response.ok) {
              throw new Error(`Failed to fetch planning centre people: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('Planning centre people response:', data);
            
            // Handle different response structures and extract the records array
            let records = [];
            if (Array.isArray(data)) {
              records = data;
            } else if (data && Array.isArray(data.people)) {
              records = data.people;
            } else if (data && Array.isArray(data.data)) {
              records = data.data;
            } else if (data && typeof data === 'object') {
              // If it's an object, try to find any array property
              const arrayKeys = Object.keys(data).filter(key => Array.isArray(data[key]));
              if (arrayKeys.length > 0) {
                records = data[arrayKeys[0]];
              }
            }
            
            this.planningCentrePeople = records;
            this.peopleRetrievalCount = records.length;
            this.peopleRetrievalStatus = 'completed';
            
            // After loading people, try to match faces in current image
            if (this.selectedFile && this.selectedFile.model) {
              this.$nextTick(() => {
                this.matchFacesInImage(this.selectedFile);
              });
            }
          } catch (error) {
            console.error('Error fetching planning centre people:', error);
            this.peopleRetrievalStatus = 'completed'; // Still mark as completed to show error state
            this.peopleRetrievalCount = 0;
          }
        },
        async refreshUrls() {
          if (!this.user) return false;
          
          try {
            const idToken = await this.user.getIdToken();
            
            const response = await fetch('https://eshepherd-auth-and-retrieve-files-g7egpip7ea-as.a.run.app', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${idToken}`,
                'Content-Type': 'application/json'
              }
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            if (data.success) {
              // Update URLs in the directory tree
              this.updateUrlsInTree(this.directoryTree, data.items);
              return true;
            } else {
              throw new Error(data.error || 'Failed to refresh URLs');
            }
          } catch (error) {
            console.error('Error refreshing URLs:', error);
            return false;
          }
        },
        updateUrlsInTree(tree, items) {
          // Create a map of item names to their new URLs and expiry info
          const urlMap = {};
          items.forEach(item => {
            urlMap[item.name] = {
              url: item.url,
              expiry_timestamp: item.expiry_timestamp,
              expiry_unix: item.expiry_unix,
              model_url: item.model_url
            };
          });
          
          // Recursively update URLs in the tree
          const updateNode = (node) => {
              if (node.type === 'file' && urlMap[node.name]) {
                const newData = urlMap[node.name];
                node.url = newData.url;
                node.expiry_timestamp = newData.expiry_timestamp;
                node.expiry_unix = newData.expiry_unix;
                node.model_url = newData.model_url;
                // Clear cached model when URL changes
                node.model = null;
              }
            if (node.children && Array.isArray(node.children)) {
              node.children.forEach(child => updateNode(child));
            }
          };
          
          tree.forEach(node => updateNode(node));
          
          // Also update currentFolderFiles if they exist
          if (this.currentFolderFiles && this.currentFolderFiles.length > 0) {
            this.currentFolderFiles.forEach(file => {
              if (file.type === 'file' && urlMap[file.name]) {
                const newData = urlMap[file.name];
                file.url = newData.url;
                file.expiry_timestamp = newData.expiry_timestamp;
                file.expiry_unix = newData.expiry_unix;
                file.model_url = newData.model_url;
                // Clear cached model when URL changes
                file.model = null;
              }
            });
          }
        },
        async ensureUrlValid(file) {
          if (!file) return null;
          
          // Check if URL is expired
          if (this.isUrlExpired(file)) {
            console.log('URL expired, refreshing...', file.name);
            // Refresh URLs from the API
            const refreshed = await this.refreshUrls();
            if (refreshed) {
              // Find the updated file in the tree
              const updatedFile = this.findFileByName(this.directoryTree, file.name);
              if (updatedFile) {
                // Update the file object that was passed in
                file.url = updatedFile.url;
                file.expiry_timestamp = updatedFile.expiry_timestamp;
                file.expiry_unix = updatedFile.expiry_unix;
                file.model_url = updatedFile.model_url;
                // Clear cached model when URL changes
                file.model = null;
                return updatedFile.url;
              }
            }
            // If refresh failed, return null
            return null;
          }
          
          return file.url;
        },
        findFileByName(nodes, fileName) {
          for (const node of nodes) {
            if (node.type === 'file' && node.name === fileName) {
              return node;
            }
            if (node.children && node.children.length > 0) {
              const found = this.findFileByName(node.children, fileName);
              if (found) return found;
            }
          }
          return null;
        },
        transformToTree(data) {
          const tree = {};
          data.forEach(item => {
            const parts = item.name.split('/');
            let current = tree;
            parts.forEach((part, index) => {
              if (!current[part]) {
                current[part] = {
                  name: part,
                  children: {},
                  type: index === parts.length - 1 ? item.type : 'directory',
                  url: item.url,
                  expiry_timestamp: item.expiry_timestamp,
                  expiry_unix: item.expiry_unix,
                  model_url: item.model_url,
                  model: null // Will be fetched from model_url when needed
                };
              }
              current = current[part].children;
            });
          });
          const convertToArray = (node, isRootLevel = false) => {
            const children = Object.values(node).map(child => {
              return {
                ...child,
                children: convertToArray(child.children)
              };
            });
            
            // Sort directories first, then files
            return children.sort((a, b) => {
              if (a.type === 'directory' && b.type === 'file') return -1;
              if (a.type === 'file' && b.type === 'directory') return 1;
              
              // For directories, sort by name in descending order (latest first)
              if (a.type === 'directory' && b.type === 'directory') {
                return b.name.localeCompare(a.name);
              }
              
              // For files, sort alphabetically
              return a.name.localeCompare(b.name);
            });
          };
          return convertToArray(tree, true);
        },
        onSessionChange() {
          if (!this.selectedSessionName) return;
          
          // Find the session by name
          const session = this.sessions.find(s => s.name === this.selectedSessionName);
          if (session) {
            this.bannerVisible = true; // Show banner when selecting session
            this.onSelectSession(session);
          }
        },
        getFaceLabelKey(imageName, facialArea) {
          if (!imageName || !facialArea) return null;
          const x = Math.round(facialArea.x || 0);
          const y = Math.round(facialArea.y || 0);
          const w = Math.round(facialArea.w || 0);
          const h = Math.round(facialArea.h || 0);
          return `${imageName}_${x}_${y}_${w}_${h}`;
        },
        async onSelectSession(session) {
          this.selectedSession = session;
          this.selectedSessionName = session.name;
          // Clear labels, checked people, and embeddings stored when session changes
          this.faceLabels = {};
          this.currentSessionLabels = {};
          this.checkedPeople = {};
          this.embeddingsStored = {};
          this.embeddingsCountCache = {};
          this.currentEmbeddingData = null;
          this.embeddingIndex = null; // Reload embeddings for new session
          this.faceMatchCache = {}; // Clear face match cache
          this.faceScanningStatus = {}; // Clear face scanning status
          this.faceScanCount = {}; // Clear face scan count
          // Get all files from this session (recursively)
          const files = this.getAllFilesFromNode(session);
          this.currentFolderFiles = files;
          
          // Select the first image if available
          if (files.length > 0) {
            this.currentFileIndex = 0;
            this.selectedFile = files[0];
            const validUrl = await this.ensureUrlValid(files[0]);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', files[0].name);
            }
            // Fetch model data if model_url exists
            if (files[0].model_url) {
              this.fetchModelData(files[0]);
            }
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          } else {
            this.currentFileIndex = -1;
            this.selectedFile = null;
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        getAllFilesFromNode(node) {
          const files = [];
          if (node.type === 'file') {
            files.push(node);
          } else if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
              files.push(...this.getAllFilesFromNode(child));
            });
          }
          return files;
        },
        getImageTimestamp(file) {
          if (!file || !file.name) return null;
          
          try {
            // Extract the first part before the underscore (hex timestamp)
            const parts = file.name.split('_');
            if (parts.length === 0 || !parts[0]) return null;
            
            const hexTimestamp = parts[0];
            
            // Convert hex to decimal (unix timestamp)
            const unixTimestamp = parseInt(hexTimestamp, 16);
            
            if (isNaN(unixTimestamp)) return null;
            
            // Convert unix timestamp to Date object
            const date = new Date(unixTimestamp * 1000); // Convert seconds to milliseconds
            
            // Format the date/time
            return date.toLocaleString('en-US', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: true
            });
          } catch (error) {
            console.error('Error parsing timestamp from filename:', error);
            return null;
          }
        },
        async fetchModelData(file) {
          if (!file || !file.model_url) return null;
          
          // If model is already cached, return it
          if (file.model !== null && file.model !== undefined) {
            // If model is loaded and we have faces, try to match them
            if (file.model && file.model.embeddings) {
              this.$nextTick(() => {
                this.matchFacesInImage(file);
              });
            }
            return file.model;
          }
          
          try {
            const response = await fetch(file.model_url);
            if (!response.ok) {
              throw new Error(`Failed to fetch model: ${response.status}`);
            }
            const modelData = await response.json();
            // Cache the model data
            file.model = modelData;
            
            // After loading model, match faces
            this.$nextTick(() => {
              this.matchFacesInImage(file);
            });
            
            return modelData;
          } catch (error) {
            console.error('Error fetching model data:', error);
            // Set to empty object to prevent repeated failed fetches
            file.model = {};
            return null;
          }
        },
        // Decode base64 embedding to Float32Array (numpy float32 array equivalent)
        // Python encoding: np.array(embedding, dtype=np.float32).tobytes() -> base64.b64encode().decode('utf-8')
        decodeEmbeddingFromBase64(base64String) {
          if (!base64String || typeof base64String !== 'string') {
            return null;
          }
          
          try {
            // Decode base64 to get the binary bytes (same as Python base64.b64decode)
            const binaryString = atob(base64String);
            
            // Convert binary string to Uint8Array
            // This represents the raw bytes from numpy array.tobytes()
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            
            // Check if length is valid for Float32Array (must be multiple of 4 bytes)
            // Each float32 is 4 bytes
            if (bytes.length % 4 !== 0) {
              console.error('Invalid embedding length:', bytes.length, 'must be multiple of 4 bytes for Float32Array');
              return null;
            }
            
            if (bytes.length === 0) {
              console.error('Empty embedding data');
              return null;
            }
            
            // Convert bytes to Float32Array
            // Float32Array automatically handles byte order (little-endian by default, same as numpy)
            // This recreates the numpy float32 array from the binary bytes
            const float32Array = new Float32Array(bytes.buffer);
            
            // Convert to regular JavaScript array for compatibility with vector search library
            const result = Array.from(float32Array);
            
            // Validate the result
            if (result.length === 0) {
              console.error('Decoded embedding array is empty');
              return null;
            }
            
            // Verify all values are valid numbers (should be float32 values)
            if (!result.every(v => typeof v === 'number' && !isNaN(v) && isFinite(v))) {
              console.error('Decoded embedding contains invalid numbers');
              return null;
            }
            
            return result;
          } catch (error) {
            console.error('Error decoding base64 embedding to Float32Array:', error.message, 'base64 preview:', base64String.substring(0, 50));
            return null;
          }
        },
        // Reload embeddings index from Firebase
        async reloadEmbeddingsIndex() {
          // Clear current index and cache
          this.embeddingIndex = null;
          this.faceMatchCache = {};
          this.faceScanningStatus = {};
          this.faceScanCount = {};
          
          // Reload embeddings (force reload)
          await this.loadAllStoredEmbeddings(true);
          
          // Rescan faces in current image if available
          if (this.selectedFile && this.selectedFile.model) {
            this.$nextTick(() => {
              this.matchFacesInImage(this.selectedFile);
            });
          }
        },
        // Load all embeddings from Firebase and create EmbeddingIndex
        async loadAllStoredEmbeddings(forceReload = false) {
          if (this.embeddingIndex !== null && !forceReload) {
            // Already loaded
            return;
          }
          
          try {
            // Dynamically import client-vector-search from esm.sh
            if (!this.ClientVectorSearchModule) {
              this.ClientVectorSearchModule = await import('https://esm.run/client-vector-search');
            }
            
            const { EmbeddingIndex } = this.ClientVectorSearchModule;
            
            if (!EmbeddingIndex) {
              console.error('EmbeddingIndex not found in client-vector-search module');
              return;
            }
            
            const embeddingsRef = database.ref('eshepherd/embeddings');
            const snapshot = await embeddingsRef.once('value');
            const allEmbeddings = snapshot.val();
            
            if (!allEmbeddings) {
              // Create empty index
              this.embeddingIndex = new EmbeddingIndex([]);
              return;
            }
            
            // Process all embeddings: {personId: {index: base64String}}
            const indexObjects = [];
            for (const personId in allEmbeddings) {
              const personEmbeddings = allEmbeddings[personId];
              
              for (const index in personEmbeddings) {
                const base64Embedding = personEmbeddings[index];
                const embeddingArray = this.decodeEmbeddingFromBase64(base64Embedding);
                
                if (embeddingArray && Array.isArray(embeddingArray)) {
                  indexObjects.push({
                    id: `${personId}_${index}`,
                    personId: personId,
                    embedding: embeddingArray
                  });
                }
              }
            }
            
            // Create EmbeddingIndex
            this.embeddingIndex = new EmbeddingIndex(indexObjects);
            
            console.log(`Loaded all stored embeddings: ${indexObjects.length} embeddings from ${Object.keys(allEmbeddings).length} people`);
          } catch (error) {
            console.error('Error loading all stored embeddings:', error);
            this.embeddingIndex = null;
          }
        },
        // Load top 5 matches for face guesses
        async loadFaceGuesses() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.model) {
            this.faceGuesses = [];
            return;
          }
          
          try {
            // Load embedding data for the selected bounding box
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.faceGuesses = [];
              return;
            }
            
            const embedding = model.embeddings[this.selectedBoundingBoxIndex];
            if (!embedding || !embedding.embedding || !embedding.facial_area) {
              this.faceGuesses = [];
              return;
            }
            
            // Decode embedding if it's base64 encoded
            let embeddingArray = embedding.embedding;
            if (typeof embeddingArray === 'string') {
              embeddingArray = this.decodeEmbeddingFromBase64(embeddingArray);
              if (!embeddingArray) {
                this.faceGuesses = [];
                return;
              }
            }
            
            // Ensure embeddingArray is a flat array of numbers
            if (!Array.isArray(embeddingArray)) {
              this.faceGuesses = [];
              return;
            }
            
            embeddingArray = embeddingArray.flat(Infinity);
            
            // Validate all elements are numbers
            if (!embeddingArray.every(v => typeof v === 'number' && !isNaN(v) && isFinite(v))) {
              this.faceGuesses = [];
              return;
            }
            
            // Load all stored embeddings if not already loaded
            await this.loadAllStoredEmbeddings();
            
            if (!this.embeddingIndex) {
              this.faceGuesses = [];
              return;
            }
            
            // Search for top 5 matches
            const results = await this.embeddingIndex.search(embeddingArray, { topK: 5 });
            
            if (!results || results.length === 0) {
              this.faceGuesses = [];
              return;
            }
            
            // Process results and match with planningCentrePeople
            // Use a Map to deduplicate by personId, keeping only the highest similarity
            const guessesMap = new Map();
            
            for (const result of results) {
              let similarity = result.similarity || result.score || 0;
              
              // If distance is provided instead, convert to similarity
              if (result.distance !== undefined && similarity === 0) {
                similarity = 1 - result.distance;
              }
              
              // Extract personId
              let personId = null;
              if (result.personId) {
                personId = result.personId;
              } else if (result.id) {
                personId = result.id.split('_')[0];
              } else if (result.object && result.object.personId) {
                personId = result.object.personId;
              } else if (result.item && result.item.personId) {
                personId = result.item.personId;
              }
              
              if (personId) {
                // Find person in planningCentrePeople
                const person = this.planningCentrePeople.find(p => p.id === personId);
                if (person) {
                  // Check if we already have this person, keep the one with higher similarity
                  const existing = guessesMap.get(personId);
                  if (!existing || similarity > existing.similarity) {
                    guessesMap.set(personId, {
                      person: person,
                      similarity: similarity
                    });
                  }
                }
              }
            }
            
            // Convert Map to array and sort by similarity (descending)
            const guesses = Array.from(guessesMap.values())
              .sort((a, b) => b.similarity - a.similarity)
              .slice(0, 5); // Take top 5 after deduplication
            
            this.faceGuesses = guesses;
          } catch (error) {
            console.error('Error loading face guesses:', error);
            this.faceGuesses = [];
          }
        },
        // Find best match for an embedding using client-vector-search
        async findBestMatch(queryEmbedding) {
          if (!queryEmbedding) {
            console.error('findBestMatch: queryEmbedding is null or undefined');
            return null;
          }
          
          if (!Array.isArray(queryEmbedding)) {
            console.error('findBestMatch: queryEmbedding is not an array. Type:', typeof queryEmbedding, 'Value:', queryEmbedding);
            return null;
          }
          
          if (queryEmbedding.length === 0) {
            console.error('findBestMatch: queryEmbedding is an empty array');
            return null;
          }
          
          if (!this.embeddingIndex) {
            console.error('findBestMatch: embeddingIndex is null. Has it been initialized?');
            return null;
          }
          
          try {
            // Search for top match
            const results = await this.embeddingIndex.search(queryEmbedding, { topK: 1 });
            
            if (results && results.length > 0) {
              const bestResult = results[0];
              
              // Debug: log the result structure
              console.log('Search result:', bestResult);
              
              // Check if similarity is above threshold
              // client-vector-search returns similarity scores (typically 0-1 for cosine similarity)
              // The result might have similarity, score, or distance (inverted)
              let similarity = bestResult.similarity || bestResult.score || 0;
              
              // If distance is provided instead, convert to similarity (assuming cosine distance)
              if (bestResult.distance !== undefined && similarity === 0) {
                similarity = 1 - bestResult.distance; // Convert distance to similarity
              }
              
              // Extract personId from the result
              // The library should return the original object we passed in
              let personId = null;
              
              // Try different ways to get personId
              if (bestResult.personId) {
                personId = bestResult.personId;
              } else if (bestResult.id) {
                // Extract from id format: "personId_index"
                personId = bestResult.id.split('_')[0];
              } else if (bestResult.object && bestResult.object.personId) {
                personId = bestResult.object.personId;
              } else if (bestResult.item && bestResult.item.personId) {
                personId = bestResult.item.personId;
              }
              
              console.log('Extracted personId:', personId, 'similarity:', similarity);
              
              if (similarity >= this.SIMILARITY_THRESHOLD && personId) {
                return {
                  personId: personId,
                  similarity: similarity,
                  embedding: bestResult.embedding || bestResult.object?.embedding || bestResult.item?.embedding
                };
              } else {
                console.log(`Match below threshold: similarity=${similarity}, threshold=${this.SIMILARITY_THRESHOLD}, personId=${personId}`);
              }
            }
            
            return null;
          } catch (error) {
            console.error('Error finding best match:', error);
            return null;
          }
        },
        // Match all faces in an image
        async matchFacesInImage(file) {
          if (!file || !file.model || !file.name) {
            return;
          }
          
          // Only scan faces when planningCentrePeople data is fully loaded
          if (this.peopleRetrievalStatus !== 'completed' || !this.planningCentrePeople || this.planningCentrePeople.length === 0) {
            console.log('Skipping face scan: planningCentrePeople not loaded yet');
            return;
          }
          
          const imageKey = file.name;
          
          // Check cache first
          if (this.faceMatchCache[imageKey]) {
            // Apply cached matches
            this.applyFaceMatches(file, this.faceMatchCache[imageKey]);
            // Set status to scanned since we already have cached results
            this.faceScanningStatus[imageKey] = 'scanned';
            // Get face count from model if not cached
            if (!this.faceScanCount[imageKey]) {
              try {
                const model = typeof file.model === 'string' 
                  ? JSON.parse(file.model) 
                  : file.model;
                if (model.embeddings && Array.isArray(model.embeddings)) {
                  this.faceScanCount[imageKey] = model.embeddings.filter(e => e && e.embedding && e.facial_area).length;
                }
              } catch (e) {
                this.faceScanCount[imageKey] = Object.keys(this.faceMatchCache[imageKey]).length;
              }
            }
            this.$forceUpdate();
            return;
          }
          
          try {
            // Set scanning status
            this.faceScanningStatus[imageKey] = 'scanning';
            this.$forceUpdate();
            
            const model = typeof file.model === 'string' 
              ? JSON.parse(file.model) 
              : file.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.faceScanningStatus[imageKey] = 'scanned';
              this.$forceUpdate();
              return;
            }
            
            // Load all stored embeddings if not already loaded
            await this.loadAllStoredEmbeddings();
            
            // Get person records for matching
            const matches = {};
            let faceCount = 0;
            
            // Match each face embedding
            for (let i = 0; i < model.embeddings.length; i++) {
              const embedding = model.embeddings[i];
              
              if (embedding && embedding.embedding && embedding.facial_area) {
                faceCount++;
                
                // Decode embedding if it's base64 encoded
                let embeddingArray = embedding.embedding;
                if (typeof embeddingArray === 'string') {
                  // Try to decode from base64
                  embeddingArray = this.decodeEmbeddingFromBase64(embeddingArray);
                  if (!embeddingArray) {
                    console.warn(`Face ${i}: Could not decode embedding from base64`);
                    continue;
                  }
                }
                
                const bestMatch = await this.findBestMatch(embeddingArray);
                
                if (bestMatch) {
                  console.log('Found match:', bestMatch);
                  // Find person record from planningCentrePeople
                  const person = this.planningCentrePeople.find(p => p.id === bestMatch.personId);
                  
                  if (person) {
                    matches[i] = {
                      personId: bestMatch.personId,
                      similarity: bestMatch.similarity,
                      person: person
                    };
                    console.log(`Matched face ${i} to person ${person.name} (ID: ${person.id}, similarity: ${bestMatch.similarity})`);
                  } else {
                    console.warn(`Person with ID ${bestMatch.personId} not found in planningCentrePeople`);
                  }
                } else {
                  console.log(`No match found for face ${i} (below threshold or no match)`);
                }
              }
            }
            
            // Store face count
            this.faceScanCount[imageKey] = faceCount;
            
            // Cache the matches
            this.faceMatchCache[imageKey] = matches;
            
            // Apply the matches
            this.applyFaceMatches(file, matches);
            
            // Set status to scanned
            this.faceScanningStatus[imageKey] = 'scanned';
            this.$forceUpdate();
            
          } catch (error) {
            console.error('Error matching faces in image:', error);
            this.faceScanningStatus[imageKey] = 'scanned'; // Set to scanned even on error
            this.$forceUpdate();
          }
        },
        // Get face scanning status for current image
        getFaceScanningStatus() {
          if (!this.selectedFile || !this.selectedFile.name) {
            return null;
          }
          return this.faceScanningStatus[this.selectedFile.name] || null;
        },
        // Get face scan count for current image
        getFaceScanCount() {
          if (!this.selectedFile || !this.selectedFile.name) {
            return 0;
          }
          return this.faceScanCount[this.selectedFile.name] || 0;
        },
        // Apply face matches to labels
        applyFaceMatches(file, matches) {
          if (!file || !matches || Object.keys(matches).length === 0) {
            return;
          }
          
          try {
            const model = typeof file.model === 'string' 
              ? JSON.parse(file.model) 
              : file.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return;
            }
            
            // Apply each match
            for (const embeddingIndexStr in matches) {
              const embeddingIndex = parseInt(embeddingIndexStr);
              const match = matches[embeddingIndex];
              
              if (match && match.person && model.embeddings[embeddingIndex]) {
                const embedding = model.embeddings[embeddingIndex];
                const facialArea = embedding.facial_area;
                
                if (facialArea) {
                  const key = this.getFaceLabelKey(file.name, facialArea);
                  
                  if (key) {
                    // Set the label
                    this.faceLabels[key] = match.person;
                    this.currentSessionLabels[key] = match.person;
                    
                    // Mark person as checked
                    if (match.person.id) {
                      this.checkedPeople[match.person.id] = true;
                    }
                    
                    console.log(`Matched face ${embeddingIndex} to ${match.person.name} (similarity: ${match.similarity.toFixed(3)})`);
                  }
                }
              }
            }
            
            // Force update to refresh UI
            this.$forceUpdate();
          } catch (error) {
            console.error('Error applying face matches:', error);
          }
        },
        formatModel(model) {
          if (!model) return '';
          
          try {
            // If model is already a string, try to parse it as JSON
            if (typeof model === 'string') {
              const parsed = JSON.parse(model);
              return JSON.stringify(parsed, null, 2);
            }
            // If model is an object, stringify it with formatting
            return JSON.stringify(model, null, 2);
          } catch (error) {
            // If parsing fails, return as string
            return typeof model === 'string' ? model : String(model);
          }
        },
        selectLatestSession() {
          // Select the latest session (first one in the sorted list, since we sort latest to earliest)
          if (this.sessions.length > 0) {
            const latestSession = this.sessions[0];
            this.onSelectSession(latestSession);
          }
        },
        async onSelectNode(node) {
          if (node.type === 'file') {
            this.selectedFile = node;
            const validUrl = await this.ensureUrlValid(node);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', node.name);
            }
            // Fetch model data if model_url exists
            if (node.model_url) {
              this.fetchModelData(node);
            }
            this.updateFolderContextFromSelected(node);
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        async goPrevImage() {
          if (this.currentFileIndex > 0) {
            const newIndex = this.currentFileIndex - 1;
            const nextFile = this.currentFolderFiles[newIndex];
            if (nextFile) {
              this.selectedFile = nextFile;
              const validUrl = await this.ensureUrlValid(nextFile);
              this.selectedImage = validUrl;
              if (!validUrl) {
                console.error('Failed to get valid URL for file:', nextFile.name);
              }
              // Fetch model data if model_url exists
              if (nextFile.model_url) {
                this.fetchModelData(nextFile);
              }
              this.currentFileIndex = newIndex;
              // Clear selected bounding box when switching images (but keep labels)
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              // Don't clear faceLabels - they persist per session
            }
          }
        },
        async goNextImage() {
          if (this.currentFileIndex >= 0 && this.currentFileIndex < this.currentFolderFiles.length - 1) {
            const newIndex = this.currentFileIndex + 1;
            const nextFile = this.currentFolderFiles[newIndex];
            if (nextFile) {
              this.selectedFile = nextFile;
              const validUrl = await this.ensureUrlValid(nextFile);
              this.selectedImage = validUrl;
              if (!validUrl) {
                console.error('Failed to get valid URL for file:', nextFile.name);
              }
              // Fetch model data if model_url exists
              if (nextFile.model_url) {
                this.fetchModelData(nextFile);
              }
              this.currentFileIndex = newIndex;
              // Clear selected bounding box when switching images (but keep labels)
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              // Don't clear faceLabels - they persist per session
            }
          }
        },
        onUpdateAnnotations(newAnnotations) {
          this.annotations = newAnnotations;
        },
        onFaceBoxClick(embeddingIndex) {
          // Toggle selection - if clicking the same box, deselect it
          if (this.selectedBoundingBoxIndex === embeddingIndex) {
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.faceGuesses = [];
            this.selectedPersonChecked = true;
            this.householdCheckboxes = {};
          } else {
            this.selectedBoundingBoxIndex = embeddingIndex;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.faceGuesses = []; // Clear previous guesses
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
              
              // Reset stored state first
              const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
              if (facialArea) {
                const resetKey = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                if (resetKey) {
                  this.embeddingsStored[resetKey] = false;
                }
              }
              
              // Set loading state
              this.checkingEmbeddingInDB = true;
              this.$forceUpdate();
              
              // Load embedding data and check if it exists in DB
              this.loadEmbeddingData();
              this.getEmbeddingsCount(); // Load count (async, but don't wait)
              this.checkEmbeddingInDB(); // Check DB (async, but don't wait)
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              this.currentEmbeddingData = null;
              
              // Load top 5 matches for guesses
              this.loadFaceGuesses();
            }
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          }
        },
        performSearch() {
          // Clear face guesses when user starts typing
          this.faceGuesses = [];
          
          if (!this.searchQuery || this.searchQuery.trim() === '') {
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.searchResultRefs = {};
            return;
          }
          
          const query = this.searchQuery.toLowerCase().trim();
          const results = this.planningCentrePeople
            .filter(person => person.name && person.name.toLowerCase().includes(query))
            .slice(0, 15); // Up to 15 results (show 5 initially, scroll for more)
          
          this.searchResults = results;
          // Reset selected index when search results change
          this.selectedSearchIndex = results.length > 0 ? 0 : -1;
          // Clear refs - they will be recreated by Vue
          this.$nextTick(() => {
            this.scrollToSelectedResult();
          });
        },
        getHouseholdMembers(person) {
          if (!person || !person.household_ids || !Array.isArray(person.household_ids) || person.household_ids.length === 0) {
            return [];
          }
          
          // Find all people who share the same household_ids
          const householdMembers = this.planningCentrePeople.filter(p => {
            if (!p.household_ids || !Array.isArray(p.household_ids)) return false;
            // Check if they share any household_ids
            return p.id !== person.id && p.household_ids.some(hid => person.household_ids.includes(hid));
          });
          
          return householdMembers;
        },
        getHouseholdGroups(person) {
          if (!person || !person.household_ids || !Array.isArray(person.household_ids) || person.household_ids.length === 0) {
            return [];
          }
          
          // Group people by each household_id
          const groups = person.household_ids.map(householdId => {
            // Find all people who share this specific household_id, excluding the selected person
            const members = this.planningCentrePeople.filter(p => {
              if (!p.household_ids || !Array.isArray(p.household_ids)) return false;
              // Exclude the selected person from household members
              return p.id !== person.id && p.household_ids.includes(householdId);
            });
            
            return {
              householdId: householdId,
              members: members
            };
          });
          
          return groups;
        },
        getHouseholdMembersDisplay(person) {
          const members = this.getHouseholdMembers(person);
          if (members.length === 0) return '';
          
          // Get names of household members
          const names = members.map(m => m.name).filter(name => name);
          
          // Truncate if too long (roughly estimate based on character count)
          const maxLength = 50; // Approximate max characters to fit in dropdown
          let display = names.join(', ');
          
          if (display.length > maxLength) {
            // Truncate and add ellipsis
            let truncated = '';
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              const separator = truncated ? ', ' : '';
              if ((truncated + separator + name).length > maxLength - 3) {
                // Leave room for '...'
                truncated += '...';
                break;
              }
              truncated += separator + name;
            }
            display = truncated;
          }
          
          return display;
        },
        handleSearchKeydown(event) {
          if (this.searchResults.length === 0) {
            return; // Don't handle keys if there are no results
          }
          
          switch(event.key) {
            case 'ArrowDown':
              event.preventDefault();
              this.selectedSearchIndex = (this.selectedSearchIndex + 1) % this.searchResults.length;
              this.scrollToSelectedResult();
              break;
            case 'ArrowUp':
              event.preventDefault();
              if (this.selectedSearchIndex <= 0) {
                this.selectedSearchIndex = this.searchResults.length - 1;
              } else {
                this.selectedSearchIndex = this.selectedSearchIndex - 1;
              }
              this.scrollToSelectedResult();
              break;
            case 'Enter':
              event.preventDefault();
              if (this.selectedSearchIndex >= 0 && this.selectedSearchIndex < this.searchResults.length) {
                this.selectPerson(this.searchResults[this.selectedSearchIndex]);
              }
              break;
            case 'Escape':
              event.preventDefault();
              this.selectedSearchIndex = -1;
              break;
          }
        },
        scrollToSelectedResult() {
          // Use $nextTick to ensure DOM is updated before scrolling
          this.$nextTick(() => {
            if (this.selectedSearchIndex >= 0 && this.searchResultRefs[this.selectedSearchIndex]) {
              const selectedElement = this.searchResultRefs[this.selectedSearchIndex];
              const container = this.$refs.searchResultsContainer;
              
              if (container && selectedElement) {
                const containerRect = container.getBoundingClientRect();
                const elementRect = selectedElement.getBoundingClientRect();
                
                // Check if element is outside visible area
                if (elementRect.top < containerRect.top) {
                  // Element is above visible area, scroll up
                  selectedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else if (elementRect.bottom > containerRect.bottom) {
                  // Element is below visible area, scroll down
                  selectedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
              }
            }
          });
        },
        async selectPerson(person) {
          // Clear face guesses when a person is selected
          this.faceGuesses = [];
          
          if (this.selectedBoundingBoxIndex !== null && this.selectedFile) {
            // Get the facial area for the selected embedding index
            const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
            if (facialArea) {
              const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
              if (key) {
                this.faceLabels[key] = person;
                this.currentSessionLabels[key] = person;
                // Mark selected person as checked in global list
                if (person.id) {
                  this.checkedPeople[person.id] = true;
                }
                // Initialize checkbox states from global list
                this.selectedPersonChecked = this.isPersonChecked(person.id);
                this.initializeHouseholdCheckboxes(person);
                
                // Reset stored state first
                const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
                if (facialArea) {
                  const resetKey = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                  if (resetKey) {
                    this.embeddingsStored[resetKey] = false;
                  }
                }
                
                // Set loading state
                this.checkingEmbeddingInDB = true;
                this.$forceUpdate();
                
                // Load current embedding data and check if it exists in DB
                this.loadEmbeddingData();
                await this.getEmbeddingsCount(); // Load count first
                await this.checkEmbeddingInDB(); // This will set checkingEmbeddingInDB to false when done
              }
            }
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          }
        },
        initializeHouseholdCheckboxes(person) {
          // Initialize household checkboxes from global checked list
          this.householdCheckboxes = {};
          const groups = this.getHouseholdGroups(person);
          groups.forEach(group => {
            group.members.forEach(member => {
              if (member.id) {
                // Check global list for checked state
                this.householdCheckboxes[member.id] = this.isPersonChecked(member.id);
              }
            });
          });
        },
        isPersonChecked(personId) {
          // Check if person is checked in global list
          return personId ? (this.checkedPeople[personId] || false) : false;
        },
        handleSelectedPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentFaceLabel();
          if (currentLabel && currentLabel.id) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update global checked list
            this.checkedPeople[currentLabel.id] = checked;
            
            if (!checked) {
              // Uncheck all household checkboxes in global list
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.checkedPeople[member.id] = false;
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
            } else {
              // When re-checking, restore household checkbox states from global list
              this.initializeHouseholdCheckboxes(currentLabel);
            }
          }
        },
        handleHouseholdCheckboxChange(memberId, event) {
          if (memberId) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update global checked list
            this.checkedPeople[memberId] = checked;
          }
        },
        getHouseholdCheckboxState(memberId) {
          // Check global list first, then local state
          if (memberId && this.checkedPeople.hasOwnProperty(memberId)) {
            return this.checkedPeople[memberId];
          }
          return this.householdCheckboxes[memberId] || false;
        },
        getSelectedPersonCheckedState() {
          const currentLabel = this.getCurrentFaceLabel();
          if (currentLabel && currentLabel.id) {
            // Check global list for selected person's checked state
            return this.isPersonChecked(currentLabel.id);
          }
          // Fallback to local state if no label
          return this.selectedPersonChecked;
        },
        getEmbeddingsCountDisplay() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          return this.embeddingsCountCache[currentLabel.id] || 0;
        },
        getMatchDisplayText() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) {
            return '0 Embeddings in DB';
          }
          
          const embeddingsCount = this.embeddingsCountCache[currentLabel.id] || 0;
          
          // Check if there's a match for the current bounding box
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.name) {
            return `${embeddingsCount} Embeddings in DB`;
          }
          
          const imageKey = this.selectedFile.name;
          const matchCache = this.faceMatchCache[imageKey];
          
          if (!matchCache || !matchCache[this.selectedBoundingBoxIndex]) {
            // No match found for this face
            return `No Match. ${embeddingsCount} Embeddings in DB`;
          }
          
          const match = matchCache[this.selectedBoundingBoxIndex];
          
          // Check if the selected person matches the top match
          if (match.personId === currentLabel.id) {
            // Selected person is the top match - show match percentage
            const matchPercentage = (match.similarity * 100).toFixed(1);
            return `${matchPercentage}% Match. ${embeddingsCount} Embeddings in DB`;
          } else {
            // Selected person is not the top match
            return `No Match. ${embeddingsCount} Embeddings in DB`;
          }
        },
        async getEmbeddingsCount() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          
          // Check cache first
          if (this.embeddingsCountCache[currentLabel.id] !== undefined) {
            return this.embeddingsCountCache[currentLabel.id];
          }
          
          // Fetch from Firebase
          try {
            const embeddingsRef = database.ref(`eshepherd/embeddings/${currentLabel.id}`);
            const snapshot = await embeddingsRef.once('value');
            const embeddings = snapshot.val();
            const count = embeddings ? Object.keys(embeddings).length : 0;
            this.embeddingsCountCache[currentLabel.id] = count;
            // Force update to refresh UI
            this.$forceUpdate();
            return count;
          } catch (error) {
            console.error('Error fetching embeddings count:', error);
            return 0;
          }
        },
        getEmbeddingsStoredState() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return false;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return false;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          return key ? (this.embeddingsStored[key] || false) : false;
        },
        loadEmbeddingData() {
          // Load the embedding data for the current bounding box
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.model) {
            this.currentEmbeddingData = null;
            return;
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.currentEmbeddingData = null;
              return;
            }
            
            const embedding = model.embeddings[this.selectedBoundingBoxIndex];
            if (embedding && embedding.embedding) {
              this.currentEmbeddingData = embedding.embedding;
            } else {
              this.currentEmbeddingData = null;
            }
          } catch (error) {
            console.error('Error loading embedding data:', error);
            this.currentEmbeddingData = null;
          }
        },
        async checkEmbeddingInDB() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Get the key for this bounding box
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (!key) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Set loading state
          this.checkingEmbeddingInDB = true;
          this.$forceUpdate();
          
          // If no embedding data, mark as not stored
          if (!this.currentEmbeddingData) {
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
            return;
          }
          
          try {
            const embeddingsRef = database.ref(`eshepherd/embeddings/${currentLabel.id}`);
            const snapshot = await embeddingsRef.once('value');
            const embeddings = snapshot.val();
            
            // Update count cache
            const count = embeddings ? Object.keys(embeddings).length : 0;
            this.embeddingsCountCache[currentLabel.id] = count;
            
            if (!embeddings || count === 0) {
              // No embeddings in DB, mark as not stored
              this.embeddingsStored[key] = false;
              this.checkingEmbeddingInDB = false;
              this.$forceUpdate();
              return;
            }
            
            // currentEmbeddingData is already a base64 string, use it directly
            // Check if current embedding exists in DB
            const embeddingValues = Object.values(embeddings);
            const exists = embeddingValues.some(storedEmbedding => storedEmbedding === this.currentEmbeddingData);
            
            // Update stored state
            this.embeddingsStored[key] = exists;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          } catch (error) {
            console.error('Error checking embedding in DB:', error);
            // On error, mark as not stored
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          }
        },
        encodeEmbeddingToBase64(embedding) {
          // Convert embedding array to base64 string
          if (Array.isArray(embedding)) {
            // Convert array to JSON string, then to base64
            const jsonString = JSON.stringify(embedding);
            return btoa(jsonString);
          } else if (typeof embedding === 'string') {
            // Already a string, encode to base64
            return btoa(embedding);
          }
          // If it's already base64 or other format, return as is
          return embedding;
        },
        async handleStoreEmbeddings() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id || !this.currentEmbeddingData || !this.user) {
            return;
          }
          
          try {
            // currentEmbeddingData is already a base64 string, store it directly
            // Get reference to embeddings for this person
            const embeddingsRef = database.ref(`eshepherd/embeddings/${currentLabel.id}`);
            
            // Get current embeddings to find next index
            const snapshot = await embeddingsRef.once('value');
            const embeddings = snapshot.val() || {};
            
            // Find next available index
            const existingIndices = Object.keys(embeddings).map(k => parseInt(k)).filter(n => !isNaN(n));
            const nextIndex = existingIndices.length > 0 ? Math.max(...existingIndices) + 1 : 0;
            
            // Store the embedding (already base64)
            await database.ref(`eshepherd/embeddings/${currentLabel.id}/${nextIndex}`).set(this.currentEmbeddingData);
            
            // Update stored state
            const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
            if (facialArea) {
              const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
              if (key) {
                this.embeddingsStored[key] = true;
              }
            }
            
            // Update count cache
            this.embeddingsCountCache[currentLabel.id] = Object.keys(embeddings).length + 1;
            
            // Force update to refresh UI
            this.$forceUpdate();
          } catch (error) {
            console.error('Error storing embedding:', error);
            alert('Failed to store embedding: ' + error.message);
          }
        },
        getFacialAreaForIndex(embeddingIndex) {
          if (!this.selectedFile || !this.selectedFile.model) return null;
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return null;
            }
            
            const embedding = model.embeddings[embeddingIndex];
            return embedding && embedding.facial_area ? embedding.facial_area : null;
          } catch (error) {
            console.error('Error getting facial area:', error);
            return null;
          }
        },
        getCurrentFaceLabel() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return null;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return null;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          return key ? this.faceLabels[key] || null : null;
        },
        clearCurrentFaceLabel() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (key) {
            delete this.faceLabels[key];
            delete this.currentSessionLabels[key];
            // Clear selection
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          }
        },
        setupKeyboardNavigation() {
          document.addEventListener('keydown', this.handleKeydown);
        },
        handleKeydown(event) {
          // Only handle arrow keys when user is logged in and not loading
          if (!this.user || this.loading) return;
          
          // Handle ESC key to deselect bounding box (works even in input fields)
          if (event.key === 'Escape' && this.selectedBoundingBoxIndex !== null) {
            event.preventDefault();
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.selectedPersonChecked = true;
            this.householdCheckboxes = {};
            return;
          }
          
          // Handle 'Tab' key to go to next bounding box (works even in input fields when box is selected)
          if (event.key === 'Tab' && this.selectedBoundingBoxIndex !== null && this.showFaces && this.selectedFile && this.selectedFile.model) {
            event.preventDefault();
            this.goToNextBoundingBox();
            return;
          }
          
          // Handle 'a' key to add embedding (only when person is selected and button is enabled)
          if (event.key === 'a' || event.key === 'A') {
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel && currentLabel.id && this.currentEmbeddingData && this.user && 
                !this.checkingEmbeddingInDB && !this.getEmbeddingsStoredState()) {
              event.preventDefault();
              this.handleStoreEmbeddings();
              return;
            }
          }
          
          // Don't handle if user is typing in an input field or textarea (except ESC, Tab, and 'a')
          if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            // ESC, Tab, and 'a' keys are handled above, but for other keys, return early
            // Allow arrow keys in search input to be handled by handleSearchKeydown
            return;
          }
          
          switch(event.key) {
            case 'ArrowLeft':
              event.preventDefault();
              if (this.hasPrevImage) {
                this.goPrevImage();
              }
              break;
            case 'ArrowRight':
              event.preventDefault();
              if (this.hasNextImage) {
                this.goNextImage();
              }
              break;
          }
        },
        goToNextBoundingBox() {
          if (!this.selectedFile || !this.selectedFile.model) return;
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return;
            }
            
            // Get all embedding indices that have facial areas
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => embedding.facial_area);
            
            if (embeddingsWithFaces.length === 0) return;
            
            // Find current index in the list
            const currentIndex = embeddingsWithFaces.findIndex(
              ({ index }) => index === this.selectedBoundingBoxIndex
            );
            
            if (currentIndex === -1) {
              // Current selection not found, select first one
              this.selectedBoundingBoxIndex = embeddingsWithFaces[0].index;
            } else {
              // Go to next, wrap around if at end
              const nextIndex = (currentIndex + 1) % embeddingsWithFaces.length;
              this.selectedBoundingBoxIndex = embeddingsWithFaces[nextIndex].index;
            }
            
            // Reset search and focus input
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          } catch (error) {
            console.error('Error navigating to next bounding box:', error);
          }
        },
        handleTouchStart(event) {
          // Only handle touches when user is logged in, not loading, and an image is selected
          if (!this.user || this.loading || !this.selectedImage) return;
          
          // Get the first touch point
          const touch = event.touches[0];
          this.touchStartX = touch.clientX;
          this.touchStartY = touch.clientY;
          this.isSwipe = false; // Reset swipe flag
        },
        handleTouchEnd(event) {
          // Only handle if we have a start position
          if (this.touchStartX === null || this.touchStartY === null) return;
          if (!this.user || this.loading || !this.selectedImage) {
            this.touchStartX = null;
            this.touchStartY = null;
            return;
          }
          
          // Get the end touch point
          const touch = event.changedTouches[0];
          const touchEndX = touch.clientX;
          const touchEndY = touch.clientY;
          
          // Calculate the difference
          const deltaX = touchEndX - this.touchStartX;
          const deltaY = touchEndY - this.touchStartY;
          
          // Minimum swipe distance (in pixels)
          const minSwipeDistance = 50;
          
          // Check if it's a horizontal swipe (more horizontal than vertical)
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
            // Prevent default to avoid any unwanted behavior
            event.preventDefault();
            this.isSwipe = true;
            
            // Hide banner on swipe
            this.bannerVisible = false;
            
            if (deltaX > 0) {
              // Swipe right - go to previous image
              if (this.hasPrevImage) {
                this.goPrevImage();
              }
            } else {
              // Swipe left - go to next image
              if (this.hasNextImage) {
                this.goNextImage();
              }
            }
          } else {
            // It's a tap (not a swipe) - show banner
            if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
              // Very small movement, treat as tap
              this.bannerVisible = !this.bannerVisible;
            }
          }
          
          // Reset touch positions
          this.touchStartX = null;
          this.touchStartY = null;
        }
      },
      computed: {
        sessions() {
          // Return only root-level directories (sessions), sorted from latest to earliest
          const dirs = this.directoryTree.filter(node => node.type === 'directory');
          // Sort from latest to earliest (descending order)
          const sorted = Array.from(dirs);
          sorted.sort((a, b) => {
            // Try to parse as dates if they look like dates, otherwise use string comparison
            const dateA = new Date(a.name);
            const dateB = new Date(b.name);
            
            // If both are valid dates, compare as dates
            if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
              return dateB - dateA; // Descending: later dates first
            }
            
            // Otherwise use string comparison (descending)
            return b.name.localeCompare(a.name);
          });
          return sorted;
        },
        hasPrevImage() {
          return this.currentFileIndex > 0;
        },
        hasNextImage() {
          return this.currentFileIndex >= 0 && this.currentFileIndex < this.currentFolderFiles.length - 1;
        }
      },
      mounted() {
        // Auto-scroll down 1px to trigger URL bar hiding on mobile
        setTimeout(() => {
          window.scrollTo(0, 1);
          // Scroll back to top after a moment (URL bar will stay hidden)
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 100);
        }, 100);
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
          // Re-trigger scroll to hide URL bar after orientation change
          setTimeout(() => {
            window.scrollTo(0, 1);
            setTimeout(() => {
              window.scrollTo(0, 0);
            }, 100);
            // Force resize event
            window.dispatchEvent(new Event('resize'));
          }, 300);
        });
        
        // Listen for authentication state changes
        auth.onAuthStateChanged((user) => {
          this.user = user;
          this.loading = false;
          if (user) {
            this.fetchDirectoryTree();
          }
        });
        
        // Add keyboard navigation
        this.setupKeyboardNavigation();
      },
      beforeUnmount() {
        // Clean up keyboard event listeners
        document.removeEventListener('keydown', this.handleKeydown);
      },
    });

    app.component('directory-tree', {
      props: ['nodes', 'selectedFile', 'isRootLevel'],
      data() {
        return {
          collapsed: {} // Track collapsed state for directories
        };
      },
      mounted() {
        this.setupInitialExpansion();
      },
      watch: {
        nodes: {
          handler() {
            this.setupInitialExpansion();
          },
          immediate: true
        }
      },
      methods: {
        setupInitialExpansion() {
          // Auto-expand the first (latest) date folder at root level
          if (this.isRootLevel && this.nodes && this.nodes.length > 0) {
            console.log('Setting up initial expansion for root level with', this.nodes.length, 'nodes');
            const firstNode = this.nodes[0];
            console.log('First node:', firstNode);
            if (firstNode.type === 'directory') {
              console.log('Expanding first directory:', firstNode.name);
              this.collapsed[firstNode.name] = false; // Expand the latest date folder
            }
            // Collapse all other directories at root level
            this.nodes.slice(1).forEach(node => {
              if (node.type === 'directory') {
                console.log('Collapsing directory:', node.name);
                this.collapsed[node.name] = true; // Collapse other date folders
              }
            });
            console.log('Final collapsed state:', this.collapsed);
          }
        },
        toggleCollapse(node) {
          this.collapsed = { ...this.collapsed, [node.name]: !this.collapsed[node.name] };
        },
        isCollapsed(node) {
          // For directories, check if explicitly set in collapsed object
          if (node.type === 'directory') {
            if (this.collapsed[node.name] === undefined) {
              return true; // Default to collapsed if not explicitly set
            }
            return this.collapsed[node.name]; // Return the explicit value (true/false)
          }
          return false; // Files are never collapsed
        },
        isSelected(node) {
          return this.selectedFile && this.selectedFile.name === node.name && this.selectedFile.mediaLink === node.mediaLink;
        }
      },
      template: `
        <ul class="select-none">
          <li v-for="node in nodes" :key="node.name" class="">
            <div v-if="node.type === 'directory'" @click="toggleCollapse(node)" class="flex items-center gap-2 px-3 py-1.5 cursor-pointer hover:bg-gray-50 text-gray-800 text-sm leading-tight font-[Arial_Narrow,Arial,sans-serif]">
              <svg :class="['h-4 w-4 text-gray-500 transform transition-transform', { 'rotate-0': isCollapsed(node), '-rotate-90': !isCollapsed(node) }]" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M12.03 5.47a.75.75 0 0 1 0 1.06L9.06 9.5l2.97 2.97a.75.75 0 1 1-1.06 1.06l-3.5-3.5a.75.75 0 0 1 0-1.06l3.5-3.5a.75.75 0 0 1 1.06 0Z" clip-rule="evenodd" />
              </svg>
              <svg class="h-4 w-4 text-amber-500" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M10 4H4a2 2 0 0 0-2 2v1h20V8a2 2 0 0 0-2-2h-8l-2-2Z"/>
                <path d="M22 9H2v9a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9Z"/>
              </svg>
              <span class="font-medium truncate">{{ node.name }}</span>
            </div>
            <div v-else @click="$emit('select', node)" :class="['group flex items-center gap-2 pl-9 pr-2 py-1.5 cursor-pointer hover:bg-blue-50 text-xs leading-tight font-[Arial_Narrow,Arial,sans-serif]', { 'bg-blue-100 text-blue-800': isSelected(node), 'text-gray-700': !isSelected(node) } ]">
              <svg class="h-4 w-4 text-gray-400 group-hover:text-blue-500" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M14 3H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9l-6-6Z"/>
              </svg>
              <span class="truncate">{{ node.name }}</span>
            </div>

            <transition name="fade" mode="out-in">
              <div v-show="!isCollapsed(node) && node.children.length" class="ml-4 border-l border-gray-200">
                <directory-tree :nodes="node.children" :selected-file="selectedFile" :is-root-level="false" @select="$emit('select', $event)"></directory-tree>
              </div>
            </transition>
          </li>
        </ul>`
    });

    app.component('image-annotation', {
      props: ['imageSrc', 'annotations', 'selectedFile', 'showFaces', 'faceLabels', 'selectedBoundingBoxIndex', 'getFaceLabelKey'],
      template: `<div class="w-full h-full flex items-center justify-center">
        <div v-if="isLoading" class="loading-container">
          <div class="spinner"></div>
          <p>Loading image...</p>
        </div>
        <v-stage v-else :config="stageConfig">
          <v-layer>
            <v-image :config="imageConfig"></v-image>
            <v-rect v-for="(box, index) in facialAreaBoxes" :key="index" :config="box" @click="handleBoxClick(box.embeddingIndex)"></v-rect>
            <v-group v-for="(label, index) in nameLabels" :key="'name-' + index" :config="{ x: label.groupX, y: label.groupY }">
              <v-rect :config="label.bgRect"></v-rect>
              <v-text :config="label.text"></v-text>
            </v-group>
            <v-rect v-for="(box, index) in annotations" :key="'annotation-' + index" :config="box"></v-rect>
          </v-layer>
        </v-stage>
      </div>`,
      data() {
        return {
          stageConfig: { width: 800, height: 600 },
          imageConfig: { image: null, x: 0, y: 0, width: 800, height: 600 },
          isLoading: false,
          containerWidth: 0,
          containerHeight: 0,
          selectedBoxOpacity: 1,
          blinkInterval: null
        };
      },
      computed: {
        facialAreaBoxes() {
          // Return empty array if showFaces is false
          if (!this.showFaces) {
            return [];
          }
          
          if (!this.selectedFile || !this.selectedFile.model || !this.imageConfig.image) {
            return [];
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return [];
            }
            
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            // Calculate scale factors
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => embedding.facial_area);
            
            return embeddingsWithFaces.map(({ embedding, index }) => {
              const area = embedding.facial_area;
              const x = (area.x || 0) * scaleX;
              const y = (area.y || 0) * scaleY;
              const width = (area.w || 0) * scaleX;
              const height = (area.h || 0) * scaleY;
              
              const isSelected = this.selectedBoundingBoxIndex === index;
              
              // Check if this face has a label using the new key format
              let hasLabel = false;
              if (this.selectedFile && this.getFaceLabelKey && this.faceLabels) {
                const key = this.getFaceLabelKey(this.selectedFile.name, area);
                hasLabel = key ? !!this.faceLabels[key] : false;
              }
              
              // Color logic: Amber for unlabelled, Soft Green for labelled
              // Selected boxes blink with color based on label status
              let strokeColor = '#FFD700'; // Amber - Not Labelled (default)
              let strokeWidth = 2;
              let opacity = 1;
              
              if (isSelected) {
                // Selected box: use green if labelled, amber if not labelled
                strokeColor = hasLabel ? '#10B981' : '#FFD700'; // Soft Green if labelled, Amber if not
                strokeWidth = 4; // Thicker for visibility
                opacity = this.selectedBoxOpacity; // Blinking opacity
              } else if (hasLabel) {
                strokeColor = '#10B981'; // Soft Green - Labelled
                strokeWidth = 2;
                opacity = 1;
              } else {
                strokeColor = '#FFD700'; // Amber - Not Labelled
                strokeWidth = 2;
                opacity = 1;
              }
              
              return {
                x: x,
                y: y,
                width: width,
                height: height,
                stroke: strokeColor,
                strokeWidth: strokeWidth,
                fill: 'transparent',
                opacity: opacity,
                embeddingIndex: index
              };
            });
          } catch (error) {
            console.error('Error parsing facial areas from model:', error);
            return [];
          }
        },
        nameLabels() {
          // Return empty array if showFaces is false
          if (!this.showFaces || !this.selectedFile || !this.selectedFile.model || !this.faceLabels) {
            return [];
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings) || !this.imageConfig.image) {
              return [];
            }
            
            // Get image dimensions and scale factors
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            // Filter embeddings that have facial_area
            const embeddingsWithFaces = model.embeddings
              .map((embedding, index) => ({ embedding, index }))
              .filter(({ embedding }) => embedding.facial_area);
            
            return embeddingsWithFaces
              .map(({ embedding, index }) => {
                const area = embedding.facial_area;
                const x = (area.x || 0) * scaleX;
                const y = (area.y || 0) * scaleY;
                const width = (area.w || 0) * scaleX;
                const height = (area.h || 0) * scaleY;
                
                // Check if this face has a label
                let label = null;
                if (this.selectedFile && this.getFaceLabelKey) {
                  const key = this.getFaceLabelKey(this.selectedFile.name, area);
                  label = key ? (this.faceLabels[key] || null) : null;
                }
                
                // Only return label if there's a name
                if (!label || !label.name) {
                  return null;
                }
                
                // Position below the bounding box, centered
                // Calculate approximate text width (rough estimate: 0.6 * fontSize * character count)
                const fontSize = 12;
                const padding = 4;
                const textWidth = label.name.length * fontSize * 0.6; // Approximate width
                const textHeight = fontSize + padding * 2;
                
                // Center the group horizontally below the box
                const groupX = x + (width - textWidth) / 2 - padding; // Center horizontally
                const groupY = y + height + 2; // 2px below the box
                
                return {
                  groupX: groupX,
                  groupY: groupY,
                  bgRect: {
                    x: 0,
                    y: 0,
                    width: textWidth + padding * 2,
                    height: textHeight,
                    fill: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black background
                    cornerRadius: 2
                  },
                  text: {
                    x: padding,
                    y: padding,
                    text: label.name,
                    fontSize: fontSize,
                    fontFamily: 'Arial',
                    fill: '#D3D3D3', // Light grey
                    align: 'left'
                  }
                };
              })
              .filter(label => label !== null); // Remove null entries
          } catch (error) {
            console.error('Error creating name labels:', error);
            return [];
          }
        }
      },
      watch: {
        selectedBoundingBoxIndex: {
          handler(newVal) {
            // Start/stop blinking animation when selection changes
            if (this.blinkInterval) {
              clearInterval(this.blinkInterval);
              this.blinkInterval = null;
            }
            
            if (newVal !== null) {
              // Start blinking animation
              this.selectedBoxOpacity = 1;
              this.blinkInterval = setInterval(() => {
                this.selectedBoxOpacity = this.selectedBoxOpacity === 1 ? 0.3 : 1;
                // Force update to trigger recomputation of facialAreaBoxes
                this.$forceUpdate();
              }, 500); // Blink every 500ms
            } else {
              // Stop blinking
              this.selectedBoxOpacity = 1;
            }
          },
          immediate: false
        },
        imageSrc: {
          handler(newSrc) {
            if (!newSrc) return;
            this.loadImage(newSrc);
          },
          immediate: true
        },
        selectedFile: {
          handler(newFile, oldFile) {
            // Recalculate boxes when file changes
            this.$nextTick(() => {
              // Force update by accessing the computed property
              this.$forceUpdate();
            });
          },
          deep: true
        },
        'selectedFile.model': {
          handler() {
            // Recalculate boxes when model data is loaded
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          }
        },
        imageConfig: {
          handler() {
            // Recalculate boxes when image dimensions change
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          },
          deep: true
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.updateDimensions();
        });
        window.addEventListener('resize', this.updateDimensions);
      },
      beforeUnmount() {
        window.removeEventListener('resize', this.updateDimensions);
        // Clean up blinking interval
        if (this.blinkInterval) {
          clearInterval(this.blinkInterval);
          this.blinkInterval = null;
        }
      },
      methods: {
        handleBoxClick(embeddingIndex) {
          this.$emit('face-box-click', embeddingIndex);
        },
        updateDimensions() {
          // Get the image pane container dimensions
          const imagePane = document.querySelector('.image-pane');
          if (imagePane) {
            this.containerWidth = imagePane.clientWidth;
            this.containerHeight = imagePane.clientHeight;
            console.log('Container dimensions:', this.containerWidth, 'x', this.containerHeight);
            this.calculateOptimalSize();
          } else {
            console.log('Image pane not found');
          }
        },
        calculateOptimalSize() {
          // Use most of the available space, leaving some padding
          const padding = 20;
          const availableWidth = Math.max(400, this.containerWidth - padding);
          const availableHeight = Math.max(300, this.containerHeight - padding);
          
          console.log('Calculating optimal size:', {
            containerWidth: this.containerWidth,
            containerHeight: this.containerHeight,
            availableWidth,
            availableHeight,
            hasImage: !!this.imageConfig.image
          });
          
          // If we have an image loaded, use its natural dimensions
          if (this.imageConfig.image) {
            const img = this.imageConfig.image;
            const imageAspectRatio = img.naturalWidth / img.naturalHeight;
            const containerAspectRatio = availableWidth / availableHeight;
            
            console.log('Image dimensions:', {
              naturalWidth: img.naturalWidth,
              naturalHeight: img.naturalHeight,
              imageAspectRatio,
              containerAspectRatio
            });
            
            let width, height;
            
            if (containerAspectRatio > imageAspectRatio) {
              // Container is wider than image - fit to height
              height = availableHeight;
              width = height * imageAspectRatio;
            } else {
              // Container is taller than image - fit to width
              width = availableWidth;
              height = width / imageAspectRatio;
            }
            
            // Ensure we don't exceed container bounds
            if (width > availableWidth) {
              width = availableWidth;
              height = width / imageAspectRatio;
            }
            if (height > availableHeight) {
              height = availableHeight;
              width = height * imageAspectRatio;
            }
            
            console.log('Calculated dimensions:', { width, height });
            
            // Update stage and image config
            this.stageConfig = { width: Math.floor(width), height: Math.floor(height) };
            this.imageConfig = { 
              ...this.imageConfig, 
              width: Math.floor(width), 
              height: Math.floor(height) 
            };
            
            // Force update to recalculate facial area boxes with new dimensions
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          } else {
            // Default size when no image is loaded
            const defaultWidth = Math.min(800, availableWidth);
            const defaultHeight = Math.min(600, availableHeight);
            
            this.stageConfig = { width: defaultWidth, height: defaultHeight };
            this.imageConfig = { 
              ...this.imageConfig, 
              width: defaultWidth, 
              height: defaultHeight 
            };
          }
        },
        loadImage(imageSrc) {
          this.isLoading = true;
          this.$emit('loading-change', true);
          console.log('Loading image from URL:', imageSrc);
          
          const img = new Image();
          img.crossOrigin = 'anonymous'; // Enable CORS for signed URLs
          img.onload = () => {
            console.log('Image loaded successfully, dimensions:', img.naturalWidth, 'x', img.naturalHeight);
            this.imageConfig.image = img;
            this.isLoading = false;
            this.$emit('loading-change', false);
            // Recalculate dimensions after image loads with proper sizing
            this.$nextTick(() => {
              this.updateDimensions();
            });
          };
          img.onerror = (error) => {
            console.error('Error loading image:', error);
            this.isLoading = false;
            this.$emit('loading-change', false);
          };
          img.src = imageSrc; // Use the signed URL directly
        }
      }
    });

    app.use(VueKonva);
    const vueApp = app.mount('#app');

    // Setup resizer functionality after Vue app is mounted
    function setupResizer() {
      const resizer = document.getElementById('resizer');
      const directoryPane = document.getElementById('directoryPane');
      const mainContent = document.querySelector('.main-content');

      // Check if elements exist before adding event listeners
      if (!resizer || !directoryPane || !mainContent) {
        console.log('Some DOM elements not found, skipping resizer setup');
        return;
      }

      let isResizing = false;
      let startX = 0;
      let startWidth = 0;

      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = directoryPane.offsetWidth;
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const deltaX = e.clientX - startX;
        const newWidth = startWidth + deltaX;
        const minWidth = 200;
        const maxWidth = mainContent.offsetWidth * 0.7; // Max 70% of content width

        if (newWidth >= minWidth && newWidth <= maxWidth) {
          directoryPane.style.width = `${newWidth}px`;
        }
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = 'default';
          document.body.style.userSelect = '';
        }
      });

      // Prevent text selection during resize
      resizer.addEventListener('selectstart', (e) => {
        e.preventDefault();
      });
    }

    // Setup resizer after Vue app is mounted with a delay to ensure DOM is ready
    setTimeout(setupResizer, 100);
  </script>
</body>
</html>
