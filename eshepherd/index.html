<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>eShepherd</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="eshepherd.png">
  <link rel="icon" type="image/png" sizes="16x16" href="eshepherd.png">
  <link rel="apple-touch-icon" href="eshepherd.png">
  <link rel="shortcut icon" href="eshepherd.png">
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <!-- Client Vector Search Library - loaded dynamically via esm.sh -->
  <!--1. Link Vue Javascript & Konva-->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <!--2. Link VueKonva Javascript -->
  <script src="https://unpkg.com/vue-konva@3/dist/vue-konva.umd.js"></script>
  <!-- Load utility modules -->
  <script type="module" src="utils-loader.js"></script>
  <!-- Load component modules -->
  <script type="module" src="components-loader.js"></script>
  <!-- Replace Tailwind CDN with a local installation or CLI setup for production -->
</head>
<body class="bg-gray-100">
  <div id="app">
    <!-- Top Banner -->
    <header :class="['fixed top-0 inset-x-0 h-10 bg-gray-800 text-white grid grid-cols-3 items-center px-3 text-sm shadow z-10 transition-transform duration-300', { '-translate-y-full': !bannerVisible }]">
      <div class="flex items-center">
        <button v-if="user" @click="toggleSidebar" class="flex items-center gap-1 rounded px-2 py-1 bg-gray-700 hover:bg-gray-600 active:bg-gray-500 text-xs">
          <svg class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M4 6h16v2H4V6Zm0 5h10v2H4v-2Zm0 5h16v2H4v-2Z"/></svg>
          <span>{{ sidebarCollapsed ? 'Show Sessions' : 'Hide Sessions' }}</span>
        </button>
      </div>
      <div class="text-center font-semibold tracking-wide text-orange-500">eShepherd</div>
      <div class="flex justify-end">
        <button v-if="user" @click="signOut" class="text-xs text-gray-300 hover:text-white">Sign Out</button>
      </div>
    </header>
    
    <!-- Main Content Area -->
    <div :class="['main-content', { 'banner-hidden': !bannerVisible }]">
      <!-- Left Pane: Control Side Panel -->
      <div :class="['directory-pane text-xs transition-all duration-200 bg-blue-50', { 'border-r border-gray-200': !sidebarCollapsed }]" :style="sidebarCollapsed ? { width: '0px', minWidth: '0px' } : { minWidth: '200px' }" id="directoryPane">
        <control-side-panel
          v-show="!sidebarCollapsed && user"
          :user="user"
          :loading="loading"
          :sessions="sessions"
          :selected-session-name="selectedSessionName"
          :selected-file="selectedFile"
          :people-retrieval-status="peopleRetrievalStatus"
          :people-retrieval-count="peopleRetrievalCount"
          :selected-bounding-box-index="selectedBoundingBoxIndex"
          :selected-point-label-id="selectedPointLabelId"
          :labelling-started="labellingStarted"
          :search-query="searchQuery"
          :search-results="searchResults"
          :selected-search-index="selectedSearchIndex"
          :face-guesses="faceGuesses"
          :planning-centre-people="planningCentrePeople"
          :checking-embedding-in-d-b="checkingEmbeddingInDB"
          :check-in-overlay-selection="checkInOverlaySelection"
          :check-in-submitting="checkInSubmitting"
          :check-in-error="checkInError"
          :check-in-success-message="checkInSuccessMessage"
          :show-faces="showFaces"
          :face-labels="faceLabels"
          :face-scanning-status="faceScanningStatus"
          :face-scan-count="faceScanCount"
          :checked-people-by-box="checkedPeopleByBox"
          :checked-people-by-point="checkedPeopleByPoint"
          :point-label-persons="pointLabelPersons"
          :embeddings-stored="embeddingsStored"
          :embeddings-count-cache="embeddingsCountCache"
          :face-match-cache="faceMatchCache"
          :embedding-index="embeddingIndex"
          @session-change="onSessionChange"
          @faces-button-click="handleFacesButtonClick"
          @fetch-planning-centre-people="fetchPlanningCentrePeople"
          @reload-embeddings="reloadEmbeddingsIndex"
          @search-input="searchQuery = $event"
          @search-results-change="searchResults = $event"
          @search-index-change="selectedSearchIndex = $event"
          @face-guesses-clear="faceGuesses = []"
          @face-guesses-update="faceGuesses = $event"
          @load-face-guesses="loadAllStoredEmbeddings()"
          @select-person="selectPerson"
          @selected-person-checkbox-change="handleSelectedPersonCheckboxChange"
          @household-checkbox-change="handleHouseholdCheckboxChange"
          @selected-point-person-checkbox-change="handleSelectedPointPersonCheckboxChange"
          @point-household-checkbox-change="handlePointHouseholdCheckboxChange"
          @store-embeddings="handleStoreEmbeddings"
          @open-check-in-overlay="openCheckInOverlay"
        ></control-side-panel>
      </div>

      <!-- Resizer -->
      <div class="resizer" id="resizer" v-show="!sidebarCollapsed && user"></div>

      <!-- Right Pane: Image Annotation Panel -->
      <image-annotation-panel
        ref="imageAnnotationPanel"
        :user="user"
        :loading="loading"
        :error="error"
        :selected-image="selectedImage"
        :selected-file="selectedFile"
        :image-loading="imageLoading"
        :current-folder-files="currentFolderFiles"
        :current-file-index="currentFileIndex"
        :has-prev-image="hasPrevImage"
        :has-next-image="hasNextImage"
        :selected-bounding-box-index="selectedBoundingBoxIndex"
        :annotations="annotations"
        :show-faces="showFaces"
        :face-labels="faceLabels"
        :point-labels="pointLabels"
        :selected-point-label-id="selectedPointLabelId"
        :point-label-persons="pointLabelPersons"
        :checked-people-by-point="checkedPeopleByPoint"
          :checked-people-by-box="checkedPeopleByBox"
          :planning-centre-people="planningCentrePeople"
          :ensure-url-valid="ensureUrlValid"
          :fetch-model-data="fetchModelData"
          @sign-in="signIn"
        @file-change="selectedFile = $event"
        @image-change="selectedImage = $event"
        @file-index-change="currentFileIndex = $event"
        @clear-selection="handleClearSelection"
        @banner-visibility-change="handleBannerVisibilityChange"
        @update-annotations="annotations = $event"
        @loading-change="imageLoading = $event"
        @face-box-click="onFaceBoxClick"
        @point-label-click="onPointLabelClick"
        @point-label-create="onPointLabelCreate"
      >
        <!-- Check-In Overlay (inside image-annotation-panel for proper positioning) -->
        <check-in-overlay
          :show="showCheckInOverlay"
          :table-data="getCheckInTableData()"
          :selection="checkInOverlaySelection"
          :selected-count="getOverlaySelectedCount()"
          :total-count="getCheckInTableData().length"
          :all-selected="areAllCheckInSelected()"
          :submitting="checkInSubmitting"
          :error="checkInError"
          :success-message="checkInSuccessMessage"
          :user="user"
          @close="closeCheckInOverlay"
          @toggle-select-all="toggleCheckInSelectAll"
          @checkbox-change="handleCheckInTableCheckboxChange"
          @submitting-change="checkInSubmitting = $event"
          @error-change="checkInError = $event"
          @success-message-change="checkInSuccessMessage = $event"
        ></check-in-overlay>
      </image-annotation-panel>
          </div>
        </div>
        
  <script>
    // Wait for Utils and Components to be loaded from modules
    (async function() {
      // Wait for Utils to be available (loaded by utils-loader.js)
      while (!window.Utils || Object.keys(window.Utils).length === 0) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      // Wait for Components to be available (loaded by components-loader.js)
      while (!window.Components || Object.keys(window.Components).length === 0) {
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      // Firebase is initialized in utils-loader.js (config/firebase.js)
      // Access via window.firebaseAuth and window.firebaseDatabase
      const auth = window.firebaseAuth;
      const database = window.firebaseDatabase;

      // Utils and Services are now loaded from utils-loader.js module
      const Utils = window.Utils;
      const Services = window.Services;

    const VueKonva = window['vue-konva'].default;
    const app = Vue.createApp({
          data() {
        return {
          directoryTree: [],
          selectedImage: null,
          selectedFile: null,
          selectedSession: null,
          selectedSessionName: '',
          annotations: [],
          currentFolderFiles: [],
          currentFileIndex: -1,
          sidebarCollapsed: false,
          user: null,
          loading: true,
          imageLoading: false,
          error: null,
          touchStartX: null,
          touchStartY: null,
          bannerVisible: true,
          isSwipe: false,
          showFaces: false,
          labellingStarted: false,
          peopleRetrievalStatus: 'idle', // 'idle', 'retrieving', 'completed'
          peopleRetrievalCount: 0,
          planningCentrePeople: [], // Store the actual records
          selectedBoundingBoxIndex: null, // Index of the selected bounding box
          pointLabels: {}, // Map of "imageName" to array of point labels: {imageName: [{id, x, y, naturalX, naturalY}]}
          selectedPointLabelId: null, // ID of the selected point label (null if none selected)
          pointLabelPersons: {}, // Map of point label ID to selected person record (similar to faceLabels)
          checkedPeopleByPoint: {}, // Per-point-label checked people: { [pointLabelId]: { [personId]: true/false } }
          faceLabels: {}, // Map of "imageName_x_y_w_h" to selected person record (persists per session)
          searchQuery: '',
          searchResults: [],
          selectedSearchIndex: -1, // Index of the highlighted search result
          faceGuesses: [], // Top 5 matches for the selected bounding box: [{person, similarity}]
          currentSessionLabels: {}, // Store labels for current session
          searchResultRefs: {}, // Refs to search result elements for scrolling
          selectedPersonChecked: true, // Track if selected person checkbox is checked (for current selection UI)
          householdCheckboxes: {}, // Track household member checkboxes state (for current selection UI)
          checkedPeopleByBox: {}, // Per-bounding-box checked people: { [faceLabelKey]: { [personId]: true/false } }
          embeddingsStored: {}, // Track if embeddings are stored for each bounding box (keyed by face label key)
          embeddingsCountCache: {}, // Cache for embeddings count per person ID
          currentEmbeddingData: null, // Store current embedding data for comparison
          checkingEmbeddingInDB: false, // Track if we're currently checking embedding in DB
          embeddingIndex: null, // EmbeddingIndex from client-vector-search
          ClientVectorSearchModule: null, // Store the imported module
          faceMatchCache: {}, // Cache face matches per image: {imageKey: {embeddingIndex: {personId, similarity, person}}}
          SIMILARITY_THRESHOLD: 0.80, // Cosine similarity threshold for face matching (0.75 is good for face recognition)
          faceScanningStatus: {}, // Track face scanning status per image: {imageKey: 'scanning' | 'scanned' | null}
          faceScanCount: {}, // Track number of faces scanned per image: {imageKey: number}
          showCheckInOverlay: false, // Control visibility of check-in overlay
          checkInSubmitting: false, // Track check-in submission state
          checkInError: null, // Store check-in error messages
          checkInSuccessMessage: '', // Store success message after check-in
          checkInOverlaySnapshot: [], // Person IDs captured when opening overlay
          checkInOverlaySelection: {} // Overlay-specific checkbox states
        };
      },
      methods: {
        async handleFacesButtonClick() {
          if (!this.labellingStarted) {
            // Start labelling: show faces and fetch planning centre people
            this.labellingStarted = true;
            this.showFaces = true;
            await this.fetchPlanningCentrePeople();
          } else {
            // Toggle faces visibility
            this.showFaces = !this.showFaces;
          }
        },
        async signIn() {
          const result = await Services.auth.signIn();
          if (result.user) {
            this.user = result.user;
            this.error = null;
            await this.fetchDirectoryTree();
          } else {
            this.error = result.error || 'Sign in failed';
          }
        },
        async signOut() {
          const result = await Services.auth.signOut();
          if (!result.error) {
            this.user = null;
            this.directoryTree = [];
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedFile = null;
            this.selectedSession = null;
            this.selectedSessionName = '';
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        toggleSidebar() {
          this.sidebarCollapsed = !this.sidebarCollapsed;
          this.bannerVisible = true; // Show banner when interacting with UI
        },
        updateFolderContextFromSelected(node) {
          // Find parent and its file list; then set current index
          const result = this.findParentAndIndexByMediaLink(this.directoryTree, node.url, null);
          if (result && result.parent) {
            const files = result.parent.children.filter(child => child.type === 'file');
            const idx = files.findIndex(f => f.url === node.url);
            this.currentFolderFiles = files;
            this.currentFileIndex = idx;
          } else {
            this.currentFolderFiles = [];
            this.currentFileIndex = -1;
          }
        },
        findParentAndIndexByMediaLink(nodes, url, parent) {
          if (!nodes) return null;
          for (const n of nodes) {
            if (n.type === 'file' && n.url === url) {
              return { parent, node: n };
            }
            if (n.children && n.children.length) {
              const res = this.findParentAndIndexByMediaLink(n.children, url, n);
              if (res) return res;
            }
          }
          return null;
        },
        async fetchDirectoryTree() {
          if (!this.user) return;
          
          try {
            this.loading = true;
            const result = await Services.file.fetchDirectoryTree(this.user);
            if (result.items) {
              this.directoryTree = Services.file.transformToTree(result.items);
              // Auto-select the latest session after loading
              this.$nextTick(() => {
                this.selectLatestSession();
              });
            } else {
              this.error = result.error || 'Failed to load images';
            }
          } catch (error) {
            console.error('Error fetching directory tree:', error);
            this.error = 'Failed to load images: ' + error.message;
          } finally {
            this.loading = false;
          }
        },
        isUrlExpired(file) {
          return Services.file.isUrlExpired(file);
        },
        async fetchPlanningCentrePeople() {
          if (!this.user) {
            console.error('User not authenticated');
            return;
          }
          
          try {
            this.peopleRetrievalStatus = 'retrieving';
            const result = await Services.planningCenter.fetchPeople(this.user);
            
            if (result.error) {
              throw new Error(result.error);
            }
            
            this.planningCentrePeople = result.records;
            this.peopleRetrievalCount = result.records.length;
            this.peopleRetrievalStatus = 'completed';
            
            // After loading people, try to match faces in current image
            if (this.selectedFile && this.selectedFile.model) {
              this.$nextTick(() => {
                this.matchFacesInImage(this.selectedFile);
              });
            }
          } catch (error) {
            console.error('Error fetching planning centre people:', error);
            this.peopleRetrievalStatus = 'completed'; // Still mark as completed to show error state
            this.peopleRetrievalCount = 0;
          }
        },
        async refreshUrls() {
          if (!this.user) return false;
          
          try {
            const result = await Services.file.refreshUrls(this.user);
            if (result.items) {
              // Update URLs in the directory tree and currentFolderFiles
              Services.file.updateUrlsInTree(this.directoryTree, result.items, this.currentFolderFiles);
              return true;
            } else {
              return false;
            }
          } catch (error) {
            console.error('Error refreshing URLs:', error);
            return false;
          }
        },
        updateUrlsInTree(tree, items) {
          Services.file.updateUrlsInTree(tree, items, this.currentFolderFiles);
        },
        async ensureUrlValid(file) {
          if (!file) return null;
          return await Services.file.ensureUrlValid(file, this.user, this.directoryTree, () => this.refreshUrls());
        },
        findFileByName(nodes, fileName) {
          return Services.file.findFileByName(nodes, fileName);
        },
        transformToTree(data) {
          return Services.file.transformToTree(data);
        },
        onSessionChange() {
          if (!this.selectedSessionName) return;
          
          // Find the session by name
          const session = this.sessions.find(s => s.name === this.selectedSessionName);
          if (session) {
            this.bannerVisible = true; // Show banner when selecting session
            this.onSelectSession(session);
          }
        },
        getFaceLabelKey(imageName, facialArea) {
          return Utils.getFaceLabelKey(imageName, facialArea);
        },
        async onSelectSession(session) {
          this.selectedSession = session;
          this.selectedSessionName = session.name;
          // Clear labels, checked people, and embeddings stored when session changes
          this.faceLabels = {};
          this.currentSessionLabels = {};
          this.checkedPeopleByBox = {};
          this.embeddingsStored = {};
          this.embeddingsCountCache = {};
          this.currentEmbeddingData = null;
          this.embeddingIndex = null; // Reload embeddings for new session
          this.faceMatchCache = {}; // Clear face match cache
          this.faceScanningStatus = {}; // Clear face scanning status
          this.faceScanCount = {}; // Clear face scan count
          // Get all files from this session (recursively)
          const files = this.getAllFilesFromNode(session);
          this.currentFolderFiles = files;
          
          // Select the first image if available
          if (files.length > 0) {
            this.currentFileIndex = 0;
            this.selectedFile = files[0];
            const validUrl = await this.ensureUrlValid(files[0]);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', files[0].name);
            }
            // Fetch model data if model_url exists
            if (files[0].model_url) {
              this.fetchModelData(files[0]);
            }
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          } else {
            this.currentFileIndex = -1;
            this.selectedFile = null;
            this.selectedImage = null;
            this.imageLoading = false;
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        getAllFilesFromNode(node) {
          return Services.file.getAllFilesFromNode(node);
        },
        async fetchModelData(file) {
          if (!file || !file.model_url) return null;
          
          // If model is already cached, return it
          if (file.model !== null && file.model !== undefined) {
            // If model is loaded and we have faces, try to match them
            if (file.model && file.model.embeddings) {
              this.$nextTick(() => {
                this.matchFacesInImage(file);
              });
            }
            return file.model;
          }
          
          try {
            const response = await fetch(file.model_url);
            if (!response.ok) {
              throw new Error(`Failed to fetch model: ${response.status}`);
            }
            const modelData = await response.json();
            // Cache the model data
            file.model = modelData;
            
            // After loading model, match faces
            this.$nextTick(() => {
              this.matchFacesInImage(file);
            });
            
            return modelData;
          } catch (error) {
            console.error('Error fetching model data:', error);
            // Set to empty object to prevent repeated failed fetches
            file.model = {};
            return null;
          }
        },
        // Decode base64 embedding to Float32Array (numpy float32 array equivalent)
        // Python encoding: np.array(embedding, dtype=np.float32).tobytes() -> base64.b64encode().decode('utf-8')
        decodeEmbeddingFromBase64(base64String) {
          return Utils.decodeEmbeddingFromBase64(base64String);
        },
        // Reload embeddings index from Firebase
        async reloadEmbeddingsIndex() {
          // Clear current index and cache
          this.embeddingIndex = null;
          this.faceMatchCache = {};
          this.faceScanningStatus = {};
          this.faceScanCount = {};
          
          // Reload embeddings (force reload)
          await this.loadAllStoredEmbeddings(true);
          
          // Rescan faces in current image if available
          if (this.selectedFile && this.selectedFile.model) {
            this.$nextTick(() => {
              this.matchFacesInImage(this.selectedFile);
            });
          }
        },
        // Load all embeddings from Firebase and create EmbeddingIndex
        async loadAllStoredEmbeddings(forceReload = false) {
          if (this.embeddingIndex !== null && !forceReload) {
            // Already loaded
            return;
          }
          
          try {
            // Dynamically import client-vector-search from esm.sh
            if (!this.ClientVectorSearchModule) {
              this.ClientVectorSearchModule = await import('https://esm.run/client-vector-search');
            }
            
            this.embeddingIndex = await Services.embedding.loadAllStoredEmbeddings(
              this.ClientVectorSearchModule,
              forceReload,
              this.embeddingIndex
            );
          } catch (error) {
            console.error('Error loading all stored embeddings:', error);
            this.embeddingIndex = null;
          }
        },
        // Match all faces in an image
        async matchFacesInImage(file) {
          if (!file || !file.model || !file.name) {
            return;
          }
          
          const imageKey = file.name;
          
          // Check cache first
          if (this.faceMatchCache[imageKey]) {
            // Apply cached matches
            this.applyFaceMatches(file, this.faceMatchCache[imageKey]);
            // Set status to scanned since we already have cached results
            this.faceScanningStatus[imageKey] = 'scanned';
            // Get face count from model if not cached
            if (!this.faceScanCount[imageKey]) {
              try {
                const model = typeof file.model === 'string' 
                  ? JSON.parse(file.model) 
                  : file.model;
                if (model.embeddings && Array.isArray(model.embeddings)) {
                  this.faceScanCount[imageKey] = model.embeddings.filter(e => e && e.embedding && e.facial_area).length;
                }
              } catch (e) {
                this.faceScanCount[imageKey] = Object.keys(this.faceMatchCache[imageKey]).length;
              }
            }
            this.$forceUpdate();
            return;
          }
          
          // Use utility function
          const matches = await Utils.matchFacesInImage(file, {
            peopleRetrievalStatus: this.peopleRetrievalStatus,
            planningCentrePeople: this.planningCentrePeople,
            faceMatchCache: this.faceMatchCache,
            faceScanningStatus: this.faceScanningStatus,
            faceScanCount: this.faceScanCount,
            embeddingIndex: this.embeddingIndex,
            similarityThreshold: this.SIMILARITY_THRESHOLD,
            loadAllStoredEmbeddings: () => this.loadAllStoredEmbeddings(),
            updateState: (updates) => {
              Object.keys(updates).forEach(key => {
                this[key] = updates[key];
              });
            this.$forceUpdate();
            }
          });
            
            // Apply the matches
          if (matches && Object.keys(matches).length > 0) {
            this.applyFaceMatches(file, matches);
          }
        },
        // Apply face matches to labels
        applyFaceMatches(file, matches) {
          if (!file || !matches || Object.keys(matches).length === 0) {
            return;
          }
          
          Utils.applyFaceMatches(file, matches, {
            faceLabels: this.faceLabels,
            currentSessionLabels: this.currentSessionLabels,
            setPersonCheckedForBox: (key, personId, checked) => this.setPersonCheckedForBox(key, personId, checked),
            updateState: (updates) => {
              Object.keys(updates).forEach(key => {
                this[key] = updates[key];
              });
            this.$forceUpdate();
          }
          });
        },
        formatModel(model) {
          if (!model) return '';
          
          try {
            // If model is already a string, try to parse it as JSON
            if (typeof model === 'string') {
              const parsed = JSON.parse(model);
              return JSON.stringify(parsed, null, 2);
            }
            // If model is an object, stringify it with formatting
            return JSON.stringify(model, null, 2);
          } catch (error) {
            // If parsing fails, return as string
            return typeof model === 'string' ? model : String(model);
          }
        },
        selectLatestSession() {
          // Select the latest session (first one in the sorted list, since we sort latest to earliest)
          if (this.sessions.length > 0) {
            const latestSession = this.sessions[0];
            this.onSelectSession(latestSession);
          }
        },
        handleClearSelection() {
          this.selectedBoundingBoxIndex = null;
          this.selectedPointLabelId = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
        },
        handleBannerVisibilityChange(value) {
          this.bannerVisible = value === null ? !this.bannerVisible : value;
        },
        async onSelectNode(node) {
          if (node.type === 'file') {
            this.selectedFile = node;
            const validUrl = await this.ensureUrlValid(node);
            this.selectedImage = validUrl;
            if (!validUrl) {
              console.error('Failed to get valid URL for file:', node.name);
            }
            // Fetch model data if model_url exists
            if (node.model_url) {
              this.fetchModelData(node);
            }
            this.updateFolderContextFromSelected(node);
            // Clear selected bounding box when switching files (but keep labels)
            this.selectedBoundingBoxIndex = null;
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Don't clear faceLabels - they persist per session
          }
        },
        onPointLabelCreate(pointData) {
          if (!this.selectedFile) return;
          
          const imageName = this.selectedFile.name;
          if (!this.pointLabels[imageName]) {
            this.pointLabels[imageName] = [];
          }
          
          // Generate unique ID for the point
          const pointId = `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Add point to the array
          this.pointLabels[imageName].push({
            id: pointId,
            x: pointData.x,
            y: pointData.y,
            naturalX: pointData.naturalX,
            naturalY: pointData.naturalY
          });
          
          // Select the newly created point
          this.selectedPointLabelId = pointId;
          
          // Clear bounding box selection when selecting a point
          this.selectedBoundingBoxIndex = null;
          
          // Initialize checkboxes (no person selected yet for new point)
          this.selectedPersonChecked = true;
          this.householdCheckboxes = {};
          
          // Clear search state
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
          
          // Ensure labelling is started (needed for search box to be visible)
          if (!this.labellingStarted) {
            this.labellingStarted = true;
            this.showFaces = true;
            // Fetch planning centre people if not already loaded
            if (!this.planningCentrePeople || this.planningCentrePeople.length === 0) {
              this.fetchPlanningCentrePeople();
            }
          }
          
          // Focus the search input - use both $nextTick and setTimeout to ensure DOM is ready
          this.$nextTick(() => {
            setTimeout(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            }, 100);
          });
        },
        onPointLabelClick(pointId) {
          // Toggle selection - if clicking the same point, deselect it
          if (this.selectedPointLabelId === pointId) {
            // Check if there's a person selected before deselecting
            const currentLabel = this.getCurrentPointLabel();
            if (!currentLabel) {
              // No person selected, delete the point label
              this.deletePointLabel(pointId);
            }
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          } else {
            this.selectedPointLabelId = pointId;
            // Clear bounding box selection when selecting a point
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentPointLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonCheckedForPoint(pointId, currentLabel.id);
              this.initializeHouseholdCheckboxesForPoint(pointId, currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input (same as bounding box logic)
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          }
        },
        onFaceBoxClick(embeddingIndex) {
          // Toggle selection - if clicking the same box, deselect it
          if (this.selectedBoundingBoxIndex === embeddingIndex) {
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.faceGuesses = [];
            this.selectedPersonChecked = true;
            this.householdCheckboxes = {};
          } else {
            this.selectedBoundingBoxIndex = embeddingIndex;
            // Clear point label selection when selecting a bounding box
            this.selectedPointLabelId = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            this.faceGuesses = []; // Clear previous guesses
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
              
              // Reset stored state first
              const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
              if (facialArea) {
                const resetKey = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                if (resetKey) {
                  this.embeddingsStored[resetKey] = false;
                }
              }
              
              // Set loading state
              this.checkingEmbeddingInDB = true;
              this.$forceUpdate();
              
              // Load embedding data and check if it exists in DB
              this.loadEmbeddingData();
              this.getEmbeddingsCount(); // Load count (async, but don't wait)
              this.checkEmbeddingInDB(); // Check DB (async, but don't wait)
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              this.currentEmbeddingData = null;
              
              // Face guesses will be loaded by ControlSidePanel component
            }
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          }
        },
        getHouseholdMembers(person) {
          return Services.planningCenter.getHouseholdMembers(person, this.planningCentrePeople);
        },
        getHouseholdGroups(person) {
          return Services.planningCenter.getHouseholdGroups(person, this.planningCentrePeople);
        },
        getHouseholdMembersDisplay(person) {
          return Services.planningCenter.getHouseholdMembersDisplay(person, this.planningCentrePeople);
        },
        getPersonById(personId) {
          return Services.planningCenter.getPersonById(personId, this.planningCentrePeople);
        },
        getCheckInTableData() {
          const entries = [];
          const addedIds = new Set();
          const snapshotIds = this.checkInOverlaySnapshot || [];
          
          if (!snapshotIds.length) {
            return entries;
          }
          
          snapshotIds.forEach(personId => {
            const person = this.getPersonById(personId);
            if (person && person.id && !addedIds.has(person.id)) {
              entries.push({ person });
              addedIds.add(person.id);
            }
          });
          
          return entries;
        },
        areAllCheckInSelected() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (snapshotIds.length === 0) {
            return false;
          }
          return snapshotIds.every(personId => this.checkInOverlaySelection[personId]);
        },
        toggleCheckInSelectAll() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (snapshotIds.length === 0) {
            return;
          }
          const shouldSelectAll = !this.areAllCheckInSelected();
          snapshotIds.forEach(personId => {
            this.checkInOverlaySelection[personId] = shouldSelectAll;
          });
        },
        handleCheckInTableCheckboxChange(personId, event) {
          const checked = event.target.checked;
          this.checkInOverlaySelection[personId] = checked;
        },
        openCheckInOverlay() {
          const selectedIds = this.getSelectedCheckInPersonIds();
          if (!selectedIds.length) {
            return;
          }
          this.checkInOverlaySnapshot = [...selectedIds];
          this.checkInOverlaySelection = {};
          selectedIds.forEach(personId => {
            this.checkInOverlaySelection[personId] = true;
          });
          this.checkInError = null;
          this.checkInSuccessMessage = '';
          this.showCheckInOverlay = true;
        },
        closeCheckInOverlay() {
          this.showCheckInOverlay = false;
        },
        getOverlaySelectedCount() {
          const snapshotIds = this.checkInOverlaySnapshot || [];
          if (!snapshotIds.length) {
            return 0;
          }
          return snapshotIds.filter(personId => this.checkInOverlaySelection[personId]).length;
        },
        getSelectedCheckInPersonIds() {
          return Utils.getSelectedCheckInPersonIds(this.checkedPeopleByBox, this.checkedPeopleByPoint);
        },
        // Get session validity time range in UTC
        // sessionName is assumed to be a date in SGT format (e.g., "2025-11-30")
        getSessionValidityRange(sessionName) {
          return Utils.getSessionValidityRange(sessionName);
        },
        async selectPerson(person) {
          // Clear face guesses when a person is selected
          this.faceGuesses = [];
          
          if (this.selectedBoundingBoxIndex !== null && this.selectedFile) {
            // Get the facial area for the selected embedding index
            const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
            if (facialArea) {
              const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
              if (key) {
                // Clear all previously checked people for this bounding box before setting new person
                if (this.checkedPeopleByBox[key]) {
                  // Uncheck all previously checked people
                  Object.keys(this.checkedPeopleByBox[key]).forEach(personId => {
                    this.checkedPeopleByBox[key][personId] = false;
                  });
                }
                
                this.faceLabels[key] = person;
                this.currentSessionLabels[key] = person;
                // Mark selected person as checked for this bounding box
                if (person.id) {
                  this.setPersonCheckedForBox(key, person.id, true);
                }
                // Initialize checkbox states from per-box list
                this.selectedPersonChecked = this.isPersonChecked(person.id);
                this.initializeHouseholdCheckboxes(person);
                
                // Reset stored state first
                const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
                if (facialArea) {
                  const resetKey = this.getFaceLabelKey(this.selectedFile.name, facialArea);
                  if (resetKey) {
                    this.embeddingsStored[resetKey] = false;
                  }
                }
                
                // Set loading state
                this.checkingEmbeddingInDB = true;
                this.$forceUpdate();
                
                // Load current embedding data and check if it exists in DB
                this.loadEmbeddingData();
                await this.getEmbeddingsCount(); // Load count first
                await this.checkEmbeddingInDB(); // This will set checkingEmbeddingInDB to false when done
              }
            }
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          } else if (this.selectedPointLabelId !== null) {
            // Handle point label selection
            this.pointLabelPersons[this.selectedPointLabelId] = person;
            // Mark selected person as checked for this point label
            if (person.id) {
              this.setPersonCheckedForPoint(this.selectedPointLabelId, person.id, true);
            }
            // Initialize checkbox states from per-point list
            this.selectedPersonChecked = this.isPersonCheckedForPoint(this.selectedPointLabelId, person.id);
            this.initializeHouseholdCheckboxesForPoint(this.selectedPointLabelId, person);
            
            // Clear search
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            // Remove focus from search input so 'n' key can be used
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.blur();
              }
            });
          }
        },
        initializeHouseholdCheckboxes(person) {
          // Initialize household checkboxes from per-bounding-box checked list
          this.householdCheckboxes = {};
          const groups = this.getHouseholdGroups(person);
          groups.forEach(group => {
            group.members.forEach(member => {
              if (member.id) {
                // Check per-bounding-box list for checked state
                this.householdCheckboxes[member.id] = this.isPersonChecked(member.id);
              }
            });
          });
        },
        // Get the face label key for the currently selected bounding box
        getCurrentFaceLabelKey() {
          return Utils.getCurrentFaceLabelKey(this.selectedFile, this.selectedBoundingBoxIndex);
        },
        // Get checked people for a specific bounding box
        getCheckedPeopleForBox(faceLabelKey) {
          return Utils.getCheckedPeopleForBox(this.checkedPeopleByBox, faceLabelKey);
        },
        // Set checked state for a person in a specific bounding box
        setPersonCheckedForBox(faceLabelKey, personId, checked) {
          if (!faceLabelKey || !personId) return;
          if (!this.checkedPeopleByBox[faceLabelKey]) {
            this.checkedPeopleByBox[faceLabelKey] = {};
          }
          if (checked) {
            this.checkedPeopleByBox[faceLabelKey][personId] = true;
          } else {
            delete this.checkedPeopleByBox[faceLabelKey][personId];
          }
        },
        // Check if a person is checked for the current bounding box
        isPersonChecked(personId) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          return Utils.isPersonChecked(this.checkedPeopleByBox, faceLabelKey, personId);
        },
        handleSelectedPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentFaceLabel();
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (currentLabel && currentLabel.id && faceLabelKey) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update per-bounding-box checked list
            this.setPersonCheckedForBox(faceLabelKey, currentLabel.id, checked);
            
            if (!checked) {
              // Uncheck all household checkboxes for this box
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.setPersonCheckedForBox(faceLabelKey, member.id, false);
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
              
              // Clear the face label so the bounding box returns to unselected (yellow) state
              if (this.faceLabels && this.faceLabels[faceLabelKey]) {
                delete this.faceLabels[faceLabelKey];
              }
              if (this.currentSessionLabels && this.currentSessionLabels[faceLabelKey]) {
                delete this.currentSessionLabels[faceLabelKey];
              }
              
              // Deselect the bounding box so it's no longer in selected state (not blinking)
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              
              // Force update to refresh the bounding box color
              this.$forceUpdate();
            } else {
              // When re-checking, restore household checkbox states from per-box list
              this.initializeHouseholdCheckboxes(currentLabel);
            }
          }
        },
        handleHouseholdCheckboxChange(memberId, event) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          if (memberId && faceLabelKey) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update per-bounding-box checked list
            this.setPersonCheckedForBox(faceLabelKey, memberId, checked);
          }
        },
        getHouseholdCheckboxState(memberId) {
          const faceLabelKey = this.getCurrentFaceLabelKey();
          return Utils.getHouseholdCheckboxState(this.checkedPeopleByBox, faceLabelKey, memberId, this.householdCheckboxes);
        },
        getSelectedPersonCheckedState() {
          return Utils.getSelectedPersonCheckedState(this.selectedFile, this.selectedBoundingBoxIndex, this.faceLabels, this.checkedPeopleByBox, this.selectedPersonChecked);
        },
        getSelectedPointPersonCheckedState() {
          return Utils.getSelectedPointPersonCheckedState(this.selectedPointLabelId, this.pointLabelPersons, this.checkedPeopleByPoint, this.selectedPersonChecked);
        },
        handleSelectedPointPersonCheckboxChange(event) {
          const currentLabel = this.getCurrentPointLabel();
          if (currentLabel && currentLabel.id && this.selectedPointLabelId) {
            const checked = event.target.checked;
            // Update local state
            this.selectedPersonChecked = checked;
            // Update per-point checked list
            this.setPersonCheckedForPoint(this.selectedPointLabelId, currentLabel.id, checked);
            
            if (!checked) {
              // Uncheck all household checkboxes for this point
              const groups = this.getHouseholdGroups(currentLabel);
              groups.forEach(group => {
                group.members.forEach(member => {
                  if (member.id) {
                    this.setPersonCheckedForPoint(this.selectedPointLabelId, member.id, false);
                  }
                });
              });
              // Update local checkboxes
              this.householdCheckboxes = {};
              
              // Clear the point label person
              if (this.pointLabelPersons && this.pointLabelPersons[this.selectedPointLabelId]) {
                delete this.pointLabelPersons[this.selectedPointLabelId];
              }
              
              // Store the point ID before clearing selection
              const pointIdToDelete = this.selectedPointLabelId;
              
              // Deselect the point label so it's no longer in selected state (not blinking)
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              
              // Delete the point label since there's no person selected
              this.deletePointLabel(pointIdToDelete);
              
              // Force update to refresh the UI
              this.$forceUpdate();
            } else {
              // When re-checking, restore household checkbox states from per-point list
              this.initializeHouseholdCheckboxesForPoint(this.selectedPointLabelId, currentLabel);
            }
          }
        },
        handlePointHouseholdCheckboxChange(memberId, event) {
          if (memberId && this.selectedPointLabelId) {
            const checked = event.target.checked;
            // Update local checkbox state
            this.householdCheckboxes[memberId] = checked;
            // Update per-point checked list
            this.setPersonCheckedForPoint(this.selectedPointLabelId, memberId, checked);
          }
        },
        getPointHouseholdCheckboxState(memberId) {
          if (!this.selectedPointLabelId || !memberId) return false;
          // Check per-point list first, then local state
          const checkedPeople = this.checkedPeopleByPoint[this.selectedPointLabelId] || {};
          if (checkedPeople.hasOwnProperty(memberId)) {
            return checkedPeople[memberId];
          }
          return this.householdCheckboxes[memberId] || false;
        },
        getEmbeddingsCountDisplay() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          return this.embeddingsCountCache[currentLabel.id] || 0;
        },
        async getEmbeddingsCount() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) return 0;
          
          // Check cache first
          if (this.embeddingsCountCache[currentLabel.id] !== undefined) {
            return this.embeddingsCountCache[currentLabel.id];
          }
          
          // Fetch from service
          try {
            const count = await Services.embedding.getEmbeddingsCount(currentLabel.id);
            this.embeddingsCountCache[currentLabel.id] = count;
            // Force update to refresh UI
            this.$forceUpdate();
            return count;
          } catch (error) {
            console.error('Error fetching embeddings count:', error);
            return 0;
          }
        },
        getEmbeddingsStoredState() {
          return Utils.getEmbeddingsStoredState(this.selectedFile, this.selectedBoundingBoxIndex, this.embeddingsStored);
        },
        loadEmbeddingData() {
          // Load the embedding data for the current bounding box
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile || !this.selectedFile.model) {
            this.currentEmbeddingData = null;
            return;
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              this.currentEmbeddingData = null;
              return;
            }
            
            const embedding = model.embeddings[this.selectedBoundingBoxIndex];
            if (embedding && embedding.embedding) {
              this.currentEmbeddingData = embedding.embedding;
            } else {
              this.currentEmbeddingData = null;
            }
          } catch (error) {
            console.error('Error loading embedding data:', error);
            this.currentEmbeddingData = null;
          }
        },
        async checkEmbeddingInDB() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Get the key for this bounding box
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (!key) {
            this.checkingEmbeddingInDB = false;
            return;
          }
          
          // Set loading state
          this.checkingEmbeddingInDB = true;
          this.$forceUpdate();
          
          // If no embedding data, mark as not stored
          if (!this.currentEmbeddingData) {
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
            return;
          }
          
          try {
            const result = await Services.embedding.checkEmbeddingInDB(currentLabel.id, this.currentEmbeddingData);
            
            // Update count cache
            this.embeddingsCountCache[currentLabel.id] = result.count;
            
            // Update stored state
            this.embeddingsStored[key] = result.exists;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          } catch (error) {
            console.error('Error checking embedding in DB:', error);
            // On error, mark as not stored
            this.embeddingsStored[key] = false;
            this.checkingEmbeddingInDB = false;
            this.$forceUpdate();
          }
        },
        encodeEmbeddingToBase64(embedding) {
          return Utils.encodeEmbeddingToBase64(embedding);
        },
        async handleStoreEmbeddings() {
          const currentLabel = this.getCurrentFaceLabel();
          if (!currentLabel || !currentLabel.id || !this.currentEmbeddingData || !this.user) {
            return;
          }
          
          try {
            const result = await Services.embedding.storeEmbedding(currentLabel.id, this.currentEmbeddingData);
            
            if (result.success) {
            // Update stored state
            const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
            if (facialArea) {
              const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
              if (key) {
                this.embeddingsStored[key] = true;
              }
            }
            
            // Update count cache
              this.embeddingsCountCache[currentLabel.id] = result.count;
            
            // Force update to refresh UI
            this.$forceUpdate();
            } else {
              alert('Failed to store embedding: ' + (result.error || 'Unknown error'));
            }
          } catch (error) {
            console.error('Error storing embedding:', error);
            alert('Failed to store embedding: ' + error.message);
          }
        },
        getFacialAreaForIndex(embeddingIndex) {
          if (!this.selectedFile || !this.selectedFile.model) return null;
          return Utils.getFacialAreaForIndex(this.selectedFile.model, embeddingIndex);
        },
        getCurrentFaceLabel() {
          return Utils.getCurrentFaceLabel(this.selectedFile, this.selectedBoundingBoxIndex, this.faceLabels);
        },
        getCurrentPointLabel() {
          return Utils.getCurrentPointLabel(this.selectedPointLabelId, this.pointLabelPersons);
        },
        isPersonCheckedForPoint(pointLabelId, personId) {
          return Utils.isPersonCheckedForPoint(this.checkedPeopleByPoint, pointLabelId, personId);
        },
        setPersonCheckedForPoint(pointLabelId, personId, checked) {
          if (!pointLabelId || !personId) return;
          if (!this.checkedPeopleByPoint[pointLabelId]) {
            this.checkedPeopleByPoint[pointLabelId] = {};
          }
          this.checkedPeopleByPoint[pointLabelId][personId] = checked;
        },
        initializeHouseholdCheckboxesForPoint(pointLabelId, person) {
          if (!pointLabelId || !person || !this.getHouseholdMembers) return;
          const householdMembers = this.getHouseholdMembers(person);
          this.householdCheckboxes = {};
          householdMembers.forEach(member => {
            if (member && member.id) {
              this.householdCheckboxes[member.id] = this.isPersonCheckedForPoint(pointLabelId, member.id);
            }
          });
        },
        clearCurrentFaceLabel() {
          if (this.selectedBoundingBoxIndex === null || !this.selectedFile) return;
          const facialArea = this.getFacialAreaForIndex(this.selectedBoundingBoxIndex);
          if (!facialArea) return;
          const key = this.getFaceLabelKey(this.selectedFile.name, facialArea);
          if (key) {
            delete this.faceLabels[key];
            delete this.currentSessionLabels[key];
            // Clear selection
            this.selectedBoundingBoxIndex = null;
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
          }
        },
        clearCurrentPointLabel() {
          if (this.selectedPointLabelId === null) return;
          if (this.pointLabelPersons && this.pointLabelPersons[this.selectedPointLabelId]) {
            delete this.pointLabelPersons[this.selectedPointLabelId];
          }
          // Clear selection
          this.selectedPointLabelId = null;
          this.searchQuery = '';
          this.searchResults = [];
          this.selectedSearchIndex = -1;
        },
        deletePointLabel(pointId) {
          if (!pointId || !this.selectedFile) return;
          
          const imageName = this.selectedFile.name;
          if (this.pointLabels[imageName]) {
            // Remove the point from the array
            this.pointLabels[imageName] = this.pointLabels[imageName].filter(point => point.id !== pointId);
            
            // If array is empty, remove the image entry
            if (this.pointLabels[imageName].length === 0) {
              delete this.pointLabels[imageName];
            }
          }
          
          // Clean up associated data
          if (this.pointLabelPersons && this.pointLabelPersons[pointId]) {
            delete this.pointLabelPersons[pointId];
          }
          if (this.checkedPeopleByPoint && this.checkedPeopleByPoint[pointId]) {
            delete this.checkedPeopleByPoint[pointId];
          }
        },
        setupKeyboardNavigation() {
          document.addEventListener('keydown', this.handleKeydown);
        },
        handleKeydown(event) {
          // Only handle arrow keys when user is logged in and not loading
          if (!this.user || this.loading) return;
          
          // Handle ESC key to deselect bounding box or point label (works even in input fields)
          if (event.key === 'Escape') {
            if (this.selectedBoundingBoxIndex !== null) {
              event.preventDefault();
              this.selectedBoundingBoxIndex = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              return;
            }
            if (this.selectedPointLabelId !== null) {
              event.preventDefault();
              // Check if there's a person selected before deselecting
              const currentLabel = this.getCurrentPointLabel();
              const pointId = this.selectedPointLabelId;
              this.selectedPointLabelId = null;
              this.searchQuery = '';
              this.searchResults = [];
              this.selectedSearchIndex = -1;
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
              
              // If no person selected, delete the point label
              if (!currentLabel) {
                this.deletePointLabel(pointId);
              }
              return;
            }
          }
          
          // Handle 'Tab' key to go to next bounding box (works even in input fields when box is selected)
          if (event.key === 'Tab' && this.selectedBoundingBoxIndex !== null && this.showFaces && this.selectedFile && this.selectedFile.model) {
            event.preventDefault();
            this.goToNextBoundingBox();
            return;
          }
          
          // Handle 'a' key to add embedding (only when person is selected and button is enabled)
          if (event.key === 'a' || event.key === 'A') {
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel && currentLabel.id && this.currentEmbeddingData && this.user && 
                !this.checkingEmbeddingInDB && !this.getEmbeddingsStoredState()) {
              event.preventDefault();
              this.handleStoreEmbeddings();
              return;
            }
          }
          
          // Don't handle if user is typing in an input field or textarea (except ESC, Tab, and 'a')
          if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            // ESC, Tab, and 'a' keys are handled above, but for other keys, return early
            // Allow arrow keys in search input to be handled by handleSearchKeydown
            return;
          }
          
          switch(event.key) {
            case 'ArrowLeft':
              event.preventDefault();
              if (this.hasPrevImage) {
                this.bannerVisible = true;
                // Emit event to trigger prev image navigation
                this.$refs.imageAnnotationPanel?.goPrevImage();
              }
              break;
            case 'ArrowRight':
              event.preventDefault();
              if (this.hasNextImage) {
                this.bannerVisible = true;
                // Emit event to trigger next image navigation
                this.$refs.imageAnnotationPanel?.goNextImage();
              }
              break;
          }
        },
        goToNextBoundingBox() {
          if (!this.selectedFile || !this.selectedFile.model) return;
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return;
            }
            
            // Get all embedding indices that have facial areas
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => embedding.facial_area);
            
            if (embeddingsWithFaces.length === 0) return;
            
            // Find current index in the list
            const currentIndex = embeddingsWithFaces.findIndex(
              ({ index }) => index === this.selectedBoundingBoxIndex
            );
            
            if (currentIndex === -1) {
              // Current selection not found, select first one
              this.selectedBoundingBoxIndex = embeddingsWithFaces[0].index;
            } else {
              // Go to next, wrap around if at end
              const nextIndex = (currentIndex + 1) % embeddingsWithFaces.length;
              this.selectedBoundingBoxIndex = embeddingsWithFaces[nextIndex].index;
            }
            
            // Reset search and focus input
            this.searchQuery = '';
            this.searchResults = [];
            this.selectedSearchIndex = -1;
            
            // Initialize checkboxes from global list if there's already a label
            const currentLabel = this.getCurrentFaceLabel();
            if (currentLabel) {
              // Check global list for selected person's checked state
              this.selectedPersonChecked = this.isPersonChecked(currentLabel.id);
              this.initializeHouseholdCheckboxes(currentLabel);
            } else {
              // No label yet, default to checked
              this.selectedPersonChecked = true;
              this.householdCheckboxes = {};
            }
            
            // Focus the search input
            this.$nextTick(() => {
              if (this.$refs.searchInput) {
                this.$refs.searchInput.focus();
              }
            });
          } catch (error) {
            console.error('Error navigating to next bounding box:', error);
          }
        },
      },
      computed: {
        sessions() {
          // Return only root-level directories (sessions), sorted from latest to earliest
          const dirs = this.directoryTree.filter(node => node.type === 'directory');
          // Sort from latest to earliest (descending order)
          const sorted = Array.from(dirs);
          sorted.sort((a, b) => {
            // Try to parse as dates if they look like dates, otherwise use string comparison
            const dateA = new Date(a.name);
            const dateB = new Date(b.name);
            
            // If both are valid dates, compare as dates
            if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
              return dateB - dateA; // Descending: later dates first
            }
            
            // Otherwise use string comparison (descending)
            return b.name.localeCompare(a.name);
          });
          return sorted;
        },
        hasPrevImage() {
          return this.currentFileIndex > 0;
        },
        hasNextImage() {
          return this.currentFileIndex >= 0 && this.currentFileIndex < this.currentFolderFiles.length - 1;
        }
      },
      mounted() {
        // Auto-scroll down 1px to trigger URL bar hiding on mobile
        setTimeout(() => {
          window.scrollTo(0, 1);
          // Scroll back to top after a moment (URL bar will stay hidden)
          setTimeout(() => {
            window.scrollTo(0, 0);
          }, 100);
        }, 100);
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
          // Re-trigger scroll to hide URL bar after orientation change
          setTimeout(() => {
            window.scrollTo(0, 1);
            setTimeout(() => {
              window.scrollTo(0, 0);
            }, 100);
            // Force resize event
            window.dispatchEvent(new Event('resize'));
          }, 300);
        });
        
        // Listen for authentication state changes
        Services.auth.onAuthStateChanged((user) => {
          this.user = user;
          this.loading = false;
          if (user) {
            this.fetchDirectoryTree();
          }
        });
        
        // Add keyboard navigation
        this.setupKeyboardNavigation();
      },
      beforeUnmount() {
        // Clean up keyboard event listeners
        document.removeEventListener('keydown', this.handleKeydown);
      },
    });


    app.component('image-annotation', {
      props: ['imageSrc', 'annotations', 'selectedFile', 'showFaces', 'faceLabels', 'selectedBoundingBoxIndex', 'pointLabels', 'selectedPointLabelId', 'pointLabelPersons', 'checkedPeopleByPoint', 'getFaceLabelKey', 'checkedPeopleByBox', 'planningCentrePeople', 'getHouseholdMembers'],
      template: `<div class="w-full h-full flex items-center justify-center relative">
        <div v-if="isLoading" class="loading-container">
          <div class="spinner"></div>
          <p>Loading image...</p>
        </div>
        <v-stage v-else :config="stageConfig" @mousedown="handleStageClick" @mousemove="handleStageMouseMove" @mouseleave="handleStageMouseLeave">
          <v-layer>
            <v-image :config="imageConfig"></v-image>
            <v-rect v-for="(box, index) in facialAreaBoxes" :key="index" :config="box" @click="handleBoxClick(box.embeddingIndex)"></v-rect>
            <v-group v-for="(label, index) in nameLabels" :key="'name-' + index" :config="{ x: label.groupX, y: label.groupY }">
              <v-rect :config="label.bgRect"></v-rect>
              <v-text v-for="(textItem, textIndex) in label.texts" :key="'text-' + textIndex" :config="textItem"></v-text>
            </v-group>
            <v-rect v-for="(box, index) in annotations" :key="'annotation-' + index" :config="box"></v-rect>
            <v-rect v-for="(pointGroup, index) in pointLabelGroups" :key="'point-box-' + index" :config="pointGroup.boundingBox" @click="handlePointLabelClick(pointGroup.id)"></v-rect>
            <v-text v-for="(pointGroup, index) in pointLabelGroups" :key="'point-marker-' + index" :config="pointGroup.marker"></v-text>
            <v-group v-for="(label, index) in pointNameLabels" :key="'point-name-' + index" :config="{ x: label.groupX, y: label.groupY }">
              <v-rect :config="label.bgRect"></v-rect>
              <v-text v-for="(textItem, textIndex) in label.texts" :key="'point-text-' + textIndex" :config="textItem"></v-text>
            </v-group>
            <v-group v-if="panTiltZoomConfig" :config="{ x: panTiltZoomConfig.groupX, y: panTiltZoomConfig.groupY }">
              <v-rect :config="panTiltZoomConfig.bgRect"></v-rect>
              <v-text :config="panTiltZoomConfig.text"></v-text>
            </v-group>
          </v-layer>
        </v-stage>
        <div v-if="showShiftTooltip" :style="{ position: 'absolute', left: tooltipX + 'px', top: tooltipY + 'px', pointerEvents: 'none', zIndex: 1000, backgroundColor: 'rgba(0, 0, 0, 0.8)', color: 'white', padding: '4px 8px', borderRadius: '4px', fontSize: '12px', whiteSpace: 'nowrap' }">
          Left Click to Add Name
        </div>
      </div>`,
      data() {
        return {
          stageConfig: { width: 800, height: 600 },
          imageConfig: { image: null, x: 0, y: 0, width: 800, height: 600 },
          isLoading: false,
          containerWidth: 0,
          containerHeight: 0,
          selectedBoxOpacity: 1,
          selectedPointOpacity: 1,
          blinkInterval: null,
          pointBlinkInterval: null,
          showShiftTooltip: false,
          tooltipX: 0,
          tooltipY: 0
        };
      },
      computed: {
        facialAreaBoxes() {
          // Return empty array if showFaces is false
          if (!this.showFaces) {
            return [];
          }
          
          if (!this.selectedFile || !this.selectedFile.model || !this.imageConfig.image) {
            return [];
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings)) {
              return [];
            }
            
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            // Calculate scale factors
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            const embeddingsWithFaces = model.embeddings
              .map((embedding, idx) => ({ embedding, index: idx }))
              .filter(({ embedding }) => {
                // Filter out embeddings without facial_area
                if (!embedding.facial_area) {
                  return false;
                }
                // Exclude bounding boxes that are approximately the same size as the entire image
                // Use a threshold of 10 pixels
                const area = embedding.facial_area;
                const areaWidth = area.w || 0;
                const areaHeight = area.h || 0;
                const widthDiff = Math.abs(areaWidth - naturalWidth);
                const heightDiff = Math.abs(areaHeight - naturalHeight);
                if (widthDiff <= 1 && heightDiff <= 1) {
                  return false; // Exclude this box - it covers the entire image (within 1px threshold)
                }
                return true;
              });
            
            return embeddingsWithFaces.map(({ embedding, index }) => {
              const area = embedding.facial_area;
              const x = (area.x || 0) * scaleX;
              const y = (area.y || 0) * scaleY;
              const width = (area.w || 0) * scaleX;
              const height = (area.h || 0) * scaleY;
              
              const isSelected = this.selectedBoundingBoxIndex === index;
              
              // Check if this face has a label using the new key format
              let hasLabel = false;
              if (this.selectedFile && this.getFaceLabelKey && this.faceLabels) {
                const key = this.getFaceLabelKey(this.selectedFile.name, area);
                hasLabel = key ? !!this.faceLabels[key] : false;
              }
              
              // Color logic: Amber for unlabelled, Soft Green for labelled
              // Selected boxes blink with color based on label status
              let strokeColor = '#FFD700'; // Amber - Not Labelled (default)
              let strokeWidth = 2;
              let opacity = 1;
              
              if (isSelected) {
                // Selected box: use green if labelled, amber if not labelled
                strokeColor = hasLabel ? '#10B981' : '#FFD700'; // Soft Green if labelled, Amber if not
                strokeWidth = 4; // Thicker for visibility
                opacity = this.selectedBoxOpacity; // Blinking opacity
              } else if (hasLabel) {
                strokeColor = '#10B981'; // Soft Green - Labelled
                strokeWidth = 2;
                opacity = 1;
              } else {
                strokeColor = '#FFD700'; // Amber - Not Labelled
                strokeWidth = 2;
                opacity = 1;
              }
              
              return {
                x: x,
                y: y,
                width: width,
                height: height,
                stroke: strokeColor,
                strokeWidth: strokeWidth,
                fill: 'transparent',
                opacity: opacity,
                embeddingIndex: index
              };
            });
          } catch (error) {
            console.error('Error parsing facial areas from model:', error);
            return [];
          }
        },
        nameLabels() {
          // Return empty array if showFaces is false
          if (!this.showFaces || !this.selectedFile || !this.selectedFile.model) {
            return [];
          }
          
          try {
            const model = typeof this.selectedFile.model === 'string' 
              ? JSON.parse(this.selectedFile.model) 
              : this.selectedFile.model;
            
            if (!model.embeddings || !Array.isArray(model.embeddings) || !this.imageConfig.image) {
              return [];
            }
            
            // Get image dimensions and scale factors
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;
            
            // Filter embeddings that have facial_area
            const embeddingsWithFaces = model.embeddings
              .map((embedding, index) => ({ embedding, index }))
              .filter(({ embedding }) => embedding.facial_area);
            
            const allLabels = [];
            
            embeddingsWithFaces.forEach(({ embedding, index }) => {
              const area = embedding.facial_area;
              const x = (area.x || 0) * scaleX;
              const y = (area.y || 0) * scaleY;
              const width = (area.w || 0) * scaleX;
              const height = (area.h || 0) * scaleY;
              
              // Get the face label key for this bounding box
              let key = null;
              if (this.selectedFile && this.getFaceLabelKey) {
                key = this.getFaceLabelKey(this.selectedFile.name, area);
              }
              
              if (!key) return;
              
              // Get the identified person from faceLabels (for vector-matched faces)
              const identifiedPerson = this.faceLabels && this.faceLabels[key] ? this.faceLabels[key] : null;
              
              // Get checked people for this bounding box
              const checkedPeople = this.checkedPeopleByBox && this.checkedPeopleByBox[key] ? this.checkedPeopleByBox[key] : {};
              const checkedPersonIds = Object.keys(checkedPeople).filter(personId => checkedPeople[personId]);
              
              // If there's an identified person, include them even if not explicitly checked
              if (identifiedPerson && identifiedPerson.id && !checkedPersonIds.includes(identifiedPerson.id)) {
                checkedPersonIds.push(identifiedPerson.id);
              }
              
              if (checkedPersonIds.length === 0) return; // No checked people, don't show label
              
              // Get person objects for all checked people
              const checkedPersons = checkedPersonIds
                .map(personId => {
                  if (!this.planningCentrePeople) return null;
                  return this.planningCentrePeople.find(p => p.id === personId);
                })
                .filter(p => p !== null);
              
              if (checkedPersons.length === 0) return;
              
              // Separate selected person from household members
              let selectedPerson = null;
              let householdMembers = [];
              
              if (identifiedPerson) {
                // Use identified person as selected person
                selectedPerson = identifiedPerson;
                // Get household members from checked people (excluding selected person)
                householdMembers = checkedPersons.filter(p => p.id !== identifiedPerson.id);
              } else {
                // No identified person, use first checked person as selected
                selectedPerson = checkedPersons[0];
                householdMembers = checkedPersons.slice(1);
              }
              
              if (!selectedPerson || !selectedPerson.name) return;
              
              // Build text lines: selected person on first line, each household member on separate lines
              const fontSize = 12;
              const padding = 4;
              const lineHeight = fontSize + 2; // Line height with spacing
              
              const texts = [];
              texts.push({
                x: padding,
                y: padding,
                text: selectedPerson.name,
                fontSize: fontSize,
                fontFamily: 'Arial',
                fill: '#D3D3D3', // Light grey
                align: 'left'
              });
              
              // Add each household member on a separate line
              householdMembers.forEach((member, index) => {
                if (member && member.name) {
                  texts.push({
                    x: padding,
                    y: padding + (index + 1) * lineHeight,
                    text: member.name,
                    fontSize: fontSize,
                    fontFamily: 'Arial',
                    fill: '#D3D3D3', // Light grey
                    align: 'left'
                  });
                }
              });
              
              // Calculate dimensions for background
              const allNames = [selectedPerson.name, ...householdMembers.map(p => p.name).filter(name => name)];
              const maxTextWidth = Math.max(...allNames.map(name => name.length * fontSize * 0.6));
              const textHeight = texts.length * lineHeight + padding;
              const textWidth = maxTextWidth;
              
              // Center the group horizontally below the box
              const groupX = x + (width - textWidth) / 2 - padding; // Center horizontally
              const groupY = y + height + 2; // 2px below the box
              
              allLabels.push({
                groupX: groupX,
                groupY: groupY,
                bgRect: {
                  x: 0,
                  y: 0,
                  width: textWidth + padding * 2,
                  height: textHeight,
                  fill: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black background
                  cornerRadius: 2
                },
                texts: texts
              });
            });
            
            return allLabels;
          } catch (error) {
            console.error('Error creating name labels:', error);
            return [];
          }
        },
        pointLabelGroups() {
          if (!this.selectedFile || !this.pointLabels || !this.imageConfig.image) {
            return [];
          }
          
          const imageName = this.selectedFile.name;
          const points = this.pointLabels[imageName] || [];
          
          if (points.length === 0) {
            return [];
          }
          
          const img = this.imageConfig.image;
          const naturalWidth = img.naturalWidth;
          const naturalHeight = img.naturalHeight;
          const displayWidth = this.imageConfig.width;
          const displayHeight = this.imageConfig.height;
          
          const scaleX = displayWidth / naturalWidth;
          const scaleY = displayHeight / naturalHeight;
          
          return points.map(point => {
            const x = point.naturalX * scaleX;
            const y = point.naturalY * scaleY;
            const isSelected = this.selectedPointLabelId === point.id;
            
            // Check if this point has a person selected
            const hasPerson = this.pointLabelPersons && this.pointLabelPersons[point.id] ? true : false;
            
            // Marker size and offset
            const fontSize = isSelected ? 24 : 16;
            const offsetX = isSelected ? 12 : 8;
            const offsetY = isSelected ? 12 : 8;
            
            // Bounding box around the marker (larger clickable area)
            const boxSize = isSelected ? 40 : 32; // Larger box when selected
            const boxX = x - boxSize / 2;
            const boxY = y - boxSize / 2;
            // Color logic: 
            // - Selected + no person: Blinking Yellow (#FFD700)
            // - Selected + has person: Blinking Green (#10B981)
            // - Not selected + has person: Solid Green (#10B981)
            // - Not selected + no person: Should not exist (point should be deleted)
            const boxColor = hasPerson ? '#10B981' : '#FFD700'; // Green if person selected, Yellow if not
            // Opacity: Blinking when selected, solid when not selected
            const boxOpacity = isSelected ? this.selectedPointOpacity : 1;
            
            return {
              id: point.id,
              boundingBox: {
                x: boxX,
                y: boxY,
                width: boxSize,
                height: boxSize,
                fill: 'transparent',
                stroke: boxColor,
                strokeWidth: isSelected ? 3 : 2,
                opacity: boxOpacity
              },
              marker: {
                x: x,
                y: y,
                text: '', // &#9678; character
                fontSize: fontSize,
                fontFamily: 'Arial',
                fill: boxColor,
                align: 'center',
                verticalAlign: 'middle',
                offsetX: offsetX,
                offsetY: offsetY,
                opacity: boxOpacity,
                listening: false // Marker itself doesn't need to be clickable, the box handles it
              }
            };
          });
        },
        pointNameLabels() {
          if (!this.selectedFile || !this.pointLabels || !this.pointLabelPersons || !this.imageConfig.image) {
            return [];
          }
          
          const imageName = this.selectedFile.name;
          const points = this.pointLabels[imageName] || [];
          
          if (points.length === 0) {
            return [];
          }
          
          const img = this.imageConfig.image;
          const naturalWidth = img.naturalWidth;
          const naturalHeight = img.naturalHeight;
          const displayWidth = this.imageConfig.width;
          const displayHeight = this.imageConfig.height;
          
          const scaleX = displayWidth / naturalWidth;
          const scaleY = displayHeight / naturalHeight;
          
          const allLabels = [];
          
          points.forEach(point => {
            // Get the identified person for this point label
            const identifiedPerson = this.pointLabelPersons[point.id] || null;
            
            if (!identifiedPerson) return; // No person selected, don't show label
            
            // Get checked people for this point label
            const checkedPeople = this.checkedPeopleByPoint && this.checkedPeopleByPoint[point.id] ? this.checkedPeopleByPoint[point.id] : {};
            const checkedPersonIds = Object.keys(checkedPeople).filter(personId => checkedPeople[personId]);
            
            // If there's an identified person, include them even if not explicitly checked
            if (identifiedPerson && identifiedPerson.id && !checkedPersonIds.includes(identifiedPerson.id)) {
              checkedPersonIds.push(identifiedPerson.id);
            }
            
            if (checkedPersonIds.length === 0) return; // No checked people, don't show label
            
            // Get person objects for all checked people
            const checkedPersons = checkedPersonIds
              .map(personId => {
                if (!this.planningCentrePeople) return null;
                return this.planningCentrePeople.find(p => p.id === personId);
              })
              .filter(p => p !== null);
            
            if (checkedPersons.length === 0) return;
            
            // Separate selected person from household members
            let selectedPerson = identifiedPerson;
            let householdMembers = checkedPersons.filter(p => p.id !== identifiedPerson.id);
            
            if (!selectedPerson || !selectedPerson.name) return;
            
            // Calculate position
            const x = point.naturalX * scaleX;
            const y = point.naturalY * scaleY;
            const boxSize = 32; // Default box size for positioning
            
            // Build text lines: selected person on first line, each household member on separate lines
            const fontSize = 12;
            const padding = 4;
            const lineHeight = fontSize + 2; // Line height with spacing
            
            const texts = [];
            texts.push({
              x: padding,
              y: padding,
              text: selectedPerson.name,
              fontSize: fontSize,
              fontFamily: 'Arial',
              fill: '#D3D3D3', // Light grey
              align: 'left'
            });
            
            // Add each household member on a separate line
            householdMembers.forEach((member, index) => {
              if (member && member.name) {
                texts.push({
                  x: padding,
                  y: padding + (index + 1) * lineHeight,
                  text: member.name,
                  fontSize: fontSize,
                  fontFamily: 'Arial',
                  fill: '#D3D3D3', // Light grey
                  align: 'left'
                });
              }
            });
            
            // Calculate dimensions for background
            const allNames = [selectedPerson.name, ...householdMembers.map(p => p.name).filter(name => name)];
            const maxTextWidth = Math.max(...allNames.map(name => name.length * fontSize * 0.6));
            const textHeight = texts.length * lineHeight + padding;
            const textWidth = maxTextWidth;
            
            // Center the group horizontally below the point marker
            const groupX = x - textWidth / 2 - padding; // Center horizontally
            const groupY = y + boxSize / 2 + 2; // 2px below the marker
            
            allLabels.push({
              groupX: groupX,
              groupY: groupY,
              bgRect: {
                x: 0,
                y: 0,
                width: textWidth + padding * 2,
                height: textHeight,
                fill: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black background
                cornerRadius: 2
              },
              texts: texts
            });
          });
          
          return allLabels;
        },
        panTiltZoom() {
          // Extract pan, tilt, zoom from filename
          if (!this.selectedFile || !this.selectedFile.name) {
            return null;
          }
          
          const filename = this.selectedFile.name.toLowerCase();
          
          // Check if it's a JPG file
          if (!filename.endsWith('.jpg') && !filename.endsWith('.jpeg')) {
            return null;
          }
          
          // Pattern to match: panXX.X_tiltXX.X_zoomXX.X (taking first occurrence)
          // Handles negative numbers like pan-34.4
          const panMatch = filename.match(/_pan(-?\d+\.?\d*)/);
          const tiltMatch = filename.match(/_tilt(-?\d+\.?\d*)/);
          const zoomMatch = filename.match(/_zoom(-?\d+\.?\d*)/);
          
          if (panMatch && tiltMatch && zoomMatch) {
            return {
              pan: parseFloat(panMatch[1]),
              tilt: parseFloat(tiltMatch[1]),
              zoom: parseFloat(zoomMatch[1])
            };
          }
          
          return null;
        },
        panTiltZoomConfig() {
          if (!this.panTiltZoom || !this.imageConfig.image) {
            return null;
          }
          
          const { pan, tilt, zoom } = this.panTiltZoom;
          const text = `Pan: ${pan.toFixed(1)} Tilt: ${tilt.toFixed(1)} Zoom: ${zoom.toFixed(1)}`;
          
          // Position in bottom left corner with some padding
          const padding = 10;
          const fontSize = 14;
          const fontFamily = 'Arial';
          
          // Create a temporary canvas to measure text width
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.font = `${fontSize}px ${fontFamily}`;
          const textWidth = ctx.measureText(text).width;
          const textHeight = fontSize;
          
          const textPadding = 6;
          const bgWidth = textWidth + textPadding * 2;
          const bgHeight = textHeight + textPadding * 2;
          
          const groupX = padding;
          const groupY = this.stageConfig.height - bgHeight - padding;
          
          return {
            groupX: groupX,
            groupY: groupY,
            bgRect: {
              x: 0,
              y: 0,
              width: bgWidth,
              height: bgHeight,
              fill: 'rgba(0, 0, 0, 0.5)',
              cornerRadius: 4
            },
            text: {
              x: textPadding,
              y: textPadding,
              text: text,
              fontSize: fontSize,
              fontFamily: fontFamily,
              fill: 'white',
              align: 'left',
              verticalAlign: 'top'
            }
          };
        }
      },
      watch: {
        selectedBoundingBoxIndex: {
          handler(newVal) {
            // Start/stop blinking animation when selection changes
            if (this.blinkInterval) {
              clearInterval(this.blinkInterval);
              this.blinkInterval = null;
            }
            
            if (newVal !== null) {
              // Start blinking animation
              this.selectedBoxOpacity = 1;
              this.blinkInterval = setInterval(() => {
                this.selectedBoxOpacity = this.selectedBoxOpacity === 1 ? 0.3 : 1;
                // Force update to trigger recomputation of facialAreaBoxes
                this.$forceUpdate();
              }, 500); // Blink every 500ms
            } else {
              // Stop blinking
              this.selectedBoxOpacity = 1;
            }
          },
          immediate: false
        },
        selectedPointLabelId: {
          handler(newVal) {
            // Start/stop blinking animation when point label selection changes
            if (this.pointBlinkInterval) {
              clearInterval(this.pointBlinkInterval);
              this.pointBlinkInterval = null;
            }
            
            if (newVal !== null) {
              // Start blinking animation
              this.selectedPointOpacity = 1;
              this.pointBlinkInterval = setInterval(() => {
                this.selectedPointOpacity = this.selectedPointOpacity === 1 ? 0.3 : 1;
                // Force update to trigger recomputation of pointLabelMarkers
                this.$forceUpdate();
              }, 500); // Blink every 500ms
            } else {
              // Stop blinking
              this.selectedPointOpacity = 1;
            }
          },
          immediate: false
        },
        imageSrc: {
          handler(newSrc) {
            if (!newSrc) return;
            this.loadImage(newSrc);
          },
          immediate: true
        },
        selectedFile: {
          handler(newFile, oldFile) {
            // Recalculate boxes when file changes
            this.$nextTick(() => {
              // Force update by accessing the computed property
              this.$forceUpdate();
            });
          },
          deep: true
        },
        'selectedFile.model': {
          handler() {
            // Recalculate boxes when model data is loaded
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          }
        },
        imageConfig: {
          handler() {
            // Recalculate boxes when image dimensions change
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          },
          deep: true
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.updateDimensions();
        });
        window.addEventListener('resize', this.updateDimensions);
        // Listen for Shift key release to hide tooltip
        window.addEventListener('keyup', this.handleKeyUp);
      },
      beforeUnmount() {
        window.removeEventListener('resize', this.updateDimensions);
        window.removeEventListener('keyup', this.handleKeyUp);
        // Clean up blinking intervals
        if (this.blinkInterval) {
          clearInterval(this.blinkInterval);
          this.blinkInterval = null;
        }
        if (this.pointBlinkInterval) {
          clearInterval(this.pointBlinkInterval);
          this.pointBlinkInterval = null;
        }
      },
      methods: {
        handleBoxClick(embeddingIndex) {
          this.$emit('face-box-click', embeddingIndex);
        },
        handleStageMouseMove(event) {
          // Check if Shift key is pressed
          if (event.evt.shiftKey) {
            const stage = event.target.getStage();
            const pointerPos = stage.getPointerPosition();
            
            // Calculate tooltip position relative to the container
            this.tooltipX = pointerPos.x + 10; // Offset to the right of cursor
            this.tooltipY = pointerPos.y - 20; // Offset above cursor
            this.showShiftTooltip = true;
          } else {
            this.showShiftTooltip = false;
          }
        },
        handleStageMouseLeave(event) {
          this.showShiftTooltip = false;
        },
        handleKeyUp(event) {
          // Hide tooltip when Shift is released
          if (event.key === 'Shift') {
            this.showShiftTooltip = false;
          }
        },
        handleStageClick(event) {
          // Check if Shift key is pressed and left mouse button
          if (event.evt.shiftKey && event.evt.button === 0) {
            // Get the stage position
            const stage = event.target.getStage();
            const pointerPos = stage.getPointerPosition();
            
            // Get image dimensions and scale factors
            if (!this.imageConfig.image) return;
            
            const img = this.imageConfig.image;
            const naturalWidth = img.naturalWidth;
            const naturalHeight = img.naturalHeight;
            const displayWidth = this.imageConfig.width;
            const displayHeight = this.imageConfig.height;
            
            const scaleX = naturalWidth / displayWidth;
            const scaleY = naturalHeight / displayHeight;
            
            // Convert display coordinates to natural image coordinates
            const naturalX = pointerPos.x * scaleX;
            const naturalY = pointerPos.y * scaleY;
            
            // Emit event to parent to create point label
            this.$emit('point-label-create', {
              x: pointerPos.x,
              y: pointerPos.y,
              naturalX: naturalX,
              naturalY: naturalY
            });
          }
        },
        handlePointLabelClick(pointId) {
          this.$emit('point-label-click', pointId);
        },
        updateDimensions() {
          // Get the image pane container dimensions
          const imagePane = document.querySelector('.image-pane');
          if (imagePane) {
            this.containerWidth = imagePane.clientWidth;
            this.containerHeight = imagePane.clientHeight;
            console.log('Container dimensions:', this.containerWidth, 'x', this.containerHeight);
            this.calculateOptimalSize();
          } else {
            console.log('Image pane not found');
          }
        },
        calculateOptimalSize() {
          // Use most of the available space, leaving some padding
          const padding = 20;
          const availableWidth = Math.max(400, this.containerWidth - padding);
          const availableHeight = Math.max(300, this.containerHeight - padding);
          
          console.log('Calculating optimal size:', {
            containerWidth: this.containerWidth,
            containerHeight: this.containerHeight,
            availableWidth,
            availableHeight,
            hasImage: !!this.imageConfig.image
          });
          
          // If we have an image loaded, use its natural dimensions
          if (this.imageConfig.image) {
            const img = this.imageConfig.image;
            const imageAspectRatio = img.naturalWidth / img.naturalHeight;
            const containerAspectRatio = availableWidth / availableHeight;
            
            console.log('Image dimensions:', {
              naturalWidth: img.naturalWidth,
              naturalHeight: img.naturalHeight,
              imageAspectRatio,
              containerAspectRatio
            });
            
            let width, height;
            
            if (containerAspectRatio > imageAspectRatio) {
              // Container is wider than image - fit to height
              height = availableHeight;
              width = height * imageAspectRatio;
            } else {
              // Container is taller than image - fit to width
              width = availableWidth;
              height = width / imageAspectRatio;
            }
            
            // Ensure we don't exceed container bounds
            if (width > availableWidth) {
              width = availableWidth;
              height = width / imageAspectRatio;
            }
            if (height > availableHeight) {
              height = availableHeight;
              width = height * imageAspectRatio;
            }
            
            console.log('Calculated dimensions:', { width, height });
            
            // Update stage and image config
            this.stageConfig = { width: Math.floor(width), height: Math.floor(height) };
            this.imageConfig = { 
              ...this.imageConfig, 
              width: Math.floor(width), 
              height: Math.floor(height) 
            };
            
            // Force update to recalculate facial area boxes with new dimensions
            this.$nextTick(() => {
              this.$forceUpdate();
            });
          } else {
            // Default size when no image is loaded
            const defaultWidth = Math.min(800, availableWidth);
            const defaultHeight = Math.min(600, availableHeight);
            
            this.stageConfig = { width: defaultWidth, height: defaultHeight };
            this.imageConfig = { 
              ...this.imageConfig, 
              width: defaultWidth, 
              height: defaultHeight 
            };
          }
        },
        loadImage(imageSrc) {
          this.isLoading = true;
          this.$emit('loading-change', true);
          console.log('Loading image from URL:', imageSrc);
          
          const img = new Image();
          img.crossOrigin = 'anonymous'; // Enable CORS for signed URLs
          img.onload = () => {
            console.log('Image loaded successfully, dimensions:', img.naturalWidth, 'x', img.naturalHeight);
            this.imageConfig.image = img;
            this.isLoading = false;
            this.$emit('loading-change', false);
            // Recalculate dimensions after image loads with proper sizing
            this.$nextTick(() => {
              this.updateDimensions();
            });
          };
          img.onerror = (error) => {
            console.error('Error loading image:', error);
            this.isLoading = false;
            this.$emit('loading-change', false);
          };
          img.src = imageSrc; // Use the signed URL directly
        }
      }
    });

      // Register new components
      app.component('control-side-panel', window.Components.ControlSidePanel);
      app.component('image-annotation-panel', window.Components.ImageAnnotationPanel);
      app.component('check-in-overlay', window.Components.CheckInOverlay);

    app.use(VueKonva);
    const vueApp = app.mount('#app');

    // Setup resizer functionality after Vue app is mounted
    // Setup resizer after Vue app is mounted with a delay to ensure DOM is ready
      setTimeout(Utils.setupResizer, 100);
    })().catch(console.error);
  </script>
</body>
</html>
